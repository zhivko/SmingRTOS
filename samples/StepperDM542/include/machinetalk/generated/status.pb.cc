// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "status.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace pb {

namespace {

const ::google::protobuf::Descriptor* EmcToolData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcToolData_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusMotionAxis_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusMotionAxis_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusConfigAxis_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusConfigAxis_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcProgramExtension_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcProgramExtension_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusAnalogIO_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusAnalogIO_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusDigitalIO_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusDigitalIO_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusGCode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusGCode_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusMCode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusMCode_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusSetting_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusSetting_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusMotion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusMotion_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusIo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusIo_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusTask_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusTask_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusInterp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusInterp_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcCommandParameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcCommandParameters_reflection_ = NULL;
const ::google::protobuf::Descriptor* EmcStatusUserCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmcStatusUserCommand_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcTaskExecStateType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcInterpStateType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcInterpExitCodeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcKinematicsType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcTrajectoryModeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcCanonUnitsType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcTimeUnitsType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcTaskModeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcTaskStateType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcAxisType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcPositionOffsetType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EmcPositionFeedbackType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_status_2eproto() {
  protobuf_AddDesc_status_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "status.proto");
  GOOGLE_CHECK(file != NULL);
  EmcToolData_descriptor_ = file->message_type(0);
  static const int EmcToolData_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, xoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, yoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, zoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, aoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, boffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, coffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, uoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, voffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, woffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, diameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, frontangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, backangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, orientation_),
  };
  EmcToolData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcToolData_descriptor_,
      EmcToolData::default_instance_,
      EmcToolData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcToolData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcToolData));
  EmcStatusMotionAxis_descriptor_ = file->message_type(1);
  static const int EmcStatusMotionAxis_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, fault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, ferror_current_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, ferror_highmark_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, homed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, homing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, inpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, max_hard_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, max_soft_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, min_hard_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, min_soft_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, override_limits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, velocity_),
  };
  EmcStatusMotionAxis_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusMotionAxis_descriptor_,
      EmcStatusMotionAxis::default_instance_,
      EmcStatusMotionAxis_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotionAxis, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusMotionAxis));
  EmcStatusConfigAxis_descriptor_ = file->message_type(2);
  static const int EmcStatusConfigAxis_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, axistype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, backlash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, max_ferror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, max_position_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, min_ferror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, min_position_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, units_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, home_sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, max_acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, max_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, increments_),
  };
  EmcStatusConfigAxis_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusConfigAxis_descriptor_,
      EmcStatusConfigAxis::default_instance_,
      EmcStatusConfigAxis_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfigAxis, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusConfigAxis));
  EmcProgramExtension_descriptor_ = file->message_type(3);
  static const int EmcProgramExtension_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcProgramExtension, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcProgramExtension, extension_),
  };
  EmcProgramExtension_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcProgramExtension_descriptor_,
      EmcProgramExtension::default_instance_,
      EmcProgramExtension_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcProgramExtension, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcProgramExtension, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcProgramExtension));
  EmcStatusAnalogIO_descriptor_ = file->message_type(4);
  static const int EmcStatusAnalogIO_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusAnalogIO, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusAnalogIO, value_),
  };
  EmcStatusAnalogIO_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusAnalogIO_descriptor_,
      EmcStatusAnalogIO::default_instance_,
      EmcStatusAnalogIO_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusAnalogIO, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusAnalogIO, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusAnalogIO));
  EmcStatusDigitalIO_descriptor_ = file->message_type(5);
  static const int EmcStatusDigitalIO_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusDigitalIO, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusDigitalIO, value_),
  };
  EmcStatusDigitalIO_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusDigitalIO_descriptor_,
      EmcStatusDigitalIO::default_instance_,
      EmcStatusDigitalIO_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusDigitalIO, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusDigitalIO, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusDigitalIO));
  EmcStatusLimit_descriptor_ = file->message_type(6);
  static const int EmcStatusLimit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusLimit, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusLimit, value_),
  };
  EmcStatusLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusLimit_descriptor_,
      EmcStatusLimit::default_instance_,
      EmcStatusLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusLimit));
  EmcStatusGCode_descriptor_ = file->message_type(7);
  static const int EmcStatusGCode_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusGCode, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusGCode, value_),
  };
  EmcStatusGCode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusGCode_descriptor_,
      EmcStatusGCode::default_instance_,
      EmcStatusGCode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusGCode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusGCode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusGCode));
  EmcStatusMCode_descriptor_ = file->message_type(8);
  static const int EmcStatusMCode_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMCode, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMCode, value_),
  };
  EmcStatusMCode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusMCode_descriptor_,
      EmcStatusMCode::default_instance_,
      EmcStatusMCode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMCode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMCode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusMCode));
  EmcStatusSetting_descriptor_ = file->message_type(9);
  static const int EmcStatusSetting_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusSetting, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusSetting, value_),
  };
  EmcStatusSetting_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusSetting_descriptor_,
      EmcStatusSetting::default_instance_,
      EmcStatusSetting_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusSetting, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusSetting, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusSetting));
  EmcStatusConfig_descriptor_ = file->message_type(10);
  static const int EmcStatusConfig_offsets_[38] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, default_acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, angular_units_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, axes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, axis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, axis_mask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, cycle_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, debug_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, kinematics_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, linear_units_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_acceleration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, program_units_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, default_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, program_extension_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, position_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, position_feedback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_feed_override_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, min_feed_override_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_spindle_override_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, min_spindle_override_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, default_spindle_speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, default_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, min_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, min_linear_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, default_angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, max_angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, min_angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, increments_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, grids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, lathe_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, geometry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, arcdivision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, no_force_homing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, remote_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, time_units_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, user_command_),
  };
  EmcStatusConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusConfig_descriptor_,
      EmcStatusConfig::default_instance_,
      EmcStatusConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusConfig));
  EmcStatusMotion_descriptor_ = file->message_type(11);
  static const int EmcStatusMotion_offsets_[48] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, active_queue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, actual_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, adaptive_feed_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, ain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, aout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, axis_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, block_delete_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, current_line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, current_vel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, delay_left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, din_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, distance_to_go_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, dout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, dtg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, feed_hold_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, feed_override_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, feedrate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, g5x_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, g5x_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, g92_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, inpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, joint_actual_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, joint_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, motion_line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, motion_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, motion_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, paused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, probe_tripped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, probe_val_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, probed_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, probing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, queue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, queue_full_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, rotation_xy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_brake_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_increasing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_override_enabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindle_speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, spindlerate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, max_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, max_acceleration_),
  };
  EmcStatusMotion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusMotion_descriptor_,
      EmcStatusMotion::default_instance_,
      EmcStatusMotion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusMotion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusMotion));
  EmcStatusIo_descriptor_ = file->message_type(12);
  static const int EmcStatusIo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, estop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, flood_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, lube_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, lube_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, mist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, pocket_prepped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, tool_in_spindle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, tool_offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, tool_table_),
  };
  EmcStatusIo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusIo_descriptor_,
      EmcStatusIo::default_instance_,
      EmcStatusIo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusIo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusIo));
  EmcStatusTask_descriptor_ = file->message_type(13);
  static const int EmcStatusTask_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, echo_serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, exec_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, input_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, optional_stop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, read_line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, task_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, task_paused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, task_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, total_lines_),
  };
  EmcStatusTask_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusTask_descriptor_,
      EmcStatusTask::default_instance_,
      EmcStatusTask_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusTask, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusTask));
  EmcStatusInterp_descriptor_ = file->message_type(14);
  static const int EmcStatusInterp_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, gcodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, interp_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, interpreter_errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, mcodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, settings_),
  };
  EmcStatusInterp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusInterp_descriptor_,
      EmcStatusInterp::default_instance_,
      EmcStatusInterp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusInterp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusInterp));
  EmcCommandParameters_descriptor_ = file->message_type(15);
  static const int EmcCommandParameters_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, debug_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, line_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, enable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, task_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, task_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, traj_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, pose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, tool_data_),
  };
  EmcCommandParameters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcCommandParameters_descriptor_,
      EmcCommandParameters::default_instance_,
      EmcCommandParameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcCommandParameters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcCommandParameters));
  EmcStatusUserCommand_descriptor_ = file->message_type(16);
  static const int EmcStatusUserCommand_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusUserCommand, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusUserCommand, command_),
  };
  EmcStatusUserCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmcStatusUserCommand_descriptor_,
      EmcStatusUserCommand::default_instance_,
      EmcStatusUserCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusUserCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmcStatusUserCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmcStatusUserCommand));
  EmcTaskExecStateType_descriptor_ = file->enum_type(0);
  EmcInterpStateType_descriptor_ = file->enum_type(1);
  EmcInterpExitCodeType_descriptor_ = file->enum_type(2);
  EmcKinematicsType_descriptor_ = file->enum_type(3);
  EmcTrajectoryModeType_descriptor_ = file->enum_type(4);
  EmcCanonUnitsType_descriptor_ = file->enum_type(5);
  EmcTimeUnitsType_descriptor_ = file->enum_type(6);
  EmcTaskModeType_descriptor_ = file->enum_type(7);
  EmcTaskStateType_descriptor_ = file->enum_type(8);
  EmcAxisType_descriptor_ = file->enum_type(9);
  EmcPositionOffsetType_descriptor_ = file->enum_type(10);
  EmcPositionFeedbackType_descriptor_ = file->enum_type(11);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_status_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcToolData_descriptor_, &EmcToolData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusMotionAxis_descriptor_, &EmcStatusMotionAxis::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusConfigAxis_descriptor_, &EmcStatusConfigAxis::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcProgramExtension_descriptor_, &EmcProgramExtension::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusAnalogIO_descriptor_, &EmcStatusAnalogIO::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusDigitalIO_descriptor_, &EmcStatusDigitalIO::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusLimit_descriptor_, &EmcStatusLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusGCode_descriptor_, &EmcStatusGCode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusMCode_descriptor_, &EmcStatusMCode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusSetting_descriptor_, &EmcStatusSetting::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusConfig_descriptor_, &EmcStatusConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusMotion_descriptor_, &EmcStatusMotion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusIo_descriptor_, &EmcStatusIo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusTask_descriptor_, &EmcStatusTask::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusInterp_descriptor_, &EmcStatusInterp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcCommandParameters_descriptor_, &EmcCommandParameters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmcStatusUserCommand_descriptor_, &EmcStatusUserCommand::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_status_2eproto() {
  delete EmcToolData::default_instance_;
  delete EmcToolData_reflection_;
  delete EmcStatusMotionAxis::default_instance_;
  delete EmcStatusMotionAxis_reflection_;
  delete EmcStatusConfigAxis::default_instance_;
  delete EmcStatusConfigAxis_reflection_;
  delete EmcProgramExtension::default_instance_;
  delete EmcProgramExtension_reflection_;
  delete EmcStatusAnalogIO::default_instance_;
  delete EmcStatusAnalogIO_reflection_;
  delete EmcStatusDigitalIO::default_instance_;
  delete EmcStatusDigitalIO_reflection_;
  delete EmcStatusLimit::default_instance_;
  delete EmcStatusLimit_reflection_;
  delete EmcStatusGCode::default_instance_;
  delete EmcStatusGCode_reflection_;
  delete EmcStatusMCode::default_instance_;
  delete EmcStatusMCode_reflection_;
  delete EmcStatusSetting::default_instance_;
  delete EmcStatusSetting_reflection_;
  delete EmcStatusConfig::default_instance_;
  delete EmcStatusConfig_reflection_;
  delete EmcStatusMotion::default_instance_;
  delete EmcStatusMotion_reflection_;
  delete EmcStatusIo::default_instance_;
  delete EmcStatusIo_reflection_;
  delete EmcStatusTask::default_instance_;
  delete EmcStatusTask_reflection_;
  delete EmcStatusInterp::default_instance_;
  delete EmcStatusInterp_reflection_;
  delete EmcCommandParameters::default_instance_;
  delete EmcCommandParameters_reflection_;
  delete EmcStatusUserCommand::default_instance_;
  delete EmcStatusUserCommand_reflection_;
}

void protobuf_AddDesc_status_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_nanopb_2eproto();
  ::pb::protobuf_AddDesc_types_2eproto();
  ::pb::protobuf_AddDesc_preview_2eproto();
  ::pb::protobuf_AddDesc_emcclass_2eproto();
  ::pb::protobuf_AddDesc_motcmds_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014status.proto\022\002pb\032\014nanopb.proto\032\013types."
    "proto\032\rpreview.proto\032\016emcclass.proto\032\rmo"
    "tcmds.proto\"\227\002\n\013EmcToolData\022\r\n\005index\030\001 \002"
    "(\005\022\n\n\002id\030\002 \001(\005\022\017\n\007xOffset\030\003 \001(\001\022\017\n\007yOffs"
    "et\030\004 \001(\001\022\017\n\007zOffset\030\005 \001(\001\022\017\n\007aOffset\030\006 \001"
    "(\001\022\017\n\007bOffset\030\007 \001(\001\022\017\n\007cOffset\030\010 \001(\001\022\017\n\007"
    "uOffset\030\t \001(\001\022\017\n\007vOffset\030\n \001(\001\022\017\n\007wOffse"
    "t\030\013 \001(\001\022\020\n\010diameter\030\014 \001(\001\022\022\n\nfrontangle\030"
    "\r \001(\001\022\021\n\tbackangle\030\016 \001(\001\022\023\n\013orientation\030"
    "\017 \001(\005:\006\222\?\003H\314\010\"\325\002\n\023EmcStatusMotionAxis\022\r\n"
    "\005index\030\001 \002(\005\022\017\n\007enabled\030\002 \001(\010\022\r\n\005fault\030\003"
    " \001(\010\022\026\n\016ferror_current\030\004 \001(\001\022\027\n\017ferror_h"
    "ighmark\030\005 \001(\001\022\r\n\005homed\030\006 \001(\010\022\016\n\006homing\030\007"
    " \001(\010\022\r\n\005inpos\030\010 \001(\010\022\r\n\005input\030\t \001(\001\022\026\n\016ma"
    "x_hard_limit\030\n \001(\010\022\026\n\016max_soft_limit\030\013 \001"
    "(\010\022\026\n\016min_hard_limit\030\014 \001(\010\022\026\n\016min_soft_l"
    "imit\030\r \001(\010\022\016\n\006output\030\016 \001(\001\022\027\n\017override_l"
    "imits\030\017 \001(\010\022\020\n\010velocity\030\020 \001(\001:\006\222\?\003H\315\010\"\253\002"
    "\n\023EmcStatusConfigAxis\022\r\n\005index\030\001 \002(\005\022!\n\010"
    "axisType\030\002 \001(\0162\017.pb.EmcAxisType\022\020\n\010backl"
    "ash\030\003 \001(\001\022\022\n\nmax_ferror\030\004 \001(\001\022\032\n\022max_pos"
    "ition_limit\030\005 \001(\001\022\022\n\nmin_ferror\030\006 \001(\001\022\032\n"
    "\022min_position_limit\030\007 \001(\001\022\r\n\005units\030\010 \001(\001"
    "\022\025\n\rhome_sequence\030\t \001(\005\022\030\n\020max_accelerat"
    "ion\030\n \001(\001\022\024\n\014max_velocity\030\013 \001(\001\022\022\n\nincre"
    "ments\030\014 \001(\t:\006\222\?\003H\316\010\"\?\n\023EmcProgramExtensi"
    "on\022\r\n\005index\030\001 \002(\005\022\021\n\textension\030\002 \001(\t:\006\222\?"
    "\003H\317\010\"9\n\021EmcStatusAnalogIO\022\r\n\005index\030\001 \002(\005"
    "\022\r\n\005value\030\002 \001(\001:\006\222\?\003H\320\010\":\n\022EmcStatusDigi"
    "talIO\022\r\n\005index\030\001 \002(\005\022\r\n\005value\030\002 \001(\010:\006\222\?\003"
    "H\321\010\"6\n\016EmcStatusLimit\022\r\n\005index\030\001 \002(\005\022\r\n\005"
    "value\030\002 \001(\005:\006\222\?\003H\322\010\"6\n\016EmcStatusGCode\022\r\n"
    "\005index\030\001 \002(\005\022\r\n\005value\030\002 \001(\005:\006\222\?\003H\323\010\"6\n\016E"
    "mcStatusMCode\022\r\n\005index\030\001 \002(\005\022\r\n\005value\030\002 "
    "\001(\005:\006\222\?\003H\324\010\"8\n\020EmcStatusSetting\022\r\n\005index"
    "\030\001 \002(\005\022\r\n\005value\030\002 \001(\001:\006\222\?\003H\325\010\"\346\010\n\017EmcSta"
    "tusConfig\022\034\n\024default_acceleration\030\001 \001(\001\022"
    "\025\n\rangular_units\030\002 \001(\001\022\014\n\004axes\030\003 \001(\005\022%\n\004"
    "axis\030\004 \003(\0132\027.pb.EmcStatusConfigAxis\022\021\n\ta"
    "xis_mask\030\005 \001(\005\022\022\n\ncycle_time\030\006 \001(\001\022\r\n\005de"
    "bug\030\007 \001(\005\022.\n\017kinematics_type\030\010 \001(\0162\025.pb."
    "EmcKinematicsType\022\024\n\014linear_units\030\t \001(\001\022"
    "\030\n\020max_acceleration\030\n \001(\001\022\024\n\014max_velocit"
    "y\030\013 \001(\001\022,\n\rprogram_units\030\014 \001(\0162\025.pb.EmcC"
    "anonUnitsType\022\030\n\020default_velocity\030\r \001(\001\022"
    "2\n\021program_extension\030\016 \003(\0132\027.pb.EmcProgr"
    "amExtension\0222\n\017position_offset\030\017 \001(\0162\031.p"
    "b.EmcPositionOffsetType\0226\n\021position_feed"
    "back\030\020 \001(\0162\033.pb.EmcPositionFeedbackType\022"
    "\031\n\021max_feed_override\030\021 \001(\001\022\031\n\021min_feed_o"
    "verride\030\022 \001(\001\022\034\n\024max_spindle_override\030\023 "
    "\001(\001\022\034\n\024min_spindle_override\030\024 \001(\001\022\035\n\025def"
    "ault_spindle_speed\030\025 \001(\001\022\037\n\027default_line"
    "ar_velocity\030\026 \001(\001\022\024\n\014min_velocity\030\027 \001(\001\022"
    "\033\n\023max_linear_velocity\030\030 \001(\001\022\033\n\023min_line"
    "ar_velocity\030\031 \001(\001\022 \n\030default_angular_vel"
    "ocity\030\032 \001(\001\022\034\n\024max_angular_velocity\030\033 \001("
    "\001\022\034\n\024min_angular_velocity\030\034 \001(\001\022\022\n\nincre"
    "ments\030\035 \001(\t\022\r\n\005grids\030\036 \001(\t\022\r\n\005lathe\030\037 \001("
    "\010\022\020\n\010geometry\030  \001(\t\022\023\n\013arcdivision\030! \001(\r"
    "\022\027\n\017no_force_homing\030\" \001(\010\022\023\n\013remote_path"
    "\030# \001(\t\022(\n\ntime_units\030$ \001(\0162\024.pb.EmcTimeU"
    "nitsType\022\014\n\004name\030% \001(\t\022.\n\014user_command\030&"
    " \003(\0132\030.pb.EmcStatusUserCommand:\006\222\?\003H\326\010\"\306"
    "\n\n\017EmcStatusMotion\022\024\n\014active_queue\030\001 \001(\005"
    "\022%\n\017actual_position\030\002 \001(\0132\014.pb.Position\022"
    "\035\n\025adaptive_feed_enabled\030\003 \001(\010\022\"\n\003ain\030\004 "
    "\003(\0132\025.pb.EmcStatusAnalogIO\022#\n\004aout\030\005 \003(\013"
    "2\025.pb.EmcStatusAnalogIO\022%\n\004axis\030\006 \003(\0132\027."
    "pb.EmcStatusMotionAxis\022\024\n\014block_delete\030\007"
    " \001(\010\022\024\n\014current_line\030\010 \001(\005\022\023\n\013current_ve"
    "l\030\t \001(\001\022\022\n\ndelay_left\030\n \001(\001\022#\n\003din\030\013 \003(\013"
    "2\026.pb.EmcStatusDigitalIO\022\026\n\016distance_to_"
    "go\030\014 \001(\001\022$\n\004dout\030\r \003(\0132\026.pb.EmcStatusDig"
    "italIO\022\031\n\003dtg\030\016 \001(\0132\014.pb.Position\022\017\n\007ena"
    "bled\030\017 \001(\010\022\031\n\021feed_hold_enabled\030\020 \001(\010\022\035\n"
    "\025feed_override_enabled\030\021 \001(\010\022\020\n\010feedrate"
    "\030\022 \001(\001\022\"\n\tg5x_index\030\023 \001(\0162\017.pb.OriginInd"
    "ex\022 \n\ng5x_offset\030\024 \001(\0132\014.pb.Position\022 \n\n"
    "g92_offset\030\025 \001(\0132\014.pb.Position\022\n\n\002id\030\027 \001"
    "(\005\022\r\n\005inpos\030\030 \001(\010\022+\n\025joint_actual_positi"
    "on\030\031 \001(\0132\014.pb.Position\022$\n\016joint_position"
    "\030\032 \001(\0132\014.pb.Position\022!\n\005limit\030\033 \003(\0132\022.pb"
    ".EmcStatusLimit\022\023\n\013motion_line\030\034 \001(\005\022#\n\013"
    "motion_type\030\035 \001(\0162\016.pb.MotionType\022.\n\013mot"
    "ion_mode\030\036 \001(\0162\031.pb.EmcTrajectoryModeTyp"
    "e\022\016\n\006paused\030\037 \001(\010\022\036\n\010position\030  \001(\0132\014.pb"
    ".Position\022\025\n\rprobe_tripped\030! \001(\010\022\021\n\tprob"
    "e_val\030\" \001(\005\022%\n\017probed_position\030# \001(\0132\014.p"
    "b.Position\022\017\n\007probing\030$ \001(\010\022\r\n\005queue\030% \001"
    "(\005\022\022\n\nqueue_full\030& \001(\010\022\023\n\013rotation_xy\030\' "
    "\001(\001\022\025\n\rspindle_brake\030( \001(\010\022\031\n\021spindle_di"
    "rection\030) \001(\005\022\027\n\017spindle_enabled\030* \001(\010\022\032"
    "\n\022spindle_increasing\030+ \001(\005\022 \n\030spindle_ov"
    "erride_enabled\030, \001(\010\022\025\n\rspindle_speed\030- "
    "\001(\001\022\023\n\013spindlerate\030. \001(\001\022\035\n\005state\030/ \001(\0162"
    "\016.pb.RCS_STATUS\022\024\n\014max_velocity\0300 \001(\001\022\030\n"
    "\020max_acceleration\0301 \001(\001:\006\222\?\003H\327\010\"\334\001\n\013EmcS"
    "tatusIo\022\r\n\005estop\030\001 \001(\010\022\r\n\005flood\030\002 \001(\010\022\014\n"
    "\004lube\030\003 \001(\010\022\022\n\nlube_level\030\004 \001(\010\022\014\n\004mist\030"
    "\005 \001(\010\022\026\n\016pocket_prepped\030\006 \001(\010\022\027\n\017tool_in"
    "_spindle\030\007 \001(\010\022!\n\013tool_offset\030\010 \001(\0132\014.pb"
    ".Position\022#\n\ntool_table\030\t \003(\0132\017.pb.EmcTo"
    "olData:\006\222\?\003H\330\010\"\254\002\n\rEmcStatusTask\022\032\n\022echo"
    "_serial_number\030\001 \001(\005\022,\n\nexec_state\030\002 \001(\016"
    "2\030.pb.EmcTaskExecStateType\022\014\n\004file\030\003 \001(\t"
    "\022\025\n\rinput_timeout\030\004 \001(\010\022\025\n\roptional_stop"
    "\030\005 \001(\010\022\021\n\tread_line\030\006 \001(\005\022&\n\ttask_mode\030\007"
    " \001(\0162\023.pb.EmcTaskModeType\022\023\n\013task_paused"
    "\030\010 \001(\005\022(\n\ntask_state\030\t \001(\0162\024.pb.EmcTaskS"
    "tateType\022\023\n\013total_lines\030\n \001(\005:\006\222\?\003H\331\010\"\200\002"
    "\n\017EmcStatusInterp\022\017\n\007command\030\001 \001(\t\022\"\n\006gc"
    "odes\030\002 \003(\0132\022.pb.EmcStatusGCode\022,\n\014interp"
    "_state\030\003 \001(\0162\026.pb.EmcInterpStateType\0226\n\023"
    "interpreter_errcode\030\004 \001(\0162\031.pb.EmcInterp"
    "ExitCodeType\022\"\n\006mcodes\030\005 \003(\0132\022.pb.EmcSta"
    "tusMCode\022&\n\010settings\030\006 \003(\0132\024.pb.EmcStatu"
    "sSetting:\006\222\?\003H\332\010\"\207\003\n\024EmcCommandParameter"
    "s\022\r\n\005index\030\001 \001(\r\022\023\n\013debug_level\030\002 \001(\r\022\023\n"
    "\013line_number\030\003 \001(\005\022\r\n\005scale\030\004 \001(\001\022\020\n\010vel"
    "ocity\030\005 \001(\001\022\020\n\010distance\030\006 \001(\001\022\r\n\005value\030\007"
    " \001(\001\022\016\n\006enable\030\010 \001(\010\022\017\n\007command\030\t \001(\t\022\014\n"
    "\004path\030\n \001(\t\022&\n\ttask_mode\030d \001(\0162\023.pb.EmcT"
    "askModeType\022(\n\ntask_state\030e \001(\0162\024.pb.Emc"
    "TaskStateType\022,\n\ttraj_mode\030f \001(\0162\031.pb.Em"
    "cTrajectoryModeType\022\031\n\004pose\030g \001(\0132\013.pb.E"
    "mcPose\022\"\n\ttool_data\030h \001(\0132\017.pb.EmcToolDa"
    "ta:\006\222\?\003H\333\010\">\n\024EmcStatusUserCommand\022\r\n\005in"
    "dex\030\001 \002(\005\022\017\n\007command\030\002 \001(\t:\006\222\?\003H\334\010*\347\002\n\024E"
    "mcTaskExecStateType\022\027\n\023EMC_TASK_EXEC_ERR"
    "OR\020\001\022\026\n\022EMC_TASK_EXEC_DONE\020\002\022$\n EMC_TASK"
    "_EXEC_WAITING_FOR_MOTION\020\003\022*\n&EMC_TASK_E"
    "XEC_WAITING_FOR_MOTION_QUEUE\020\004\022 \n\034EMC_TA"
    "SK_EXEC_WAITING_FOR_IO\020\005\022+\n\'EMC_TASK_EXE"
    "C_WAITING_FOR_MOTION_AND_IO\020\007\022#\n\037EMC_TAS"
    "K_EXEC_WAITING_FOR_DELAY\020\010\022(\n$EMC_TASK_E"
    "XEC_WAITING_FOR_SYSTEM_CMD\020\t\022.\n*EMC_TASK"
    "_EXEC_WAITING_FOR_SPINDLE_ORIENTED\020\n*\204\001\n"
    "\022EmcInterpStateType\022\030\n\024EMC_TASK_INTERP_I"
    "DLE\020\001\022\033\n\027EMC_TASK_INTERP_READING\020\002\022\032\n\026EM"
    "C_TASK_INTERP_PAUSED\020\003\022\033\n\027EMC_TASK_INTER"
    "P_WAITING\020\004*\310\001\n\025EmcInterpExitCodeType\022\026\n"
    "\022EMC_INTERP_EXIT_OK\020\000\022\030\n\024EMC_INTERP_EXIT"
    "_EXIT\020\001\022\"\n\036EMC_INTERP_EXIT_EXECUTE_FINIS"
    "H\020\002\022\033\n\027EMC_INTERP_EXIT_ENDFILE\020\003\022!\n\035EMC_"
    "INTERP_EXIT_FILE_NOT_OPEN\020\004\022\031\n\025EMC_INTER"
    "P_EXIT_ERROR\020\005*{\n\021EmcKinematicsType\022\027\n\023K"
    "INEMATICS_IDENTITY\020\001\022\033\n\027KINEMATICS_FORWA"
    "RD_ONLY\020\002\022\033\n\027KINEMATICS_INVERSE_ONLY\020\003\022\023"
    "\n\017KINEMATICS_BOTH\020\004*b\n\025EmcTrajectoryMode"
    "Type\022\026\n\022EMC_TRAJ_MODE_FREE\020\001\022\027\n\023EMC_TRAJ"
    "_MODE_COORD\020\002\022\030\n\024EMC_TRAJ_MODE_TELEOP\020\003*"
    "S\n\021EmcCanonUnitsType\022\026\n\022CANON_UNITS_INCH"
    "ES\020\001\022\022\n\016CANON_UNITS_MM\020\002\022\022\n\016CANON_UNITS_"
    "CM\020\003*@\n\020EmcTimeUnitsType\022\025\n\021TIME_UNITS_M"
    "INUTE\020\001\022\025\n\021TIME_UNITS_SECOND\020\002*Z\n\017EmcTas"
    "kModeType\022\030\n\024EMC_TASK_MODE_MANUAL\020\001\022\026\n\022E"
    "MC_TASK_MODE_AUTO\020\002\022\025\n\021EMC_TASK_MODE_MDI"
    "\020\003*{\n\020EmcTaskStateType\022\030\n\024EMC_TASK_STATE"
    "_ESTOP\020\001\022\036\n\032EMC_TASK_STATE_ESTOP_RESET\020\002"
    "\022\026\n\022EMC_TASK_STATE_OFF\020\003\022\025\n\021EMC_TASK_STA"
    "TE_ON\020\004*8\n\013EmcAxisType\022\023\n\017EMC_AXIS_LINEA"
    "R\020\001\022\024\n\020EMC_AXIS_ANGULAR\020\002*V\n\025EmcPosition"
    "OffsetType\022\036\n\032EMC_CONFIG_RELATIVE_OFFSET"
    "\020\001\022\035\n\031EMC_CONFIG_MACHINE_OFFSET\020\002*\\\n\027Emc"
    "PositionFeedbackType\022\036\n\032EMC_CONFIG_ACTUA"
    "L_FEEDBACK\020\001\022!\n\035EMC_CONFIG_COMMANDED_FEE"
    "DBACK\020\002", 6687);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "status.proto", &protobuf_RegisterTypes);
  EmcToolData::default_instance_ = new EmcToolData();
  EmcStatusMotionAxis::default_instance_ = new EmcStatusMotionAxis();
  EmcStatusConfigAxis::default_instance_ = new EmcStatusConfigAxis();
  EmcProgramExtension::default_instance_ = new EmcProgramExtension();
  EmcStatusAnalogIO::default_instance_ = new EmcStatusAnalogIO();
  EmcStatusDigitalIO::default_instance_ = new EmcStatusDigitalIO();
  EmcStatusLimit::default_instance_ = new EmcStatusLimit();
  EmcStatusGCode::default_instance_ = new EmcStatusGCode();
  EmcStatusMCode::default_instance_ = new EmcStatusMCode();
  EmcStatusSetting::default_instance_ = new EmcStatusSetting();
  EmcStatusConfig::default_instance_ = new EmcStatusConfig();
  EmcStatusMotion::default_instance_ = new EmcStatusMotion();
  EmcStatusIo::default_instance_ = new EmcStatusIo();
  EmcStatusTask::default_instance_ = new EmcStatusTask();
  EmcStatusInterp::default_instance_ = new EmcStatusInterp();
  EmcCommandParameters::default_instance_ = new EmcCommandParameters();
  EmcStatusUserCommand::default_instance_ = new EmcStatusUserCommand();
  EmcToolData::default_instance_->InitAsDefaultInstance();
  EmcStatusMotionAxis::default_instance_->InitAsDefaultInstance();
  EmcStatusConfigAxis::default_instance_->InitAsDefaultInstance();
  EmcProgramExtension::default_instance_->InitAsDefaultInstance();
  EmcStatusAnalogIO::default_instance_->InitAsDefaultInstance();
  EmcStatusDigitalIO::default_instance_->InitAsDefaultInstance();
  EmcStatusLimit::default_instance_->InitAsDefaultInstance();
  EmcStatusGCode::default_instance_->InitAsDefaultInstance();
  EmcStatusMCode::default_instance_->InitAsDefaultInstance();
  EmcStatusSetting::default_instance_->InitAsDefaultInstance();
  EmcStatusConfig::default_instance_->InitAsDefaultInstance();
  EmcStatusMotion::default_instance_->InitAsDefaultInstance();
  EmcStatusIo::default_instance_->InitAsDefaultInstance();
  EmcStatusTask::default_instance_->InitAsDefaultInstance();
  EmcStatusInterp::default_instance_->InitAsDefaultInstance();
  EmcCommandParameters::default_instance_->InitAsDefaultInstance();
  EmcStatusUserCommand::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_status_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_status_2eproto {
  StaticDescriptorInitializer_status_2eproto() {
    protobuf_AddDesc_status_2eproto();
  }
} static_descriptor_initializer_status_2eproto_;
const ::google::protobuf::EnumDescriptor* EmcTaskExecStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcTaskExecStateType_descriptor_;
}
bool EmcTaskExecStateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcInterpStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcInterpStateType_descriptor_;
}
bool EmcInterpStateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcInterpExitCodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcInterpExitCodeType_descriptor_;
}
bool EmcInterpExitCodeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcKinematicsType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcKinematicsType_descriptor_;
}
bool EmcKinematicsType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcTrajectoryModeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcTrajectoryModeType_descriptor_;
}
bool EmcTrajectoryModeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcCanonUnitsType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcCanonUnitsType_descriptor_;
}
bool EmcCanonUnitsType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcTimeUnitsType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcTimeUnitsType_descriptor_;
}
bool EmcTimeUnitsType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcTaskModeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcTaskModeType_descriptor_;
}
bool EmcTaskModeType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcTaskStateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcTaskStateType_descriptor_;
}
bool EmcTaskStateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcAxisType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcAxisType_descriptor_;
}
bool EmcAxisType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcPositionOffsetType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcPositionOffsetType_descriptor_;
}
bool EmcPositionOffsetType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EmcPositionFeedbackType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcPositionFeedbackType_descriptor_;
}
bool EmcPositionFeedbackType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int EmcToolData::kIndexFieldNumber;
const int EmcToolData::kIdFieldNumber;
const int EmcToolData::kXOffsetFieldNumber;
const int EmcToolData::kYOffsetFieldNumber;
const int EmcToolData::kZOffsetFieldNumber;
const int EmcToolData::kAOffsetFieldNumber;
const int EmcToolData::kBOffsetFieldNumber;
const int EmcToolData::kCOffsetFieldNumber;
const int EmcToolData::kUOffsetFieldNumber;
const int EmcToolData::kVOffsetFieldNumber;
const int EmcToolData::kWOffsetFieldNumber;
const int EmcToolData::kDiameterFieldNumber;
const int EmcToolData::kFrontangleFieldNumber;
const int EmcToolData::kBackangleFieldNumber;
const int EmcToolData::kOrientationFieldNumber;
#endif  // !_MSC_VER

EmcToolData::EmcToolData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcToolData)
}

void EmcToolData::InitAsDefaultInstance() {
}

EmcToolData::EmcToolData(const EmcToolData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcToolData)
}

void EmcToolData::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  id_ = 0;
  xoffset_ = 0;
  yoffset_ = 0;
  zoffset_ = 0;
  aoffset_ = 0;
  boffset_ = 0;
  coffset_ = 0;
  uoffset_ = 0;
  voffset_ = 0;
  woffset_ = 0;
  diameter_ = 0;
  frontangle_ = 0;
  backangle_ = 0;
  orientation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcToolData::~EmcToolData() {
  // @@protoc_insertion_point(destructor:pb.EmcToolData)
  SharedDtor();
}

void EmcToolData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcToolData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcToolData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcToolData_descriptor_;
}

const EmcToolData& EmcToolData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcToolData* EmcToolData::default_instance_ = NULL;

EmcToolData* EmcToolData::New() const {
  return new EmcToolData;
}

void EmcToolData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcToolData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(index_, coffset_);
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(uoffset_, orientation_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcToolData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcToolData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional int32 id = 2;
      case 2: {
        if (tag == 16) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_xOffset;
        break;
      }

      // optional double xOffset = 3;
      case 3: {
        if (tag == 25) {
         parse_xOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &xoffset_)));
          set_has_xoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_yOffset;
        break;
      }

      // optional double yOffset = 4;
      case 4: {
        if (tag == 33) {
         parse_yOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &yoffset_)));
          set_has_yoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_zOffset;
        break;
      }

      // optional double zOffset = 5;
      case 5: {
        if (tag == 41) {
         parse_zOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &zoffset_)));
          set_has_zoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_aOffset;
        break;
      }

      // optional double aOffset = 6;
      case 6: {
        if (tag == 49) {
         parse_aOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &aoffset_)));
          set_has_aoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_bOffset;
        break;
      }

      // optional double bOffset = 7;
      case 7: {
        if (tag == 57) {
         parse_bOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &boffset_)));
          set_has_boffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_cOffset;
        break;
      }

      // optional double cOffset = 8;
      case 8: {
        if (tag == 65) {
         parse_cOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &coffset_)));
          set_has_coffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_uOffset;
        break;
      }

      // optional double uOffset = 9;
      case 9: {
        if (tag == 73) {
         parse_uOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &uoffset_)));
          set_has_uoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_vOffset;
        break;
      }

      // optional double vOffset = 10;
      case 10: {
        if (tag == 81) {
         parse_vOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &voffset_)));
          set_has_voffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_wOffset;
        break;
      }

      // optional double wOffset = 11;
      case 11: {
        if (tag == 89) {
         parse_wOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &woffset_)));
          set_has_woffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(97)) goto parse_diameter;
        break;
      }

      // optional double diameter = 12;
      case 12: {
        if (tag == 97) {
         parse_diameter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &diameter_)));
          set_has_diameter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(105)) goto parse_frontangle;
        break;
      }

      // optional double frontangle = 13;
      case 13: {
        if (tag == 105) {
         parse_frontangle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &frontangle_)));
          set_has_frontangle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(113)) goto parse_backangle;
        break;
      }

      // optional double backangle = 14;
      case 14: {
        if (tag == 113) {
         parse_backangle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &backangle_)));
          set_has_backangle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_orientation;
        break;
      }

      // optional int32 orientation = 15;
      case 15: {
        if (tag == 120) {
         parse_orientation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &orientation_)));
          set_has_orientation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcToolData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcToolData)
  return false;
#undef DO_
}

void EmcToolData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcToolData)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // optional double xOffset = 3;
  if (has_xoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->xoffset(), output);
  }

  // optional double yOffset = 4;
  if (has_yoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->yoffset(), output);
  }

  // optional double zOffset = 5;
  if (has_zoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->zoffset(), output);
  }

  // optional double aOffset = 6;
  if (has_aoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->aoffset(), output);
  }

  // optional double bOffset = 7;
  if (has_boffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->boffset(), output);
  }

  // optional double cOffset = 8;
  if (has_coffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->coffset(), output);
  }

  // optional double uOffset = 9;
  if (has_uoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->uoffset(), output);
  }

  // optional double vOffset = 10;
  if (has_voffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->voffset(), output);
  }

  // optional double wOffset = 11;
  if (has_woffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->woffset(), output);
  }

  // optional double diameter = 12;
  if (has_diameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->diameter(), output);
  }

  // optional double frontangle = 13;
  if (has_frontangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->frontangle(), output);
  }

  // optional double backangle = 14;
  if (has_backangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->backangle(), output);
  }

  // optional int32 orientation = 15;
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->orientation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcToolData)
}

::google::protobuf::uint8* EmcToolData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcToolData)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional int32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->id(), target);
  }

  // optional double xOffset = 3;
  if (has_xoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->xoffset(), target);
  }

  // optional double yOffset = 4;
  if (has_yoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->yoffset(), target);
  }

  // optional double zOffset = 5;
  if (has_zoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->zoffset(), target);
  }

  // optional double aOffset = 6;
  if (has_aoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->aoffset(), target);
  }

  // optional double bOffset = 7;
  if (has_boffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->boffset(), target);
  }

  // optional double cOffset = 8;
  if (has_coffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->coffset(), target);
  }

  // optional double uOffset = 9;
  if (has_uoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->uoffset(), target);
  }

  // optional double vOffset = 10;
  if (has_voffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->voffset(), target);
  }

  // optional double wOffset = 11;
  if (has_woffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->woffset(), target);
  }

  // optional double diameter = 12;
  if (has_diameter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->diameter(), target);
  }

  // optional double frontangle = 13;
  if (has_frontangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->frontangle(), target);
  }

  // optional double backangle = 14;
  if (has_backangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->backangle(), target);
  }

  // optional int32 orientation = 15;
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->orientation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcToolData)
  return target;
}

int EmcToolData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional double xOffset = 3;
    if (has_xoffset()) {
      total_size += 1 + 8;
    }

    // optional double yOffset = 4;
    if (has_yoffset()) {
      total_size += 1 + 8;
    }

    // optional double zOffset = 5;
    if (has_zoffset()) {
      total_size += 1 + 8;
    }

    // optional double aOffset = 6;
    if (has_aoffset()) {
      total_size += 1 + 8;
    }

    // optional double bOffset = 7;
    if (has_boffset()) {
      total_size += 1 + 8;
    }

    // optional double cOffset = 8;
    if (has_coffset()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double uOffset = 9;
    if (has_uoffset()) {
      total_size += 1 + 8;
    }

    // optional double vOffset = 10;
    if (has_voffset()) {
      total_size += 1 + 8;
    }

    // optional double wOffset = 11;
    if (has_woffset()) {
      total_size += 1 + 8;
    }

    // optional double diameter = 12;
    if (has_diameter()) {
      total_size += 1 + 8;
    }

    // optional double frontangle = 13;
    if (has_frontangle()) {
      total_size += 1 + 8;
    }

    // optional double backangle = 14;
    if (has_backangle()) {
      total_size += 1 + 8;
    }

    // optional int32 orientation = 15;
    if (has_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->orientation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcToolData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcToolData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcToolData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcToolData::MergeFrom(const EmcToolData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_xoffset()) {
      set_xoffset(from.xoffset());
    }
    if (from.has_yoffset()) {
      set_yoffset(from.yoffset());
    }
    if (from.has_zoffset()) {
      set_zoffset(from.zoffset());
    }
    if (from.has_aoffset()) {
      set_aoffset(from.aoffset());
    }
    if (from.has_boffset()) {
      set_boffset(from.boffset());
    }
    if (from.has_coffset()) {
      set_coffset(from.coffset());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_uoffset()) {
      set_uoffset(from.uoffset());
    }
    if (from.has_voffset()) {
      set_voffset(from.voffset());
    }
    if (from.has_woffset()) {
      set_woffset(from.woffset());
    }
    if (from.has_diameter()) {
      set_diameter(from.diameter());
    }
    if (from.has_frontangle()) {
      set_frontangle(from.frontangle());
    }
    if (from.has_backangle()) {
      set_backangle(from.backangle());
    }
    if (from.has_orientation()) {
      set_orientation(from.orientation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcToolData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcToolData::CopyFrom(const EmcToolData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcToolData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcToolData::Swap(EmcToolData* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(id_, other->id_);
    std::swap(xoffset_, other->xoffset_);
    std::swap(yoffset_, other->yoffset_);
    std::swap(zoffset_, other->zoffset_);
    std::swap(aoffset_, other->aoffset_);
    std::swap(boffset_, other->boffset_);
    std::swap(coffset_, other->coffset_);
    std::swap(uoffset_, other->uoffset_);
    std::swap(voffset_, other->voffset_);
    std::swap(woffset_, other->woffset_);
    std::swap(diameter_, other->diameter_);
    std::swap(frontangle_, other->frontangle_);
    std::swap(backangle_, other->backangle_);
    std::swap(orientation_, other->orientation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcToolData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcToolData_descriptor_;
  metadata.reflection = EmcToolData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusMotionAxis::kIndexFieldNumber;
const int EmcStatusMotionAxis::kEnabledFieldNumber;
const int EmcStatusMotionAxis::kFaultFieldNumber;
const int EmcStatusMotionAxis::kFerrorCurrentFieldNumber;
const int EmcStatusMotionAxis::kFerrorHighmarkFieldNumber;
const int EmcStatusMotionAxis::kHomedFieldNumber;
const int EmcStatusMotionAxis::kHomingFieldNumber;
const int EmcStatusMotionAxis::kInposFieldNumber;
const int EmcStatusMotionAxis::kInputFieldNumber;
const int EmcStatusMotionAxis::kMaxHardLimitFieldNumber;
const int EmcStatusMotionAxis::kMaxSoftLimitFieldNumber;
const int EmcStatusMotionAxis::kMinHardLimitFieldNumber;
const int EmcStatusMotionAxis::kMinSoftLimitFieldNumber;
const int EmcStatusMotionAxis::kOutputFieldNumber;
const int EmcStatusMotionAxis::kOverrideLimitsFieldNumber;
const int EmcStatusMotionAxis::kVelocityFieldNumber;
#endif  // !_MSC_VER

EmcStatusMotionAxis::EmcStatusMotionAxis()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusMotionAxis)
}

void EmcStatusMotionAxis::InitAsDefaultInstance() {
}

EmcStatusMotionAxis::EmcStatusMotionAxis(const EmcStatusMotionAxis& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusMotionAxis)
}

void EmcStatusMotionAxis::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  enabled_ = false;
  fault_ = false;
  ferror_current_ = 0;
  ferror_highmark_ = 0;
  homed_ = false;
  homing_ = false;
  inpos_ = false;
  input_ = 0;
  max_hard_limit_ = false;
  max_soft_limit_ = false;
  min_hard_limit_ = false;
  min_soft_limit_ = false;
  output_ = 0;
  override_limits_ = false;
  velocity_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusMotionAxis::~EmcStatusMotionAxis() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusMotionAxis)
  SharedDtor();
}

void EmcStatusMotionAxis::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusMotionAxis::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusMotionAxis::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusMotionAxis_descriptor_;
}

const EmcStatusMotionAxis& EmcStatusMotionAxis::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusMotionAxis* EmcStatusMotionAxis::default_instance_ = NULL;

EmcStatusMotionAxis* EmcStatusMotionAxis::New() const {
  return new EmcStatusMotionAxis;
}

void EmcStatusMotionAxis::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusMotionAxis*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(index_, ferror_highmark_);
    inpos_ = false;
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(max_hard_limit_, velocity_);
    input_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusMotionAxis::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusMotionAxis)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_enabled;
        break;
      }

      // optional bool enabled = 2;
      case 2: {
        if (tag == 16) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_fault;
        break;
      }

      // optional bool fault = 3;
      case 3: {
        if (tag == 24) {
         parse_fault:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fault_)));
          set_has_fault();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_ferror_current;
        break;
      }

      // optional double ferror_current = 4;
      case 4: {
        if (tag == 33) {
         parse_ferror_current:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ferror_current_)));
          set_has_ferror_current();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_ferror_highmark;
        break;
      }

      // optional double ferror_highmark = 5;
      case 5: {
        if (tag == 41) {
         parse_ferror_highmark:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &ferror_highmark_)));
          set_has_ferror_highmark();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_homed;
        break;
      }

      // optional bool homed = 6;
      case 6: {
        if (tag == 48) {
         parse_homed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &homed_)));
          set_has_homed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_homing;
        break;
      }

      // optional bool homing = 7;
      case 7: {
        if (tag == 56) {
         parse_homing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &homing_)));
          set_has_homing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_inpos;
        break;
      }

      // optional bool inpos = 8;
      case 8: {
        if (tag == 64) {
         parse_inpos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &inpos_)));
          set_has_inpos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_input;
        break;
      }

      // optional double input = 9;
      case 9: {
        if (tag == 73) {
         parse_input:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &input_)));
          set_has_input();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_max_hard_limit;
        break;
      }

      // optional bool max_hard_limit = 10;
      case 10: {
        if (tag == 80) {
         parse_max_hard_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &max_hard_limit_)));
          set_has_max_hard_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_max_soft_limit;
        break;
      }

      // optional bool max_soft_limit = 11;
      case 11: {
        if (tag == 88) {
         parse_max_soft_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &max_soft_limit_)));
          set_has_max_soft_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_min_hard_limit;
        break;
      }

      // optional bool min_hard_limit = 12;
      case 12: {
        if (tag == 96) {
         parse_min_hard_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &min_hard_limit_)));
          set_has_min_hard_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_min_soft_limit;
        break;
      }

      // optional bool min_soft_limit = 13;
      case 13: {
        if (tag == 104) {
         parse_min_soft_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &min_soft_limit_)));
          set_has_min_soft_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(113)) goto parse_output;
        break;
      }

      // optional double output = 14;
      case 14: {
        if (tag == 113) {
         parse_output:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &output_)));
          set_has_output();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_override_limits;
        break;
      }

      // optional bool override_limits = 15;
      case 15: {
        if (tag == 120) {
         parse_override_limits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &override_limits_)));
          set_has_override_limits();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(129)) goto parse_velocity;
        break;
      }

      // optional double velocity = 16;
      case 16: {
        if (tag == 129) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusMotionAxis)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusMotionAxis)
  return false;
#undef DO_
}

void EmcStatusMotionAxis::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusMotionAxis)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional bool enabled = 2;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->enabled(), output);
  }

  // optional bool fault = 3;
  if (has_fault()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->fault(), output);
  }

  // optional double ferror_current = 4;
  if (has_ferror_current()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->ferror_current(), output);
  }

  // optional double ferror_highmark = 5;
  if (has_ferror_highmark()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->ferror_highmark(), output);
  }

  // optional bool homed = 6;
  if (has_homed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->homed(), output);
  }

  // optional bool homing = 7;
  if (has_homing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->homing(), output);
  }

  // optional bool inpos = 8;
  if (has_inpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->inpos(), output);
  }

  // optional double input = 9;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->input(), output);
  }

  // optional bool max_hard_limit = 10;
  if (has_max_hard_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->max_hard_limit(), output);
  }

  // optional bool max_soft_limit = 11;
  if (has_max_soft_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->max_soft_limit(), output);
  }

  // optional bool min_hard_limit = 12;
  if (has_min_hard_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->min_hard_limit(), output);
  }

  // optional bool min_soft_limit = 13;
  if (has_min_soft_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->min_soft_limit(), output);
  }

  // optional double output = 14;
  if (has_output()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->output(), output);
  }

  // optional bool override_limits = 15;
  if (has_override_limits()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->override_limits(), output);
  }

  // optional double velocity = 16;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(16, this->velocity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusMotionAxis)
}

::google::protobuf::uint8* EmcStatusMotionAxis::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusMotionAxis)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional bool enabled = 2;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->enabled(), target);
  }

  // optional bool fault = 3;
  if (has_fault()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->fault(), target);
  }

  // optional double ferror_current = 4;
  if (has_ferror_current()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->ferror_current(), target);
  }

  // optional double ferror_highmark = 5;
  if (has_ferror_highmark()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->ferror_highmark(), target);
  }

  // optional bool homed = 6;
  if (has_homed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->homed(), target);
  }

  // optional bool homing = 7;
  if (has_homing()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->homing(), target);
  }

  // optional bool inpos = 8;
  if (has_inpos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->inpos(), target);
  }

  // optional double input = 9;
  if (has_input()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->input(), target);
  }

  // optional bool max_hard_limit = 10;
  if (has_max_hard_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->max_hard_limit(), target);
  }

  // optional bool max_soft_limit = 11;
  if (has_max_soft_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->max_soft_limit(), target);
  }

  // optional bool min_hard_limit = 12;
  if (has_min_hard_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->min_hard_limit(), target);
  }

  // optional bool min_soft_limit = 13;
  if (has_min_soft_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->min_soft_limit(), target);
  }

  // optional double output = 14;
  if (has_output()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->output(), target);
  }

  // optional bool override_limits = 15;
  if (has_override_limits()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->override_limits(), target);
  }

  // optional double velocity = 16;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(16, this->velocity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusMotionAxis)
  return target;
}

int EmcStatusMotionAxis::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional bool enabled = 2;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

    // optional bool fault = 3;
    if (has_fault()) {
      total_size += 1 + 1;
    }

    // optional double ferror_current = 4;
    if (has_ferror_current()) {
      total_size += 1 + 8;
    }

    // optional double ferror_highmark = 5;
    if (has_ferror_highmark()) {
      total_size += 1 + 8;
    }

    // optional bool homed = 6;
    if (has_homed()) {
      total_size += 1 + 1;
    }

    // optional bool homing = 7;
    if (has_homing()) {
      total_size += 1 + 1;
    }

    // optional bool inpos = 8;
    if (has_inpos()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double input = 9;
    if (has_input()) {
      total_size += 1 + 8;
    }

    // optional bool max_hard_limit = 10;
    if (has_max_hard_limit()) {
      total_size += 1 + 1;
    }

    // optional bool max_soft_limit = 11;
    if (has_max_soft_limit()) {
      total_size += 1 + 1;
    }

    // optional bool min_hard_limit = 12;
    if (has_min_hard_limit()) {
      total_size += 1 + 1;
    }

    // optional bool min_soft_limit = 13;
    if (has_min_soft_limit()) {
      total_size += 1 + 1;
    }

    // optional double output = 14;
    if (has_output()) {
      total_size += 1 + 8;
    }

    // optional bool override_limits = 15;
    if (has_override_limits()) {
      total_size += 1 + 1;
    }

    // optional double velocity = 16;
    if (has_velocity()) {
      total_size += 2 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusMotionAxis::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusMotionAxis* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusMotionAxis*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusMotionAxis::MergeFrom(const EmcStatusMotionAxis& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_fault()) {
      set_fault(from.fault());
    }
    if (from.has_ferror_current()) {
      set_ferror_current(from.ferror_current());
    }
    if (from.has_ferror_highmark()) {
      set_ferror_highmark(from.ferror_highmark());
    }
    if (from.has_homed()) {
      set_homed(from.homed());
    }
    if (from.has_homing()) {
      set_homing(from.homing());
    }
    if (from.has_inpos()) {
      set_inpos(from.inpos());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_input()) {
      set_input(from.input());
    }
    if (from.has_max_hard_limit()) {
      set_max_hard_limit(from.max_hard_limit());
    }
    if (from.has_max_soft_limit()) {
      set_max_soft_limit(from.max_soft_limit());
    }
    if (from.has_min_hard_limit()) {
      set_min_hard_limit(from.min_hard_limit());
    }
    if (from.has_min_soft_limit()) {
      set_min_soft_limit(from.min_soft_limit());
    }
    if (from.has_output()) {
      set_output(from.output());
    }
    if (from.has_override_limits()) {
      set_override_limits(from.override_limits());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusMotionAxis::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusMotionAxis::CopyFrom(const EmcStatusMotionAxis& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusMotionAxis::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusMotionAxis::Swap(EmcStatusMotionAxis* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(enabled_, other->enabled_);
    std::swap(fault_, other->fault_);
    std::swap(ferror_current_, other->ferror_current_);
    std::swap(ferror_highmark_, other->ferror_highmark_);
    std::swap(homed_, other->homed_);
    std::swap(homing_, other->homing_);
    std::swap(inpos_, other->inpos_);
    std::swap(input_, other->input_);
    std::swap(max_hard_limit_, other->max_hard_limit_);
    std::swap(max_soft_limit_, other->max_soft_limit_);
    std::swap(min_hard_limit_, other->min_hard_limit_);
    std::swap(min_soft_limit_, other->min_soft_limit_);
    std::swap(output_, other->output_);
    std::swap(override_limits_, other->override_limits_);
    std::swap(velocity_, other->velocity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusMotionAxis::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusMotionAxis_descriptor_;
  metadata.reflection = EmcStatusMotionAxis_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusConfigAxis::kIndexFieldNumber;
const int EmcStatusConfigAxis::kAxisTypeFieldNumber;
const int EmcStatusConfigAxis::kBacklashFieldNumber;
const int EmcStatusConfigAxis::kMaxFerrorFieldNumber;
const int EmcStatusConfigAxis::kMaxPositionLimitFieldNumber;
const int EmcStatusConfigAxis::kMinFerrorFieldNumber;
const int EmcStatusConfigAxis::kMinPositionLimitFieldNumber;
const int EmcStatusConfigAxis::kUnitsFieldNumber;
const int EmcStatusConfigAxis::kHomeSequenceFieldNumber;
const int EmcStatusConfigAxis::kMaxAccelerationFieldNumber;
const int EmcStatusConfigAxis::kMaxVelocityFieldNumber;
const int EmcStatusConfigAxis::kIncrementsFieldNumber;
#endif  // !_MSC_VER

EmcStatusConfigAxis::EmcStatusConfigAxis()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusConfigAxis)
}

void EmcStatusConfigAxis::InitAsDefaultInstance() {
}

EmcStatusConfigAxis::EmcStatusConfigAxis(const EmcStatusConfigAxis& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusConfigAxis)
}

void EmcStatusConfigAxis::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0;
  axistype_ = 1;
  backlash_ = 0;
  max_ferror_ = 0;
  max_position_limit_ = 0;
  min_ferror_ = 0;
  min_position_limit_ = 0;
  units_ = 0;
  home_sequence_ = 0;
  max_acceleration_ = 0;
  max_velocity_ = 0;
  increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusConfigAxis::~EmcStatusConfigAxis() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusConfigAxis)
  SharedDtor();
}

void EmcStatusConfigAxis::SharedDtor() {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete increments_;
  }
  if (this != default_instance_) {
  }
}

void EmcStatusConfigAxis::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusConfigAxis::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusConfigAxis_descriptor_;
}

const EmcStatusConfigAxis& EmcStatusConfigAxis::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusConfigAxis* EmcStatusConfigAxis::default_instance_ = NULL;

EmcStatusConfigAxis* EmcStatusConfigAxis::New() const {
  return new EmcStatusConfigAxis;
}

void EmcStatusConfigAxis::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusConfigAxis*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(backlash_, units_);
    index_ = 0;
    axistype_ = 1;
  }
  if (_has_bits_[8 / 32] & 3840) {
    ZR_(max_acceleration_, max_velocity_);
    home_sequence_ = 0;
    if (has_increments()) {
      if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        increments_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusConfigAxis::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusConfigAxis)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_axisType;
        break;
      }

      // optional .pb.EmcAxisType axisType = 2;
      case 2: {
        if (tag == 16) {
         parse_axisType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcAxisType_IsValid(value)) {
            set_axistype(static_cast< ::pb::EmcAxisType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_backlash;
        break;
      }

      // optional double backlash = 3;
      case 3: {
        if (tag == 25) {
         parse_backlash:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &backlash_)));
          set_has_backlash();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_max_ferror;
        break;
      }

      // optional double max_ferror = 4;
      case 4: {
        if (tag == 33) {
         parse_max_ferror:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_ferror_)));
          set_has_max_ferror();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_max_position_limit;
        break;
      }

      // optional double max_position_limit = 5;
      case 5: {
        if (tag == 41) {
         parse_max_position_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_position_limit_)));
          set_has_max_position_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_min_ferror;
        break;
      }

      // optional double min_ferror = 6;
      case 6: {
        if (tag == 49) {
         parse_min_ferror:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_ferror_)));
          set_has_min_ferror();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_min_position_limit;
        break;
      }

      // optional double min_position_limit = 7;
      case 7: {
        if (tag == 57) {
         parse_min_position_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_position_limit_)));
          set_has_min_position_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_units;
        break;
      }

      // optional double units = 8;
      case 8: {
        if (tag == 65) {
         parse_units:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &units_)));
          set_has_units();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_home_sequence;
        break;
      }

      // optional int32 home_sequence = 9;
      case 9: {
        if (tag == 72) {
         parse_home_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &home_sequence_)));
          set_has_home_sequence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_max_acceleration;
        break;
      }

      // optional double max_acceleration = 10;
      case 10: {
        if (tag == 81) {
         parse_max_acceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_acceleration_)));
          set_has_max_acceleration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_max_velocity;
        break;
      }

      // optional double max_velocity = 11;
      case 11: {
        if (tag == 89) {
         parse_max_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_velocity_)));
          set_has_max_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_increments;
        break;
      }

      // optional string increments = 12;
      case 12: {
        if (tag == 98) {
         parse_increments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_increments()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->increments().data(), this->increments().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "increments");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusConfigAxis)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusConfigAxis)
  return false;
#undef DO_
}

void EmcStatusConfigAxis::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusConfigAxis)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional .pb.EmcAxisType axisType = 2;
  if (has_axistype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->axistype(), output);
  }

  // optional double backlash = 3;
  if (has_backlash()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->backlash(), output);
  }

  // optional double max_ferror = 4;
  if (has_max_ferror()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->max_ferror(), output);
  }

  // optional double max_position_limit = 5;
  if (has_max_position_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->max_position_limit(), output);
  }

  // optional double min_ferror = 6;
  if (has_min_ferror()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->min_ferror(), output);
  }

  // optional double min_position_limit = 7;
  if (has_min_position_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->min_position_limit(), output);
  }

  // optional double units = 8;
  if (has_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->units(), output);
  }

  // optional int32 home_sequence = 9;
  if (has_home_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->home_sequence(), output);
  }

  // optional double max_acceleration = 10;
  if (has_max_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->max_acceleration(), output);
  }

  // optional double max_velocity = 11;
  if (has_max_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->max_velocity(), output);
  }

  // optional string increments = 12;
  if (has_increments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->increments().data(), this->increments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "increments");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->increments(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusConfigAxis)
}

::google::protobuf::uint8* EmcStatusConfigAxis::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusConfigAxis)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional .pb.EmcAxisType axisType = 2;
  if (has_axistype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->axistype(), target);
  }

  // optional double backlash = 3;
  if (has_backlash()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->backlash(), target);
  }

  // optional double max_ferror = 4;
  if (has_max_ferror()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->max_ferror(), target);
  }

  // optional double max_position_limit = 5;
  if (has_max_position_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->max_position_limit(), target);
  }

  // optional double min_ferror = 6;
  if (has_min_ferror()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->min_ferror(), target);
  }

  // optional double min_position_limit = 7;
  if (has_min_position_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->min_position_limit(), target);
  }

  // optional double units = 8;
  if (has_units()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->units(), target);
  }

  // optional int32 home_sequence = 9;
  if (has_home_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->home_sequence(), target);
  }

  // optional double max_acceleration = 10;
  if (has_max_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->max_acceleration(), target);
  }

  // optional double max_velocity = 11;
  if (has_max_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->max_velocity(), target);
  }

  // optional string increments = 12;
  if (has_increments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->increments().data(), this->increments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "increments");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->increments(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusConfigAxis)
  return target;
}

int EmcStatusConfigAxis::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional .pb.EmcAxisType axisType = 2;
    if (has_axistype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->axistype());
    }

    // optional double backlash = 3;
    if (has_backlash()) {
      total_size += 1 + 8;
    }

    // optional double max_ferror = 4;
    if (has_max_ferror()) {
      total_size += 1 + 8;
    }

    // optional double max_position_limit = 5;
    if (has_max_position_limit()) {
      total_size += 1 + 8;
    }

    // optional double min_ferror = 6;
    if (has_min_ferror()) {
      total_size += 1 + 8;
    }

    // optional double min_position_limit = 7;
    if (has_min_position_limit()) {
      total_size += 1 + 8;
    }

    // optional double units = 8;
    if (has_units()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 home_sequence = 9;
    if (has_home_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->home_sequence());
    }

    // optional double max_acceleration = 10;
    if (has_max_acceleration()) {
      total_size += 1 + 8;
    }

    // optional double max_velocity = 11;
    if (has_max_velocity()) {
      total_size += 1 + 8;
    }

    // optional string increments = 12;
    if (has_increments()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->increments());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusConfigAxis::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusConfigAxis* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusConfigAxis*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusConfigAxis::MergeFrom(const EmcStatusConfigAxis& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_axistype()) {
      set_axistype(from.axistype());
    }
    if (from.has_backlash()) {
      set_backlash(from.backlash());
    }
    if (from.has_max_ferror()) {
      set_max_ferror(from.max_ferror());
    }
    if (from.has_max_position_limit()) {
      set_max_position_limit(from.max_position_limit());
    }
    if (from.has_min_ferror()) {
      set_min_ferror(from.min_ferror());
    }
    if (from.has_min_position_limit()) {
      set_min_position_limit(from.min_position_limit());
    }
    if (from.has_units()) {
      set_units(from.units());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_home_sequence()) {
      set_home_sequence(from.home_sequence());
    }
    if (from.has_max_acceleration()) {
      set_max_acceleration(from.max_acceleration());
    }
    if (from.has_max_velocity()) {
      set_max_velocity(from.max_velocity());
    }
    if (from.has_increments()) {
      set_increments(from.increments());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusConfigAxis::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusConfigAxis::CopyFrom(const EmcStatusConfigAxis& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusConfigAxis::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusConfigAxis::Swap(EmcStatusConfigAxis* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(axistype_, other->axistype_);
    std::swap(backlash_, other->backlash_);
    std::swap(max_ferror_, other->max_ferror_);
    std::swap(max_position_limit_, other->max_position_limit_);
    std::swap(min_ferror_, other->min_ferror_);
    std::swap(min_position_limit_, other->min_position_limit_);
    std::swap(units_, other->units_);
    std::swap(home_sequence_, other->home_sequence_);
    std::swap(max_acceleration_, other->max_acceleration_);
    std::swap(max_velocity_, other->max_velocity_);
    std::swap(increments_, other->increments_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusConfigAxis::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusConfigAxis_descriptor_;
  metadata.reflection = EmcStatusConfigAxis_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcProgramExtension::kIndexFieldNumber;
const int EmcProgramExtension::kExtensionFieldNumber;
#endif  // !_MSC_VER

EmcProgramExtension::EmcProgramExtension()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcProgramExtension)
}

void EmcProgramExtension::InitAsDefaultInstance() {
}

EmcProgramExtension::EmcProgramExtension(const EmcProgramExtension& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcProgramExtension)
}

void EmcProgramExtension::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0;
  extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcProgramExtension::~EmcProgramExtension() {
  // @@protoc_insertion_point(destructor:pb.EmcProgramExtension)
  SharedDtor();
}

void EmcProgramExtension::SharedDtor() {
  if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extension_;
  }
  if (this != default_instance_) {
  }
}

void EmcProgramExtension::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcProgramExtension::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcProgramExtension_descriptor_;
}

const EmcProgramExtension& EmcProgramExtension::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcProgramExtension* EmcProgramExtension::default_instance_ = NULL;

EmcProgramExtension* EmcProgramExtension::New() const {
  return new EmcProgramExtension;
}

void EmcProgramExtension::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    index_ = 0;
    if (has_extension()) {
      if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extension_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcProgramExtension::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcProgramExtension)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_extension;
        break;
      }

      // optional string extension = 2;
      case 2: {
        if (tag == 18) {
         parse_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_extension()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->extension().data(), this->extension().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "extension");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcProgramExtension)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcProgramExtension)
  return false;
#undef DO_
}

void EmcProgramExtension::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcProgramExtension)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional string extension = 2;
  if (has_extension()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->extension().data(), this->extension().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "extension");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->extension(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcProgramExtension)
}

::google::protobuf::uint8* EmcProgramExtension::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcProgramExtension)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional string extension = 2;
  if (has_extension()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->extension().data(), this->extension().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "extension");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->extension(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcProgramExtension)
  return target;
}

int EmcProgramExtension::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional string extension = 2;
    if (has_extension()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->extension());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcProgramExtension::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcProgramExtension* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcProgramExtension*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcProgramExtension::MergeFrom(const EmcProgramExtension& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_extension()) {
      set_extension(from.extension());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcProgramExtension::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcProgramExtension::CopyFrom(const EmcProgramExtension& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcProgramExtension::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcProgramExtension::Swap(EmcProgramExtension* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(extension_, other->extension_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcProgramExtension::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcProgramExtension_descriptor_;
  metadata.reflection = EmcProgramExtension_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusAnalogIO::kIndexFieldNumber;
const int EmcStatusAnalogIO::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusAnalogIO::EmcStatusAnalogIO()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusAnalogIO)
}

void EmcStatusAnalogIO::InitAsDefaultInstance() {
}

EmcStatusAnalogIO::EmcStatusAnalogIO(const EmcStatusAnalogIO& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusAnalogIO)
}

void EmcStatusAnalogIO::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusAnalogIO::~EmcStatusAnalogIO() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusAnalogIO)
  SharedDtor();
}

void EmcStatusAnalogIO::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusAnalogIO::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusAnalogIO::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusAnalogIO_descriptor_;
}

const EmcStatusAnalogIO& EmcStatusAnalogIO::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusAnalogIO* EmcStatusAnalogIO::default_instance_ = NULL;

EmcStatusAnalogIO* EmcStatusAnalogIO::New() const {
  return new EmcStatusAnalogIO;
}

void EmcStatusAnalogIO::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusAnalogIO*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(value_, index_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusAnalogIO::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusAnalogIO)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_value;
        break;
      }

      // optional double value = 2;
      case 2: {
        if (tag == 17) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusAnalogIO)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusAnalogIO)
  return false;
#undef DO_
}

void EmcStatusAnalogIO::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusAnalogIO)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional double value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusAnalogIO)
}

::google::protobuf::uint8* EmcStatusAnalogIO::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusAnalogIO)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional double value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusAnalogIO)
  return target;
}

int EmcStatusAnalogIO::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional double value = 2;
    if (has_value()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusAnalogIO::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusAnalogIO* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusAnalogIO*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusAnalogIO::MergeFrom(const EmcStatusAnalogIO& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusAnalogIO::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusAnalogIO::CopyFrom(const EmcStatusAnalogIO& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusAnalogIO::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusAnalogIO::Swap(EmcStatusAnalogIO* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusAnalogIO::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusAnalogIO_descriptor_;
  metadata.reflection = EmcStatusAnalogIO_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusDigitalIO::kIndexFieldNumber;
const int EmcStatusDigitalIO::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusDigitalIO::EmcStatusDigitalIO()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusDigitalIO)
}

void EmcStatusDigitalIO::InitAsDefaultInstance() {
}

EmcStatusDigitalIO::EmcStatusDigitalIO(const EmcStatusDigitalIO& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusDigitalIO)
}

void EmcStatusDigitalIO::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusDigitalIO::~EmcStatusDigitalIO() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusDigitalIO)
  SharedDtor();
}

void EmcStatusDigitalIO::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusDigitalIO::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusDigitalIO::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusDigitalIO_descriptor_;
}

const EmcStatusDigitalIO& EmcStatusDigitalIO::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusDigitalIO* EmcStatusDigitalIO::default_instance_ = NULL;

EmcStatusDigitalIO* EmcStatusDigitalIO::New() const {
  return new EmcStatusDigitalIO;
}

void EmcStatusDigitalIO::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusDigitalIO*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(index_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusDigitalIO::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusDigitalIO)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional bool value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusDigitalIO)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusDigitalIO)
  return false;
#undef DO_
}

void EmcStatusDigitalIO::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusDigitalIO)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional bool value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusDigitalIO)
}

::google::protobuf::uint8* EmcStatusDigitalIO::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusDigitalIO)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional bool value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusDigitalIO)
  return target;
}

int EmcStatusDigitalIO::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional bool value = 2;
    if (has_value()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusDigitalIO::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusDigitalIO* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusDigitalIO*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusDigitalIO::MergeFrom(const EmcStatusDigitalIO& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusDigitalIO::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusDigitalIO::CopyFrom(const EmcStatusDigitalIO& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusDigitalIO::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusDigitalIO::Swap(EmcStatusDigitalIO* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusDigitalIO::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusDigitalIO_descriptor_;
  metadata.reflection = EmcStatusDigitalIO_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusLimit::kIndexFieldNumber;
const int EmcStatusLimit::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusLimit::EmcStatusLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusLimit)
}

void EmcStatusLimit::InitAsDefaultInstance() {
}

EmcStatusLimit::EmcStatusLimit(const EmcStatusLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusLimit)
}

void EmcStatusLimit::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusLimit::~EmcStatusLimit() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusLimit)
  SharedDtor();
}

void EmcStatusLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusLimit_descriptor_;
}

const EmcStatusLimit& EmcStatusLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusLimit* EmcStatusLimit::default_instance_ = NULL;

EmcStatusLimit* EmcStatusLimit::New() const {
  return new EmcStatusLimit;
}

void EmcStatusLimit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusLimit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(index_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusLimit)
  return false;
#undef DO_
}

void EmcStatusLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusLimit)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusLimit)
}

::google::protobuf::uint8* EmcStatusLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusLimit)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional int32 value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusLimit)
  return target;
}

int EmcStatusLimit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusLimit::MergeFrom(const EmcStatusLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusLimit::CopyFrom(const EmcStatusLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusLimit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusLimit::Swap(EmcStatusLimit* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusLimit_descriptor_;
  metadata.reflection = EmcStatusLimit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusGCode::kIndexFieldNumber;
const int EmcStatusGCode::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusGCode::EmcStatusGCode()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusGCode)
}

void EmcStatusGCode::InitAsDefaultInstance() {
}

EmcStatusGCode::EmcStatusGCode(const EmcStatusGCode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusGCode)
}

void EmcStatusGCode::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusGCode::~EmcStatusGCode() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusGCode)
  SharedDtor();
}

void EmcStatusGCode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusGCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusGCode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusGCode_descriptor_;
}

const EmcStatusGCode& EmcStatusGCode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusGCode* EmcStatusGCode::default_instance_ = NULL;

EmcStatusGCode* EmcStatusGCode::New() const {
  return new EmcStatusGCode;
}

void EmcStatusGCode::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusGCode*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(index_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusGCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusGCode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusGCode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusGCode)
  return false;
#undef DO_
}

void EmcStatusGCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusGCode)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusGCode)
}

::google::protobuf::uint8* EmcStatusGCode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusGCode)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional int32 value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusGCode)
  return target;
}

int EmcStatusGCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusGCode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusGCode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusGCode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusGCode::MergeFrom(const EmcStatusGCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusGCode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusGCode::CopyFrom(const EmcStatusGCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusGCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusGCode::Swap(EmcStatusGCode* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusGCode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusGCode_descriptor_;
  metadata.reflection = EmcStatusGCode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusMCode::kIndexFieldNumber;
const int EmcStatusMCode::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusMCode::EmcStatusMCode()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusMCode)
}

void EmcStatusMCode::InitAsDefaultInstance() {
}

EmcStatusMCode::EmcStatusMCode(const EmcStatusMCode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusMCode)
}

void EmcStatusMCode::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusMCode::~EmcStatusMCode() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusMCode)
  SharedDtor();
}

void EmcStatusMCode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusMCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusMCode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusMCode_descriptor_;
}

const EmcStatusMCode& EmcStatusMCode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusMCode* EmcStatusMCode::default_instance_ = NULL;

EmcStatusMCode* EmcStatusMCode::New() const {
  return new EmcStatusMCode;
}

void EmcStatusMCode::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusMCode*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(index_, value_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusMCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusMCode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusMCode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusMCode)
  return false;
#undef DO_
}

void EmcStatusMCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusMCode)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusMCode)
}

::google::protobuf::uint8* EmcStatusMCode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusMCode)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional int32 value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusMCode)
  return target;
}

int EmcStatusMCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusMCode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusMCode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusMCode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusMCode::MergeFrom(const EmcStatusMCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusMCode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusMCode::CopyFrom(const EmcStatusMCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusMCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusMCode::Swap(EmcStatusMCode* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusMCode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusMCode_descriptor_;
  metadata.reflection = EmcStatusMCode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusSetting::kIndexFieldNumber;
const int EmcStatusSetting::kValueFieldNumber;
#endif  // !_MSC_VER

EmcStatusSetting::EmcStatusSetting()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusSetting)
}

void EmcStatusSetting::InitAsDefaultInstance() {
}

EmcStatusSetting::EmcStatusSetting(const EmcStatusSetting& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusSetting)
}

void EmcStatusSetting::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusSetting::~EmcStatusSetting() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusSetting)
  SharedDtor();
}

void EmcStatusSetting::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmcStatusSetting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusSetting::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusSetting_descriptor_;
}

const EmcStatusSetting& EmcStatusSetting::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusSetting* EmcStatusSetting::default_instance_ = NULL;

EmcStatusSetting* EmcStatusSetting::New() const {
  return new EmcStatusSetting;
}

void EmcStatusSetting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusSetting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(value_, index_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusSetting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusSetting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_value;
        break;
      }

      // optional double value = 2;
      case 2: {
        if (tag == 17) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusSetting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusSetting)
  return false;
#undef DO_
}

void EmcStatusSetting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusSetting)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional double value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusSetting)
}

::google::protobuf::uint8* EmcStatusSetting::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusSetting)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional double value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusSetting)
  return target;
}

int EmcStatusSetting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional double value = 2;
    if (has_value()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusSetting::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusSetting* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusSetting*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusSetting::MergeFrom(const EmcStatusSetting& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusSetting::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusSetting::CopyFrom(const EmcStatusSetting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusSetting::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusSetting::Swap(EmcStatusSetting* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusSetting::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusSetting_descriptor_;
  metadata.reflection = EmcStatusSetting_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusConfig::kDefaultAccelerationFieldNumber;
const int EmcStatusConfig::kAngularUnitsFieldNumber;
const int EmcStatusConfig::kAxesFieldNumber;
const int EmcStatusConfig::kAxisFieldNumber;
const int EmcStatusConfig::kAxisMaskFieldNumber;
const int EmcStatusConfig::kCycleTimeFieldNumber;
const int EmcStatusConfig::kDebugFieldNumber;
const int EmcStatusConfig::kKinematicsTypeFieldNumber;
const int EmcStatusConfig::kLinearUnitsFieldNumber;
const int EmcStatusConfig::kMaxAccelerationFieldNumber;
const int EmcStatusConfig::kMaxVelocityFieldNumber;
const int EmcStatusConfig::kProgramUnitsFieldNumber;
const int EmcStatusConfig::kDefaultVelocityFieldNumber;
const int EmcStatusConfig::kProgramExtensionFieldNumber;
const int EmcStatusConfig::kPositionOffsetFieldNumber;
const int EmcStatusConfig::kPositionFeedbackFieldNumber;
const int EmcStatusConfig::kMaxFeedOverrideFieldNumber;
const int EmcStatusConfig::kMinFeedOverrideFieldNumber;
const int EmcStatusConfig::kMaxSpindleOverrideFieldNumber;
const int EmcStatusConfig::kMinSpindleOverrideFieldNumber;
const int EmcStatusConfig::kDefaultSpindleSpeedFieldNumber;
const int EmcStatusConfig::kDefaultLinearVelocityFieldNumber;
const int EmcStatusConfig::kMinVelocityFieldNumber;
const int EmcStatusConfig::kMaxLinearVelocityFieldNumber;
const int EmcStatusConfig::kMinLinearVelocityFieldNumber;
const int EmcStatusConfig::kDefaultAngularVelocityFieldNumber;
const int EmcStatusConfig::kMaxAngularVelocityFieldNumber;
const int EmcStatusConfig::kMinAngularVelocityFieldNumber;
const int EmcStatusConfig::kIncrementsFieldNumber;
const int EmcStatusConfig::kGridsFieldNumber;
const int EmcStatusConfig::kLatheFieldNumber;
const int EmcStatusConfig::kGeometryFieldNumber;
const int EmcStatusConfig::kArcdivisionFieldNumber;
const int EmcStatusConfig::kNoForceHomingFieldNumber;
const int EmcStatusConfig::kRemotePathFieldNumber;
const int EmcStatusConfig::kTimeUnitsFieldNumber;
const int EmcStatusConfig::kNameFieldNumber;
const int EmcStatusConfig::kUserCommandFieldNumber;
#endif  // !_MSC_VER

EmcStatusConfig::EmcStatusConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusConfig)
}

void EmcStatusConfig::InitAsDefaultInstance() {
}

EmcStatusConfig::EmcStatusConfig(const EmcStatusConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusConfig)
}

void EmcStatusConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  default_acceleration_ = 0;
  angular_units_ = 0;
  axes_ = 0;
  axis_mask_ = 0;
  cycle_time_ = 0;
  debug_ = 0;
  kinematics_type_ = 1;
  linear_units_ = 0;
  max_acceleration_ = 0;
  max_velocity_ = 0;
  program_units_ = 1;
  default_velocity_ = 0;
  position_offset_ = 1;
  position_feedback_ = 1;
  max_feed_override_ = 0;
  min_feed_override_ = 0;
  max_spindle_override_ = 0;
  min_spindle_override_ = 0;
  default_spindle_speed_ = 0;
  default_linear_velocity_ = 0;
  min_velocity_ = 0;
  max_linear_velocity_ = 0;
  min_linear_velocity_ = 0;
  default_angular_velocity_ = 0;
  max_angular_velocity_ = 0;
  min_angular_velocity_ = 0;
  increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  grids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  lathe_ = false;
  geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  arcdivision_ = 0u;
  no_force_homing_ = false;
  remote_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_units_ = 1;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusConfig::~EmcStatusConfig() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusConfig)
  SharedDtor();
}

void EmcStatusConfig::SharedDtor() {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete increments_;
  }
  if (grids_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grids_;
  }
  if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete geometry_;
  }
  if (remote_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_path_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void EmcStatusConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusConfig_descriptor_;
}

const EmcStatusConfig& EmcStatusConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusConfig* EmcStatusConfig::default_instance_ = NULL;

EmcStatusConfig* EmcStatusConfig::New() const {
  return new EmcStatusConfig;
}

void EmcStatusConfig::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusConfig*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 247) {
    ZR_(default_acceleration_, angular_units_);
    ZR_(axes_, debug_);
    kinematics_type_ = 1;
  }
  if (_has_bits_[8 / 32] & 57088) {
    ZR_(linear_units_, default_velocity_);
    program_units_ = 1;
    position_offset_ = 1;
    position_feedback_ = 1;
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(max_feed_override_, max_linear_velocity_);
  }
  if (_has_bits_[24 / 32] & 4278190080) {
    ZR_(min_linear_velocity_, max_angular_velocity_);
    min_angular_velocity_ = 0;
    if (has_increments()) {
      if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        increments_->clear();
      }
    }
    if (has_grids()) {
      if (grids_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        grids_->clear();
      }
    }
    lathe_ = false;
    if (has_geometry()) {
      if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        geometry_->clear();
      }
    }
  }
  if (_has_bits_[32 / 32] & 31) {
    arcdivision_ = 0u;
    no_force_homing_ = false;
    if (has_remote_path()) {
      if (remote_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        remote_path_->clear();
      }
    }
    time_units_ = 1;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  axis_.Clear();
  program_extension_.Clear();
  user_command_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double default_acceleration = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &default_acceleration_)));
          set_has_default_acceleration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_angular_units;
        break;
      }

      // optional double angular_units = 2;
      case 2: {
        if (tag == 17) {
         parse_angular_units:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &angular_units_)));
          set_has_angular_units();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_axes;
        break;
      }

      // optional int32 axes = 3;
      case 3: {
        if (tag == 24) {
         parse_axes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &axes_)));
          set_has_axes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_axis;
        break;
      }

      // repeated .pb.EmcStatusConfigAxis axis = 4;
      case 4: {
        if (tag == 34) {
         parse_axis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_axis()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_axis;
        if (input->ExpectTag(40)) goto parse_axis_mask;
        break;
      }

      // optional int32 axis_mask = 5;
      case 5: {
        if (tag == 40) {
         parse_axis_mask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &axis_mask_)));
          set_has_axis_mask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_cycle_time;
        break;
      }

      // optional double cycle_time = 6;
      case 6: {
        if (tag == 49) {
         parse_cycle_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cycle_time_)));
          set_has_cycle_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_debug;
        break;
      }

      // optional int32 debug = 7;
      case 7: {
        if (tag == 56) {
         parse_debug:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &debug_)));
          set_has_debug();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_kinematics_type;
        break;
      }

      // optional .pb.EmcKinematicsType kinematics_type = 8;
      case 8: {
        if (tag == 64) {
         parse_kinematics_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcKinematicsType_IsValid(value)) {
            set_kinematics_type(static_cast< ::pb::EmcKinematicsType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_linear_units;
        break;
      }

      // optional double linear_units = 9;
      case 9: {
        if (tag == 73) {
         parse_linear_units:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &linear_units_)));
          set_has_linear_units();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_max_acceleration;
        break;
      }

      // optional double max_acceleration = 10;
      case 10: {
        if (tag == 81) {
         parse_max_acceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_acceleration_)));
          set_has_max_acceleration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(89)) goto parse_max_velocity;
        break;
      }

      // optional double max_velocity = 11;
      case 11: {
        if (tag == 89) {
         parse_max_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_velocity_)));
          set_has_max_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_program_units;
        break;
      }

      // optional .pb.EmcCanonUnitsType program_units = 12;
      case 12: {
        if (tag == 96) {
         parse_program_units:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcCanonUnitsType_IsValid(value)) {
            set_program_units(static_cast< ::pb::EmcCanonUnitsType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(12, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(105)) goto parse_default_velocity;
        break;
      }

      // optional double default_velocity = 13;
      case 13: {
        if (tag == 105) {
         parse_default_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &default_velocity_)));
          set_has_default_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_program_extension;
        break;
      }

      // repeated .pb.EmcProgramExtension program_extension = 14;
      case 14: {
        if (tag == 114) {
         parse_program_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_program_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_program_extension;
        if (input->ExpectTag(120)) goto parse_position_offset;
        break;
      }

      // optional .pb.EmcPositionOffsetType position_offset = 15;
      case 15: {
        if (tag == 120) {
         parse_position_offset:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcPositionOffsetType_IsValid(value)) {
            set_position_offset(static_cast< ::pb::EmcPositionOffsetType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(15, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_position_feedback;
        break;
      }

      // optional .pb.EmcPositionFeedbackType position_feedback = 16;
      case 16: {
        if (tag == 128) {
         parse_position_feedback:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcPositionFeedbackType_IsValid(value)) {
            set_position_feedback(static_cast< ::pb::EmcPositionFeedbackType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(16, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(137)) goto parse_max_feed_override;
        break;
      }

      // optional double max_feed_override = 17;
      case 17: {
        if (tag == 137) {
         parse_max_feed_override:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_feed_override_)));
          set_has_max_feed_override();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(145)) goto parse_min_feed_override;
        break;
      }

      // optional double min_feed_override = 18;
      case 18: {
        if (tag == 145) {
         parse_min_feed_override:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_feed_override_)));
          set_has_min_feed_override();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(153)) goto parse_max_spindle_override;
        break;
      }

      // optional double max_spindle_override = 19;
      case 19: {
        if (tag == 153) {
         parse_max_spindle_override:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_spindle_override_)));
          set_has_max_spindle_override();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(161)) goto parse_min_spindle_override;
        break;
      }

      // optional double min_spindle_override = 20;
      case 20: {
        if (tag == 161) {
         parse_min_spindle_override:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_spindle_override_)));
          set_has_min_spindle_override();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(169)) goto parse_default_spindle_speed;
        break;
      }

      // optional double default_spindle_speed = 21;
      case 21: {
        if (tag == 169) {
         parse_default_spindle_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &default_spindle_speed_)));
          set_has_default_spindle_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(177)) goto parse_default_linear_velocity;
        break;
      }

      // optional double default_linear_velocity = 22;
      case 22: {
        if (tag == 177) {
         parse_default_linear_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &default_linear_velocity_)));
          set_has_default_linear_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(185)) goto parse_min_velocity;
        break;
      }

      // optional double min_velocity = 23;
      case 23: {
        if (tag == 185) {
         parse_min_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_velocity_)));
          set_has_min_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(193)) goto parse_max_linear_velocity;
        break;
      }

      // optional double max_linear_velocity = 24;
      case 24: {
        if (tag == 193) {
         parse_max_linear_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_linear_velocity_)));
          set_has_max_linear_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(201)) goto parse_min_linear_velocity;
        break;
      }

      // optional double min_linear_velocity = 25;
      case 25: {
        if (tag == 201) {
         parse_min_linear_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_linear_velocity_)));
          set_has_min_linear_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(209)) goto parse_default_angular_velocity;
        break;
      }

      // optional double default_angular_velocity = 26;
      case 26: {
        if (tag == 209) {
         parse_default_angular_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &default_angular_velocity_)));
          set_has_default_angular_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(217)) goto parse_max_angular_velocity;
        break;
      }

      // optional double max_angular_velocity = 27;
      case 27: {
        if (tag == 217) {
         parse_max_angular_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_angular_velocity_)));
          set_has_max_angular_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(225)) goto parse_min_angular_velocity;
        break;
      }

      // optional double min_angular_velocity = 28;
      case 28: {
        if (tag == 225) {
         parse_min_angular_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &min_angular_velocity_)));
          set_has_min_angular_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_increments;
        break;
      }

      // optional string increments = 29;
      case 29: {
        if (tag == 234) {
         parse_increments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_increments()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->increments().data(), this->increments().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "increments");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_grids;
        break;
      }

      // optional string grids = 30;
      case 30: {
        if (tag == 242) {
         parse_grids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_grids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->grids().data(), this->grids().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "grids");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_lathe;
        break;
      }

      // optional bool lathe = 31;
      case 31: {
        if (tag == 248) {
         parse_lathe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lathe_)));
          set_has_lathe();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_geometry;
        break;
      }

      // optional string geometry = 32;
      case 32: {
        if (tag == 258) {
         parse_geometry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_geometry()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->geometry().data(), this->geometry().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "geometry");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_arcdivision;
        break;
      }

      // optional uint32 arcdivision = 33;
      case 33: {
        if (tag == 264) {
         parse_arcdivision:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &arcdivision_)));
          set_has_arcdivision();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_no_force_homing;
        break;
      }

      // optional bool no_force_homing = 34;
      case 34: {
        if (tag == 272) {
         parse_no_force_homing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_force_homing_)));
          set_has_no_force_homing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_remote_path;
        break;
      }

      // optional string remote_path = 35;
      case 35: {
        if (tag == 282) {
         parse_remote_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_remote_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->remote_path().data(), this->remote_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "remote_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_time_units;
        break;
      }

      // optional .pb.EmcTimeUnitsType time_units = 36;
      case 36: {
        if (tag == 288) {
         parse_time_units:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTimeUnitsType_IsValid(value)) {
            set_time_units(static_cast< ::pb::EmcTimeUnitsType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(36, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(298)) goto parse_name;
        break;
      }

      // optional string name = 37;
      case 37: {
        if (tag == 298) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(306)) goto parse_user_command;
        break;
      }

      // repeated .pb.EmcStatusUserCommand user_command = 38;
      case 38: {
        if (tag == 306) {
         parse_user_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_user_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(306)) goto parse_user_command;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusConfig)
  return false;
#undef DO_
}

void EmcStatusConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusConfig)
  // optional double default_acceleration = 1;
  if (has_default_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->default_acceleration(), output);
  }

  // optional double angular_units = 2;
  if (has_angular_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->angular_units(), output);
  }

  // optional int32 axes = 3;
  if (has_axes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->axes(), output);
  }

  // repeated .pb.EmcStatusConfigAxis axis = 4;
  for (int i = 0; i < this->axis_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->axis(i), output);
  }

  // optional int32 axis_mask = 5;
  if (has_axis_mask()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->axis_mask(), output);
  }

  // optional double cycle_time = 6;
  if (has_cycle_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->cycle_time(), output);
  }

  // optional int32 debug = 7;
  if (has_debug()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->debug(), output);
  }

  // optional .pb.EmcKinematicsType kinematics_type = 8;
  if (has_kinematics_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->kinematics_type(), output);
  }

  // optional double linear_units = 9;
  if (has_linear_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->linear_units(), output);
  }

  // optional double max_acceleration = 10;
  if (has_max_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->max_acceleration(), output);
  }

  // optional double max_velocity = 11;
  if (has_max_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(11, this->max_velocity(), output);
  }

  // optional .pb.EmcCanonUnitsType program_units = 12;
  if (has_program_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->program_units(), output);
  }

  // optional double default_velocity = 13;
  if (has_default_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->default_velocity(), output);
  }

  // repeated .pb.EmcProgramExtension program_extension = 14;
  for (int i = 0; i < this->program_extension_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->program_extension(i), output);
  }

  // optional .pb.EmcPositionOffsetType position_offset = 15;
  if (has_position_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      15, this->position_offset(), output);
  }

  // optional .pb.EmcPositionFeedbackType position_feedback = 16;
  if (has_position_feedback()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      16, this->position_feedback(), output);
  }

  // optional double max_feed_override = 17;
  if (has_max_feed_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(17, this->max_feed_override(), output);
  }

  // optional double min_feed_override = 18;
  if (has_min_feed_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->min_feed_override(), output);
  }

  // optional double max_spindle_override = 19;
  if (has_max_spindle_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(19, this->max_spindle_override(), output);
  }

  // optional double min_spindle_override = 20;
  if (has_min_spindle_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(20, this->min_spindle_override(), output);
  }

  // optional double default_spindle_speed = 21;
  if (has_default_spindle_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->default_spindle_speed(), output);
  }

  // optional double default_linear_velocity = 22;
  if (has_default_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(22, this->default_linear_velocity(), output);
  }

  // optional double min_velocity = 23;
  if (has_min_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->min_velocity(), output);
  }

  // optional double max_linear_velocity = 24;
  if (has_max_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->max_linear_velocity(), output);
  }

  // optional double min_linear_velocity = 25;
  if (has_min_linear_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->min_linear_velocity(), output);
  }

  // optional double default_angular_velocity = 26;
  if (has_default_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(26, this->default_angular_velocity(), output);
  }

  // optional double max_angular_velocity = 27;
  if (has_max_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->max_angular_velocity(), output);
  }

  // optional double min_angular_velocity = 28;
  if (has_min_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->min_angular_velocity(), output);
  }

  // optional string increments = 29;
  if (has_increments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->increments().data(), this->increments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "increments");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      29, this->increments(), output);
  }

  // optional string grids = 30;
  if (has_grids()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->grids().data(), this->grids().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "grids");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      30, this->grids(), output);
  }

  // optional bool lathe = 31;
  if (has_lathe()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(31, this->lathe(), output);
  }

  // optional string geometry = 32;
  if (has_geometry()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->geometry().data(), this->geometry().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "geometry");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      32, this->geometry(), output);
  }

  // optional uint32 arcdivision = 33;
  if (has_arcdivision()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->arcdivision(), output);
  }

  // optional bool no_force_homing = 34;
  if (has_no_force_homing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(34, this->no_force_homing(), output);
  }

  // optional string remote_path = 35;
  if (has_remote_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->remote_path().data(), this->remote_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "remote_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      35, this->remote_path(), output);
  }

  // optional .pb.EmcTimeUnitsType time_units = 36;
  if (has_time_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      36, this->time_units(), output);
  }

  // optional string name = 37;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      37, this->name(), output);
  }

  // repeated .pb.EmcStatusUserCommand user_command = 38;
  for (int i = 0; i < this->user_command_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      38, this->user_command(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusConfig)
}

::google::protobuf::uint8* EmcStatusConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusConfig)
  // optional double default_acceleration = 1;
  if (has_default_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->default_acceleration(), target);
  }

  // optional double angular_units = 2;
  if (has_angular_units()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->angular_units(), target);
  }

  // optional int32 axes = 3;
  if (has_axes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->axes(), target);
  }

  // repeated .pb.EmcStatusConfigAxis axis = 4;
  for (int i = 0; i < this->axis_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->axis(i), target);
  }

  // optional int32 axis_mask = 5;
  if (has_axis_mask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->axis_mask(), target);
  }

  // optional double cycle_time = 6;
  if (has_cycle_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->cycle_time(), target);
  }

  // optional int32 debug = 7;
  if (has_debug()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->debug(), target);
  }

  // optional .pb.EmcKinematicsType kinematics_type = 8;
  if (has_kinematics_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->kinematics_type(), target);
  }

  // optional double linear_units = 9;
  if (has_linear_units()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->linear_units(), target);
  }

  // optional double max_acceleration = 10;
  if (has_max_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->max_acceleration(), target);
  }

  // optional double max_velocity = 11;
  if (has_max_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(11, this->max_velocity(), target);
  }

  // optional .pb.EmcCanonUnitsType program_units = 12;
  if (has_program_units()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->program_units(), target);
  }

  // optional double default_velocity = 13;
  if (has_default_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->default_velocity(), target);
  }

  // repeated .pb.EmcProgramExtension program_extension = 14;
  for (int i = 0; i < this->program_extension_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->program_extension(i), target);
  }

  // optional .pb.EmcPositionOffsetType position_offset = 15;
  if (has_position_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      15, this->position_offset(), target);
  }

  // optional .pb.EmcPositionFeedbackType position_feedback = 16;
  if (has_position_feedback()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      16, this->position_feedback(), target);
  }

  // optional double max_feed_override = 17;
  if (has_max_feed_override()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(17, this->max_feed_override(), target);
  }

  // optional double min_feed_override = 18;
  if (has_min_feed_override()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->min_feed_override(), target);
  }

  // optional double max_spindle_override = 19;
  if (has_max_spindle_override()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(19, this->max_spindle_override(), target);
  }

  // optional double min_spindle_override = 20;
  if (has_min_spindle_override()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(20, this->min_spindle_override(), target);
  }

  // optional double default_spindle_speed = 21;
  if (has_default_spindle_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(21, this->default_spindle_speed(), target);
  }

  // optional double default_linear_velocity = 22;
  if (has_default_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(22, this->default_linear_velocity(), target);
  }

  // optional double min_velocity = 23;
  if (has_min_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->min_velocity(), target);
  }

  // optional double max_linear_velocity = 24;
  if (has_max_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->max_linear_velocity(), target);
  }

  // optional double min_linear_velocity = 25;
  if (has_min_linear_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->min_linear_velocity(), target);
  }

  // optional double default_angular_velocity = 26;
  if (has_default_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(26, this->default_angular_velocity(), target);
  }

  // optional double max_angular_velocity = 27;
  if (has_max_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(27, this->max_angular_velocity(), target);
  }

  // optional double min_angular_velocity = 28;
  if (has_min_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->min_angular_velocity(), target);
  }

  // optional string increments = 29;
  if (has_increments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->increments().data(), this->increments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "increments");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        29, this->increments(), target);
  }

  // optional string grids = 30;
  if (has_grids()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->grids().data(), this->grids().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "grids");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->grids(), target);
  }

  // optional bool lathe = 31;
  if (has_lathe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(31, this->lathe(), target);
  }

  // optional string geometry = 32;
  if (has_geometry()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->geometry().data(), this->geometry().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "geometry");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        32, this->geometry(), target);
  }

  // optional uint32 arcdivision = 33;
  if (has_arcdivision()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(33, this->arcdivision(), target);
  }

  // optional bool no_force_homing = 34;
  if (has_no_force_homing()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(34, this->no_force_homing(), target);
  }

  // optional string remote_path = 35;
  if (has_remote_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->remote_path().data(), this->remote_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "remote_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        35, this->remote_path(), target);
  }

  // optional .pb.EmcTimeUnitsType time_units = 36;
  if (has_time_units()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      36, this->time_units(), target);
  }

  // optional string name = 37;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        37, this->name(), target);
  }

  // repeated .pb.EmcStatusUserCommand user_command = 38;
  for (int i = 0; i < this->user_command_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        38, this->user_command(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusConfig)
  return target;
}

int EmcStatusConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional double default_acceleration = 1;
    if (has_default_acceleration()) {
      total_size += 1 + 8;
    }

    // optional double angular_units = 2;
    if (has_angular_units()) {
      total_size += 1 + 8;
    }

    // optional int32 axes = 3;
    if (has_axes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->axes());
    }

    // optional int32 axis_mask = 5;
    if (has_axis_mask()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->axis_mask());
    }

    // optional double cycle_time = 6;
    if (has_cycle_time()) {
      total_size += 1 + 8;
    }

    // optional int32 debug = 7;
    if (has_debug()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->debug());
    }

    // optional .pb.EmcKinematicsType kinematics_type = 8;
    if (has_kinematics_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->kinematics_type());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double linear_units = 9;
    if (has_linear_units()) {
      total_size += 1 + 8;
    }

    // optional double max_acceleration = 10;
    if (has_max_acceleration()) {
      total_size += 1 + 8;
    }

    // optional double max_velocity = 11;
    if (has_max_velocity()) {
      total_size += 1 + 8;
    }

    // optional .pb.EmcCanonUnitsType program_units = 12;
    if (has_program_units()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->program_units());
    }

    // optional double default_velocity = 13;
    if (has_default_velocity()) {
      total_size += 1 + 8;
    }

    // optional .pb.EmcPositionOffsetType position_offset = 15;
    if (has_position_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->position_offset());
    }

    // optional .pb.EmcPositionFeedbackType position_feedback = 16;
    if (has_position_feedback()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->position_feedback());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional double max_feed_override = 17;
    if (has_max_feed_override()) {
      total_size += 2 + 8;
    }

    // optional double min_feed_override = 18;
    if (has_min_feed_override()) {
      total_size += 2 + 8;
    }

    // optional double max_spindle_override = 19;
    if (has_max_spindle_override()) {
      total_size += 2 + 8;
    }

    // optional double min_spindle_override = 20;
    if (has_min_spindle_override()) {
      total_size += 2 + 8;
    }

    // optional double default_spindle_speed = 21;
    if (has_default_spindle_speed()) {
      total_size += 2 + 8;
    }

    // optional double default_linear_velocity = 22;
    if (has_default_linear_velocity()) {
      total_size += 2 + 8;
    }

    // optional double min_velocity = 23;
    if (has_min_velocity()) {
      total_size += 2 + 8;
    }

    // optional double max_linear_velocity = 24;
    if (has_max_linear_velocity()) {
      total_size += 2 + 8;
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional double min_linear_velocity = 25;
    if (has_min_linear_velocity()) {
      total_size += 2 + 8;
    }

    // optional double default_angular_velocity = 26;
    if (has_default_angular_velocity()) {
      total_size += 2 + 8;
    }

    // optional double max_angular_velocity = 27;
    if (has_max_angular_velocity()) {
      total_size += 2 + 8;
    }

    // optional double min_angular_velocity = 28;
    if (has_min_angular_velocity()) {
      total_size += 2 + 8;
    }

    // optional string increments = 29;
    if (has_increments()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->increments());
    }

    // optional string grids = 30;
    if (has_grids()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->grids());
    }

    // optional bool lathe = 31;
    if (has_lathe()) {
      total_size += 2 + 1;
    }

    // optional string geometry = 32;
    if (has_geometry()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->geometry());
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional uint32 arcdivision = 33;
    if (has_arcdivision()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->arcdivision());
    }

    // optional bool no_force_homing = 34;
    if (has_no_force_homing()) {
      total_size += 2 + 1;
    }

    // optional string remote_path = 35;
    if (has_remote_path()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->remote_path());
    }

    // optional .pb.EmcTimeUnitsType time_units = 36;
    if (has_time_units()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->time_units());
    }

    // optional string name = 37;
    if (has_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .pb.EmcStatusConfigAxis axis = 4;
  total_size += 1 * this->axis_size();
  for (int i = 0; i < this->axis_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->axis(i));
  }

  // repeated .pb.EmcProgramExtension program_extension = 14;
  total_size += 1 * this->program_extension_size();
  for (int i = 0; i < this->program_extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->program_extension(i));
  }

  // repeated .pb.EmcStatusUserCommand user_command = 38;
  total_size += 2 * this->user_command_size();
  for (int i = 0; i < this->user_command_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->user_command(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusConfig::MergeFrom(const EmcStatusConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  axis_.MergeFrom(from.axis_);
  program_extension_.MergeFrom(from.program_extension_);
  user_command_.MergeFrom(from.user_command_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_default_acceleration()) {
      set_default_acceleration(from.default_acceleration());
    }
    if (from.has_angular_units()) {
      set_angular_units(from.angular_units());
    }
    if (from.has_axes()) {
      set_axes(from.axes());
    }
    if (from.has_axis_mask()) {
      set_axis_mask(from.axis_mask());
    }
    if (from.has_cycle_time()) {
      set_cycle_time(from.cycle_time());
    }
    if (from.has_debug()) {
      set_debug(from.debug());
    }
    if (from.has_kinematics_type()) {
      set_kinematics_type(from.kinematics_type());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_linear_units()) {
      set_linear_units(from.linear_units());
    }
    if (from.has_max_acceleration()) {
      set_max_acceleration(from.max_acceleration());
    }
    if (from.has_max_velocity()) {
      set_max_velocity(from.max_velocity());
    }
    if (from.has_program_units()) {
      set_program_units(from.program_units());
    }
    if (from.has_default_velocity()) {
      set_default_velocity(from.default_velocity());
    }
    if (from.has_position_offset()) {
      set_position_offset(from.position_offset());
    }
    if (from.has_position_feedback()) {
      set_position_feedback(from.position_feedback());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_max_feed_override()) {
      set_max_feed_override(from.max_feed_override());
    }
    if (from.has_min_feed_override()) {
      set_min_feed_override(from.min_feed_override());
    }
    if (from.has_max_spindle_override()) {
      set_max_spindle_override(from.max_spindle_override());
    }
    if (from.has_min_spindle_override()) {
      set_min_spindle_override(from.min_spindle_override());
    }
    if (from.has_default_spindle_speed()) {
      set_default_spindle_speed(from.default_spindle_speed());
    }
    if (from.has_default_linear_velocity()) {
      set_default_linear_velocity(from.default_linear_velocity());
    }
    if (from.has_min_velocity()) {
      set_min_velocity(from.min_velocity());
    }
    if (from.has_max_linear_velocity()) {
      set_max_linear_velocity(from.max_linear_velocity());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_min_linear_velocity()) {
      set_min_linear_velocity(from.min_linear_velocity());
    }
    if (from.has_default_angular_velocity()) {
      set_default_angular_velocity(from.default_angular_velocity());
    }
    if (from.has_max_angular_velocity()) {
      set_max_angular_velocity(from.max_angular_velocity());
    }
    if (from.has_min_angular_velocity()) {
      set_min_angular_velocity(from.min_angular_velocity());
    }
    if (from.has_increments()) {
      set_increments(from.increments());
    }
    if (from.has_grids()) {
      set_grids(from.grids());
    }
    if (from.has_lathe()) {
      set_lathe(from.lathe());
    }
    if (from.has_geometry()) {
      set_geometry(from.geometry());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_arcdivision()) {
      set_arcdivision(from.arcdivision());
    }
    if (from.has_no_force_homing()) {
      set_no_force_homing(from.no_force_homing());
    }
    if (from.has_remote_path()) {
      set_remote_path(from.remote_path());
    }
    if (from.has_time_units()) {
      set_time_units(from.time_units());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusConfig::CopyFrom(const EmcStatusConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusConfig::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->axis())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->program_extension())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->user_command())) return false;
  return true;
}

void EmcStatusConfig::Swap(EmcStatusConfig* other) {
  if (other != this) {
    std::swap(default_acceleration_, other->default_acceleration_);
    std::swap(angular_units_, other->angular_units_);
    std::swap(axes_, other->axes_);
    axis_.Swap(&other->axis_);
    std::swap(axis_mask_, other->axis_mask_);
    std::swap(cycle_time_, other->cycle_time_);
    std::swap(debug_, other->debug_);
    std::swap(kinematics_type_, other->kinematics_type_);
    std::swap(linear_units_, other->linear_units_);
    std::swap(max_acceleration_, other->max_acceleration_);
    std::swap(max_velocity_, other->max_velocity_);
    std::swap(program_units_, other->program_units_);
    std::swap(default_velocity_, other->default_velocity_);
    program_extension_.Swap(&other->program_extension_);
    std::swap(position_offset_, other->position_offset_);
    std::swap(position_feedback_, other->position_feedback_);
    std::swap(max_feed_override_, other->max_feed_override_);
    std::swap(min_feed_override_, other->min_feed_override_);
    std::swap(max_spindle_override_, other->max_spindle_override_);
    std::swap(min_spindle_override_, other->min_spindle_override_);
    std::swap(default_spindle_speed_, other->default_spindle_speed_);
    std::swap(default_linear_velocity_, other->default_linear_velocity_);
    std::swap(min_velocity_, other->min_velocity_);
    std::swap(max_linear_velocity_, other->max_linear_velocity_);
    std::swap(min_linear_velocity_, other->min_linear_velocity_);
    std::swap(default_angular_velocity_, other->default_angular_velocity_);
    std::swap(max_angular_velocity_, other->max_angular_velocity_);
    std::swap(min_angular_velocity_, other->min_angular_velocity_);
    std::swap(increments_, other->increments_);
    std::swap(grids_, other->grids_);
    std::swap(lathe_, other->lathe_);
    std::swap(geometry_, other->geometry_);
    std::swap(arcdivision_, other->arcdivision_);
    std::swap(no_force_homing_, other->no_force_homing_);
    std::swap(remote_path_, other->remote_path_);
    std::swap(time_units_, other->time_units_);
    std::swap(name_, other->name_);
    user_command_.Swap(&other->user_command_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusConfig_descriptor_;
  metadata.reflection = EmcStatusConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusMotion::kActiveQueueFieldNumber;
const int EmcStatusMotion::kActualPositionFieldNumber;
const int EmcStatusMotion::kAdaptiveFeedEnabledFieldNumber;
const int EmcStatusMotion::kAinFieldNumber;
const int EmcStatusMotion::kAoutFieldNumber;
const int EmcStatusMotion::kAxisFieldNumber;
const int EmcStatusMotion::kBlockDeleteFieldNumber;
const int EmcStatusMotion::kCurrentLineFieldNumber;
const int EmcStatusMotion::kCurrentVelFieldNumber;
const int EmcStatusMotion::kDelayLeftFieldNumber;
const int EmcStatusMotion::kDinFieldNumber;
const int EmcStatusMotion::kDistanceToGoFieldNumber;
const int EmcStatusMotion::kDoutFieldNumber;
const int EmcStatusMotion::kDtgFieldNumber;
const int EmcStatusMotion::kEnabledFieldNumber;
const int EmcStatusMotion::kFeedHoldEnabledFieldNumber;
const int EmcStatusMotion::kFeedOverrideEnabledFieldNumber;
const int EmcStatusMotion::kFeedrateFieldNumber;
const int EmcStatusMotion::kG5XIndexFieldNumber;
const int EmcStatusMotion::kG5XOffsetFieldNumber;
const int EmcStatusMotion::kG92OffsetFieldNumber;
const int EmcStatusMotion::kIdFieldNumber;
const int EmcStatusMotion::kInposFieldNumber;
const int EmcStatusMotion::kJointActualPositionFieldNumber;
const int EmcStatusMotion::kJointPositionFieldNumber;
const int EmcStatusMotion::kLimitFieldNumber;
const int EmcStatusMotion::kMotionLineFieldNumber;
const int EmcStatusMotion::kMotionTypeFieldNumber;
const int EmcStatusMotion::kMotionModeFieldNumber;
const int EmcStatusMotion::kPausedFieldNumber;
const int EmcStatusMotion::kPositionFieldNumber;
const int EmcStatusMotion::kProbeTrippedFieldNumber;
const int EmcStatusMotion::kProbeValFieldNumber;
const int EmcStatusMotion::kProbedPositionFieldNumber;
const int EmcStatusMotion::kProbingFieldNumber;
const int EmcStatusMotion::kQueueFieldNumber;
const int EmcStatusMotion::kQueueFullFieldNumber;
const int EmcStatusMotion::kRotationXyFieldNumber;
const int EmcStatusMotion::kSpindleBrakeFieldNumber;
const int EmcStatusMotion::kSpindleDirectionFieldNumber;
const int EmcStatusMotion::kSpindleEnabledFieldNumber;
const int EmcStatusMotion::kSpindleIncreasingFieldNumber;
const int EmcStatusMotion::kSpindleOverrideEnabledFieldNumber;
const int EmcStatusMotion::kSpindleSpeedFieldNumber;
const int EmcStatusMotion::kSpindlerateFieldNumber;
const int EmcStatusMotion::kStateFieldNumber;
const int EmcStatusMotion::kMaxVelocityFieldNumber;
const int EmcStatusMotion::kMaxAccelerationFieldNumber;
#endif  // !_MSC_VER

EmcStatusMotion::EmcStatusMotion()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusMotion)
}

void EmcStatusMotion::InitAsDefaultInstance() {
  actual_position_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  dtg_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  g5x_offset_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  g92_offset_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  joint_actual_position_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  joint_position_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  position_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
  probed_position_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
}

EmcStatusMotion::EmcStatusMotion(const EmcStatusMotion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusMotion)
}

void EmcStatusMotion::SharedCtor() {
  _cached_size_ = 0;
  active_queue_ = 0;
  actual_position_ = NULL;
  adaptive_feed_enabled_ = false;
  block_delete_ = false;
  current_line_ = 0;
  current_vel_ = 0;
  delay_left_ = 0;
  distance_to_go_ = 0;
  dtg_ = NULL;
  enabled_ = false;
  feed_hold_enabled_ = false;
  feed_override_enabled_ = false;
  feedrate_ = 0;
  g5x_index_ = 0;
  g5x_offset_ = NULL;
  g92_offset_ = NULL;
  id_ = 0;
  inpos_ = false;
  joint_actual_position_ = NULL;
  joint_position_ = NULL;
  motion_line_ = 0;
  motion_type_ = 0;
  motion_mode_ = 1;
  paused_ = false;
  position_ = NULL;
  probe_tripped_ = false;
  probe_val_ = 0;
  probed_position_ = NULL;
  probing_ = false;
  queue_ = 0;
  queue_full_ = false;
  rotation_xy_ = 0;
  spindle_brake_ = false;
  spindle_direction_ = 0;
  spindle_enabled_ = false;
  spindle_increasing_ = 0;
  spindle_override_enabled_ = false;
  spindle_speed_ = 0;
  spindlerate_ = 0;
  state_ = -1;
  max_velocity_ = 0;
  max_acceleration_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusMotion::~EmcStatusMotion() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusMotion)
  SharedDtor();
}

void EmcStatusMotion::SharedDtor() {
  if (this != default_instance_) {
    delete actual_position_;
    delete dtg_;
    delete g5x_offset_;
    delete g92_offset_;
    delete joint_actual_position_;
    delete joint_position_;
    delete position_;
    delete probed_position_;
  }
}

void EmcStatusMotion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusMotion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusMotion_descriptor_;
}

const EmcStatusMotion& EmcStatusMotion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusMotion* EmcStatusMotion::default_instance_ = NULL;

EmcStatusMotion* EmcStatusMotion::New() const {
  return new EmcStatusMotion;
}

void EmcStatusMotion::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusMotion*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 199) {
    ZR_(active_queue_, current_line_);
    ZR_(adaptive_feed_enabled_, block_delete_);
    if (has_actual_position()) {
      if (actual_position_ != NULL) actual_position_->::pb::Position::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 60160) {
    ZR_(current_vel_, delay_left_);
    ZR_(enabled_, feed_hold_enabled_);
    distance_to_go_ = 0;
    if (has_dtg()) {
      if (dtg_ != NULL) dtg_->::pb::Position::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 16711680) {
    ZR_(id_, inpos_);
    feedrate_ = 0;
    g5x_index_ = 0;
    if (has_g5x_offset()) {
      if (g5x_offset_ != NULL) g5x_offset_->::pb::Position::Clear();
    }
    if (has_g92_offset()) {
      if (g92_offset_ != NULL) g92_offset_->::pb::Position::Clear();
    }
    if (has_joint_actual_position()) {
      if (joint_actual_position_ != NULL) joint_actual_position_->::pb::Position::Clear();
    }
  }
  if (_has_bits_[24 / 32] & 4244635648) {
    ZR_(paused_, probe_tripped_);
    ZR_(motion_line_, motion_type_);
    if (has_joint_position()) {
      if (joint_position_ != NULL) joint_position_->::pb::Position::Clear();
    }
    motion_mode_ = 1;
    if (has_position()) {
      if (position_ != NULL) position_->::pb::Position::Clear();
    }
  }
  if (_has_bits_[32 / 32] & 255) {
    ZR_(queue_, spindle_brake_);
    ZR_(rotation_xy_, spindle_direction_);
    probe_val_ = 0;
    if (has_probed_position()) {
      if (probed_position_ != NULL) probed_position_->::pb::Position::Clear();
    }
  }
  if (_has_bits_[40 / 32] & 65280) {
    ZR_(spindle_increasing_, spindle_override_enabled_);
    ZR_(spindlerate_, max_acceleration_);
    spindle_enabled_ = false;
    state_ = -1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ain_.Clear();
  aout_.Clear();
  axis_.Clear();
  din_.Clear();
  dout_.Clear();
  limit_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusMotion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusMotion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 active_queue = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &active_queue_)));
          set_has_active_queue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_actual_position;
        break;
      }

      // optional .pb.Position actual_position = 2;
      case 2: {
        if (tag == 18) {
         parse_actual_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actual_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_adaptive_feed_enabled;
        break;
      }

      // optional bool adaptive_feed_enabled = 3;
      case 3: {
        if (tag == 24) {
         parse_adaptive_feed_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &adaptive_feed_enabled_)));
          set_has_adaptive_feed_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ain;
        break;
      }

      // repeated .pb.EmcStatusAnalogIO ain = 4;
      case 4: {
        if (tag == 34) {
         parse_ain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ain()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ain;
        if (input->ExpectTag(42)) goto parse_aout;
        break;
      }

      // repeated .pb.EmcStatusAnalogIO aout = 5;
      case 5: {
        if (tag == 42) {
         parse_aout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_aout()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_aout;
        if (input->ExpectTag(50)) goto parse_axis;
        break;
      }

      // repeated .pb.EmcStatusMotionAxis axis = 6;
      case 6: {
        if (tag == 50) {
         parse_axis:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_axis()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_axis;
        if (input->ExpectTag(56)) goto parse_block_delete;
        break;
      }

      // optional bool block_delete = 7;
      case 7: {
        if (tag == 56) {
         parse_block_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &block_delete_)));
          set_has_block_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_current_line;
        break;
      }

      // optional int32 current_line = 8;
      case 8: {
        if (tag == 64) {
         parse_current_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_line_)));
          set_has_current_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_current_vel;
        break;
      }

      // optional double current_vel = 9;
      case 9: {
        if (tag == 73) {
         parse_current_vel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &current_vel_)));
          set_has_current_vel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(81)) goto parse_delay_left;
        break;
      }

      // optional double delay_left = 10;
      case 10: {
        if (tag == 81) {
         parse_delay_left:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &delay_left_)));
          set_has_delay_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_din;
        break;
      }

      // repeated .pb.EmcStatusDigitalIO din = 11;
      case 11: {
        if (tag == 90) {
         parse_din:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_din()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_din;
        if (input->ExpectTag(97)) goto parse_distance_to_go;
        break;
      }

      // optional double distance_to_go = 12;
      case 12: {
        if (tag == 97) {
         parse_distance_to_go:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_to_go_)));
          set_has_distance_to_go();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_dout;
        break;
      }

      // repeated .pb.EmcStatusDigitalIO dout = 13;
      case 13: {
        if (tag == 106) {
         parse_dout:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_dout()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_dout;
        if (input->ExpectTag(114)) goto parse_dtg;
        break;
      }

      // optional .pb.Position dtg = 14;
      case 14: {
        if (tag == 114) {
         parse_dtg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dtg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_enabled;
        break;
      }

      // optional bool enabled = 15;
      case 15: {
        if (tag == 120) {
         parse_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enabled_)));
          set_has_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_feed_hold_enabled;
        break;
      }

      // optional bool feed_hold_enabled = 16;
      case 16: {
        if (tag == 128) {
         parse_feed_hold_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &feed_hold_enabled_)));
          set_has_feed_hold_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_feed_override_enabled;
        break;
      }

      // optional bool feed_override_enabled = 17;
      case 17: {
        if (tag == 136) {
         parse_feed_override_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &feed_override_enabled_)));
          set_has_feed_override_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(145)) goto parse_feedrate;
        break;
      }

      // optional double feedrate = 18;
      case 18: {
        if (tag == 145) {
         parse_feedrate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &feedrate_)));
          set_has_feedrate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_g5x_index;
        break;
      }

      // optional .pb.OriginIndex g5x_index = 19;
      case 19: {
        if (tag == 152) {
         parse_g5x_index:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::OriginIndex_IsValid(value)) {
            set_g5x_index(static_cast< ::pb::OriginIndex >(value));
          } else {
            mutable_unknown_fields()->AddVarint(19, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_g5x_offset;
        break;
      }

      // optional .pb.Position g5x_offset = 20;
      case 20: {
        if (tag == 162) {
         parse_g5x_offset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_g5x_offset()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_g92_offset;
        break;
      }

      // optional .pb.Position g92_offset = 21;
      case 21: {
        if (tag == 170) {
         parse_g92_offset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_g92_offset()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_id;
        break;
      }

      // optional int32 id = 23;
      case 23: {
        if (tag == 184) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_inpos;
        break;
      }

      // optional bool inpos = 24;
      case 24: {
        if (tag == 192) {
         parse_inpos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &inpos_)));
          set_has_inpos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_joint_actual_position;
        break;
      }

      // optional .pb.Position joint_actual_position = 25;
      case 25: {
        if (tag == 202) {
         parse_joint_actual_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joint_actual_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(210)) goto parse_joint_position;
        break;
      }

      // optional .pb.Position joint_position = 26;
      case 26: {
        if (tag == 210) {
         parse_joint_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_joint_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_limit;
        break;
      }

      // repeated .pb.EmcStatusLimit limit = 27;
      case 27: {
        if (tag == 218) {
         parse_limit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_limit()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_limit;
        if (input->ExpectTag(224)) goto parse_motion_line;
        break;
      }

      // optional int32 motion_line = 28;
      case 28: {
        if (tag == 224) {
         parse_motion_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &motion_line_)));
          set_has_motion_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_motion_type;
        break;
      }

      // optional .pb.MotionType motion_type = 29;
      case 29: {
        if (tag == 232) {
         parse_motion_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::MotionType_IsValid(value)) {
            set_motion_type(static_cast< ::pb::MotionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(29, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_motion_mode;
        break;
      }

      // optional .pb.EmcTrajectoryModeType motion_mode = 30;
      case 30: {
        if (tag == 240) {
         parse_motion_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTrajectoryModeType_IsValid(value)) {
            set_motion_mode(static_cast< ::pb::EmcTrajectoryModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(30, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_paused;
        break;
      }

      // optional bool paused = 31;
      case 31: {
        if (tag == 248) {
         parse_paused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &paused_)));
          set_has_paused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(258)) goto parse_position;
        break;
      }

      // optional .pb.Position position = 32;
      case 32: {
        if (tag == 258) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_probe_tripped;
        break;
      }

      // optional bool probe_tripped = 33;
      case 33: {
        if (tag == 264) {
         parse_probe_tripped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &probe_tripped_)));
          set_has_probe_tripped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_probe_val;
        break;
      }

      // optional int32 probe_val = 34;
      case 34: {
        if (tag == 272) {
         parse_probe_val:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &probe_val_)));
          set_has_probe_val();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_probed_position;
        break;
      }

      // optional .pb.Position probed_position = 35;
      case 35: {
        if (tag == 282) {
         parse_probed_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_probed_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_probing;
        break;
      }

      // optional bool probing = 36;
      case 36: {
        if (tag == 288) {
         parse_probing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &probing_)));
          set_has_probing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_queue;
        break;
      }

      // optional int32 queue = 37;
      case 37: {
        if (tag == 296) {
         parse_queue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &queue_)));
          set_has_queue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_queue_full;
        break;
      }

      // optional bool queue_full = 38;
      case 38: {
        if (tag == 304) {
         parse_queue_full:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &queue_full_)));
          set_has_queue_full();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(313)) goto parse_rotation_xy;
        break;
      }

      // optional double rotation_xy = 39;
      case 39: {
        if (tag == 313) {
         parse_rotation_xy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rotation_xy_)));
          set_has_rotation_xy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_spindle_brake;
        break;
      }

      // optional bool spindle_brake = 40;
      case 40: {
        if (tag == 320) {
         parse_spindle_brake:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &spindle_brake_)));
          set_has_spindle_brake();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_spindle_direction;
        break;
      }

      // optional int32 spindle_direction = 41;
      case 41: {
        if (tag == 328) {
         parse_spindle_direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &spindle_direction_)));
          set_has_spindle_direction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_spindle_enabled;
        break;
      }

      // optional bool spindle_enabled = 42;
      case 42: {
        if (tag == 336) {
         parse_spindle_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &spindle_enabled_)));
          set_has_spindle_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(344)) goto parse_spindle_increasing;
        break;
      }

      // optional int32 spindle_increasing = 43;
      case 43: {
        if (tag == 344) {
         parse_spindle_increasing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &spindle_increasing_)));
          set_has_spindle_increasing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(352)) goto parse_spindle_override_enabled;
        break;
      }

      // optional bool spindle_override_enabled = 44;
      case 44: {
        if (tag == 352) {
         parse_spindle_override_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &spindle_override_enabled_)));
          set_has_spindle_override_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(361)) goto parse_spindle_speed;
        break;
      }

      // optional double spindle_speed = 45;
      case 45: {
        if (tag == 361) {
         parse_spindle_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &spindle_speed_)));
          set_has_spindle_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(369)) goto parse_spindlerate;
        break;
      }

      // optional double spindlerate = 46;
      case 46: {
        if (tag == 369) {
         parse_spindlerate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &spindlerate_)));
          set_has_spindlerate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(376)) goto parse_state;
        break;
      }

      // optional .pb.RCS_STATUS state = 47;
      case 47: {
        if (tag == 376) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::RCS_STATUS_IsValid(value)) {
            set_state(static_cast< ::pb::RCS_STATUS >(value));
          } else {
            mutable_unknown_fields()->AddVarint(47, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(385)) goto parse_max_velocity;
        break;
      }

      // optional double max_velocity = 48;
      case 48: {
        if (tag == 385) {
         parse_max_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_velocity_)));
          set_has_max_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(393)) goto parse_max_acceleration;
        break;
      }

      // optional double max_acceleration = 49;
      case 49: {
        if (tag == 393) {
         parse_max_acceleration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_acceleration_)));
          set_has_max_acceleration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusMotion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusMotion)
  return false;
#undef DO_
}

void EmcStatusMotion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusMotion)
  // optional int32 active_queue = 1;
  if (has_active_queue()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->active_queue(), output);
  }

  // optional .pb.Position actual_position = 2;
  if (has_actual_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->actual_position(), output);
  }

  // optional bool adaptive_feed_enabled = 3;
  if (has_adaptive_feed_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->adaptive_feed_enabled(), output);
  }

  // repeated .pb.EmcStatusAnalogIO ain = 4;
  for (int i = 0; i < this->ain_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->ain(i), output);
  }

  // repeated .pb.EmcStatusAnalogIO aout = 5;
  for (int i = 0; i < this->aout_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->aout(i), output);
  }

  // repeated .pb.EmcStatusMotionAxis axis = 6;
  for (int i = 0; i < this->axis_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->axis(i), output);
  }

  // optional bool block_delete = 7;
  if (has_block_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->block_delete(), output);
  }

  // optional int32 current_line = 8;
  if (has_current_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->current_line(), output);
  }

  // optional double current_vel = 9;
  if (has_current_vel()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->current_vel(), output);
  }

  // optional double delay_left = 10;
  if (has_delay_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(10, this->delay_left(), output);
  }

  // repeated .pb.EmcStatusDigitalIO din = 11;
  for (int i = 0; i < this->din_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->din(i), output);
  }

  // optional double distance_to_go = 12;
  if (has_distance_to_go()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(12, this->distance_to_go(), output);
  }

  // repeated .pb.EmcStatusDigitalIO dout = 13;
  for (int i = 0; i < this->dout_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->dout(i), output);
  }

  // optional .pb.Position dtg = 14;
  if (has_dtg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->dtg(), output);
  }

  // optional bool enabled = 15;
  if (has_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->enabled(), output);
  }

  // optional bool feed_hold_enabled = 16;
  if (has_feed_hold_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->feed_hold_enabled(), output);
  }

  // optional bool feed_override_enabled = 17;
  if (has_feed_override_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->feed_override_enabled(), output);
  }

  // optional double feedrate = 18;
  if (has_feedrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(18, this->feedrate(), output);
  }

  // optional .pb.OriginIndex g5x_index = 19;
  if (has_g5x_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->g5x_index(), output);
  }

  // optional .pb.Position g5x_offset = 20;
  if (has_g5x_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->g5x_offset(), output);
  }

  // optional .pb.Position g92_offset = 21;
  if (has_g92_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->g92_offset(), output);
  }

  // optional int32 id = 23;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(23, this->id(), output);
  }

  // optional bool inpos = 24;
  if (has_inpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->inpos(), output);
  }

  // optional .pb.Position joint_actual_position = 25;
  if (has_joint_actual_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, this->joint_actual_position(), output);
  }

  // optional .pb.Position joint_position = 26;
  if (has_joint_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, this->joint_position(), output);
  }

  // repeated .pb.EmcStatusLimit limit = 27;
  for (int i = 0; i < this->limit_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, this->limit(i), output);
  }

  // optional int32 motion_line = 28;
  if (has_motion_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(28, this->motion_line(), output);
  }

  // optional .pb.MotionType motion_type = 29;
  if (has_motion_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      29, this->motion_type(), output);
  }

  // optional .pb.EmcTrajectoryModeType motion_mode = 30;
  if (has_motion_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      30, this->motion_mode(), output);
  }

  // optional bool paused = 31;
  if (has_paused()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(31, this->paused(), output);
  }

  // optional .pb.Position position = 32;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, this->position(), output);
  }

  // optional bool probe_tripped = 33;
  if (has_probe_tripped()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(33, this->probe_tripped(), output);
  }

  // optional int32 probe_val = 34;
  if (has_probe_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(34, this->probe_val(), output);
  }

  // optional .pb.Position probed_position = 35;
  if (has_probed_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, this->probed_position(), output);
  }

  // optional bool probing = 36;
  if (has_probing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(36, this->probing(), output);
  }

  // optional int32 queue = 37;
  if (has_queue()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(37, this->queue(), output);
  }

  // optional bool queue_full = 38;
  if (has_queue_full()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->queue_full(), output);
  }

  // optional double rotation_xy = 39;
  if (has_rotation_xy()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(39, this->rotation_xy(), output);
  }

  // optional bool spindle_brake = 40;
  if (has_spindle_brake()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(40, this->spindle_brake(), output);
  }

  // optional int32 spindle_direction = 41;
  if (has_spindle_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(41, this->spindle_direction(), output);
  }

  // optional bool spindle_enabled = 42;
  if (has_spindle_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(42, this->spindle_enabled(), output);
  }

  // optional int32 spindle_increasing = 43;
  if (has_spindle_increasing()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(43, this->spindle_increasing(), output);
  }

  // optional bool spindle_override_enabled = 44;
  if (has_spindle_override_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(44, this->spindle_override_enabled(), output);
  }

  // optional double spindle_speed = 45;
  if (has_spindle_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(45, this->spindle_speed(), output);
  }

  // optional double spindlerate = 46;
  if (has_spindlerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(46, this->spindlerate(), output);
  }

  // optional .pb.RCS_STATUS state = 47;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      47, this->state(), output);
  }

  // optional double max_velocity = 48;
  if (has_max_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(48, this->max_velocity(), output);
  }

  // optional double max_acceleration = 49;
  if (has_max_acceleration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(49, this->max_acceleration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusMotion)
}

::google::protobuf::uint8* EmcStatusMotion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusMotion)
  // optional int32 active_queue = 1;
  if (has_active_queue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->active_queue(), target);
  }

  // optional .pb.Position actual_position = 2;
  if (has_actual_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->actual_position(), target);
  }

  // optional bool adaptive_feed_enabled = 3;
  if (has_adaptive_feed_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->adaptive_feed_enabled(), target);
  }

  // repeated .pb.EmcStatusAnalogIO ain = 4;
  for (int i = 0; i < this->ain_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->ain(i), target);
  }

  // repeated .pb.EmcStatusAnalogIO aout = 5;
  for (int i = 0; i < this->aout_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->aout(i), target);
  }

  // repeated .pb.EmcStatusMotionAxis axis = 6;
  for (int i = 0; i < this->axis_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->axis(i), target);
  }

  // optional bool block_delete = 7;
  if (has_block_delete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->block_delete(), target);
  }

  // optional int32 current_line = 8;
  if (has_current_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->current_line(), target);
  }

  // optional double current_vel = 9;
  if (has_current_vel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->current_vel(), target);
  }

  // optional double delay_left = 10;
  if (has_delay_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(10, this->delay_left(), target);
  }

  // repeated .pb.EmcStatusDigitalIO din = 11;
  for (int i = 0; i < this->din_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->din(i), target);
  }

  // optional double distance_to_go = 12;
  if (has_distance_to_go()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(12, this->distance_to_go(), target);
  }

  // repeated .pb.EmcStatusDigitalIO dout = 13;
  for (int i = 0; i < this->dout_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->dout(i), target);
  }

  // optional .pb.Position dtg = 14;
  if (has_dtg()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->dtg(), target);
  }

  // optional bool enabled = 15;
  if (has_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->enabled(), target);
  }

  // optional bool feed_hold_enabled = 16;
  if (has_feed_hold_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->feed_hold_enabled(), target);
  }

  // optional bool feed_override_enabled = 17;
  if (has_feed_override_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->feed_override_enabled(), target);
  }

  // optional double feedrate = 18;
  if (has_feedrate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(18, this->feedrate(), target);
  }

  // optional .pb.OriginIndex g5x_index = 19;
  if (has_g5x_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      19, this->g5x_index(), target);
  }

  // optional .pb.Position g5x_offset = 20;
  if (has_g5x_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->g5x_offset(), target);
  }

  // optional .pb.Position g92_offset = 21;
  if (has_g92_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->g92_offset(), target);
  }

  // optional int32 id = 23;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(23, this->id(), target);
  }

  // optional bool inpos = 24;
  if (has_inpos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(24, this->inpos(), target);
  }

  // optional .pb.Position joint_actual_position = 25;
  if (has_joint_actual_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        25, this->joint_actual_position(), target);
  }

  // optional .pb.Position joint_position = 26;
  if (has_joint_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        26, this->joint_position(), target);
  }

  // repeated .pb.EmcStatusLimit limit = 27;
  for (int i = 0; i < this->limit_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        27, this->limit(i), target);
  }

  // optional int32 motion_line = 28;
  if (has_motion_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(28, this->motion_line(), target);
  }

  // optional .pb.MotionType motion_type = 29;
  if (has_motion_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      29, this->motion_type(), target);
  }

  // optional .pb.EmcTrajectoryModeType motion_mode = 30;
  if (has_motion_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      30, this->motion_mode(), target);
  }

  // optional bool paused = 31;
  if (has_paused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(31, this->paused(), target);
  }

  // optional .pb.Position position = 32;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, this->position(), target);
  }

  // optional bool probe_tripped = 33;
  if (has_probe_tripped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(33, this->probe_tripped(), target);
  }

  // optional int32 probe_val = 34;
  if (has_probe_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(34, this->probe_val(), target);
  }

  // optional .pb.Position probed_position = 35;
  if (has_probed_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        35, this->probed_position(), target);
  }

  // optional bool probing = 36;
  if (has_probing()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(36, this->probing(), target);
  }

  // optional int32 queue = 37;
  if (has_queue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(37, this->queue(), target);
  }

  // optional bool queue_full = 38;
  if (has_queue_full()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(38, this->queue_full(), target);
  }

  // optional double rotation_xy = 39;
  if (has_rotation_xy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(39, this->rotation_xy(), target);
  }

  // optional bool spindle_brake = 40;
  if (has_spindle_brake()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(40, this->spindle_brake(), target);
  }

  // optional int32 spindle_direction = 41;
  if (has_spindle_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(41, this->spindle_direction(), target);
  }

  // optional bool spindle_enabled = 42;
  if (has_spindle_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(42, this->spindle_enabled(), target);
  }

  // optional int32 spindle_increasing = 43;
  if (has_spindle_increasing()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(43, this->spindle_increasing(), target);
  }

  // optional bool spindle_override_enabled = 44;
  if (has_spindle_override_enabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(44, this->spindle_override_enabled(), target);
  }

  // optional double spindle_speed = 45;
  if (has_spindle_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(45, this->spindle_speed(), target);
  }

  // optional double spindlerate = 46;
  if (has_spindlerate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(46, this->spindlerate(), target);
  }

  // optional .pb.RCS_STATUS state = 47;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      47, this->state(), target);
  }

  // optional double max_velocity = 48;
  if (has_max_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(48, this->max_velocity(), target);
  }

  // optional double max_acceleration = 49;
  if (has_max_acceleration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(49, this->max_acceleration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusMotion)
  return target;
}

int EmcStatusMotion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 active_queue = 1;
    if (has_active_queue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->active_queue());
    }

    // optional .pb.Position actual_position = 2;
    if (has_actual_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->actual_position());
    }

    // optional bool adaptive_feed_enabled = 3;
    if (has_adaptive_feed_enabled()) {
      total_size += 1 + 1;
    }

    // optional bool block_delete = 7;
    if (has_block_delete()) {
      total_size += 1 + 1;
    }

    // optional int32 current_line = 8;
    if (has_current_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current_line());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional double current_vel = 9;
    if (has_current_vel()) {
      total_size += 1 + 8;
    }

    // optional double delay_left = 10;
    if (has_delay_left()) {
      total_size += 1 + 8;
    }

    // optional double distance_to_go = 12;
    if (has_distance_to_go()) {
      total_size += 1 + 8;
    }

    // optional .pb.Position dtg = 14;
    if (has_dtg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dtg());
    }

    // optional bool enabled = 15;
    if (has_enabled()) {
      total_size += 1 + 1;
    }

    // optional bool feed_hold_enabled = 16;
    if (has_feed_hold_enabled()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool feed_override_enabled = 17;
    if (has_feed_override_enabled()) {
      total_size += 2 + 1;
    }

    // optional double feedrate = 18;
    if (has_feedrate()) {
      total_size += 2 + 8;
    }

    // optional .pb.OriginIndex g5x_index = 19;
    if (has_g5x_index()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->g5x_index());
    }

    // optional .pb.Position g5x_offset = 20;
    if (has_g5x_offset()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->g5x_offset());
    }

    // optional .pb.Position g92_offset = 21;
    if (has_g92_offset()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->g92_offset());
    }

    // optional int32 id = 23;
    if (has_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional bool inpos = 24;
    if (has_inpos()) {
      total_size += 2 + 1;
    }

    // optional .pb.Position joint_actual_position = 25;
    if (has_joint_actual_position()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joint_actual_position());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional .pb.Position joint_position = 26;
    if (has_joint_position()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->joint_position());
    }

    // optional int32 motion_line = 28;
    if (has_motion_line()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->motion_line());
    }

    // optional .pb.MotionType motion_type = 29;
    if (has_motion_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motion_type());
    }

    // optional .pb.EmcTrajectoryModeType motion_mode = 30;
    if (has_motion_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->motion_mode());
    }

    // optional bool paused = 31;
    if (has_paused()) {
      total_size += 2 + 1;
    }

    // optional .pb.Position position = 32;
    if (has_position()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // optional bool probe_tripped = 33;
    if (has_probe_tripped()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional int32 probe_val = 34;
    if (has_probe_val()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->probe_val());
    }

    // optional .pb.Position probed_position = 35;
    if (has_probed_position()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->probed_position());
    }

    // optional bool probing = 36;
    if (has_probing()) {
      total_size += 2 + 1;
    }

    // optional int32 queue = 37;
    if (has_queue()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->queue());
    }

    // optional bool queue_full = 38;
    if (has_queue_full()) {
      total_size += 2 + 1;
    }

    // optional double rotation_xy = 39;
    if (has_rotation_xy()) {
      total_size += 2 + 8;
    }

    // optional bool spindle_brake = 40;
    if (has_spindle_brake()) {
      total_size += 2 + 1;
    }

    // optional int32 spindle_direction = 41;
    if (has_spindle_direction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->spindle_direction());
    }

  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional bool spindle_enabled = 42;
    if (has_spindle_enabled()) {
      total_size += 2 + 1;
    }

    // optional int32 spindle_increasing = 43;
    if (has_spindle_increasing()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->spindle_increasing());
    }

    // optional bool spindle_override_enabled = 44;
    if (has_spindle_override_enabled()) {
      total_size += 2 + 1;
    }

    // optional double spindle_speed = 45;
    if (has_spindle_speed()) {
      total_size += 2 + 8;
    }

    // optional double spindlerate = 46;
    if (has_spindlerate()) {
      total_size += 2 + 8;
    }

    // optional .pb.RCS_STATUS state = 47;
    if (has_state()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional double max_velocity = 48;
    if (has_max_velocity()) {
      total_size += 2 + 8;
    }

    // optional double max_acceleration = 49;
    if (has_max_acceleration()) {
      total_size += 2 + 8;
    }

  }
  // repeated .pb.EmcStatusAnalogIO ain = 4;
  total_size += 1 * this->ain_size();
  for (int i = 0; i < this->ain_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ain(i));
  }

  // repeated .pb.EmcStatusAnalogIO aout = 5;
  total_size += 1 * this->aout_size();
  for (int i = 0; i < this->aout_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->aout(i));
  }

  // repeated .pb.EmcStatusMotionAxis axis = 6;
  total_size += 1 * this->axis_size();
  for (int i = 0; i < this->axis_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->axis(i));
  }

  // repeated .pb.EmcStatusDigitalIO din = 11;
  total_size += 1 * this->din_size();
  for (int i = 0; i < this->din_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->din(i));
  }

  // repeated .pb.EmcStatusDigitalIO dout = 13;
  total_size += 1 * this->dout_size();
  for (int i = 0; i < this->dout_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->dout(i));
  }

  // repeated .pb.EmcStatusLimit limit = 27;
  total_size += 2 * this->limit_size();
  for (int i = 0; i < this->limit_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->limit(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusMotion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusMotion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusMotion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusMotion::MergeFrom(const EmcStatusMotion& from) {
  GOOGLE_CHECK_NE(&from, this);
  ain_.MergeFrom(from.ain_);
  aout_.MergeFrom(from.aout_);
  axis_.MergeFrom(from.axis_);
  din_.MergeFrom(from.din_);
  dout_.MergeFrom(from.dout_);
  limit_.MergeFrom(from.limit_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active_queue()) {
      set_active_queue(from.active_queue());
    }
    if (from.has_actual_position()) {
      mutable_actual_position()->::pb::Position::MergeFrom(from.actual_position());
    }
    if (from.has_adaptive_feed_enabled()) {
      set_adaptive_feed_enabled(from.adaptive_feed_enabled());
    }
    if (from.has_block_delete()) {
      set_block_delete(from.block_delete());
    }
    if (from.has_current_line()) {
      set_current_line(from.current_line());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_current_vel()) {
      set_current_vel(from.current_vel());
    }
    if (from.has_delay_left()) {
      set_delay_left(from.delay_left());
    }
    if (from.has_distance_to_go()) {
      set_distance_to_go(from.distance_to_go());
    }
    if (from.has_dtg()) {
      mutable_dtg()->::pb::Position::MergeFrom(from.dtg());
    }
    if (from.has_enabled()) {
      set_enabled(from.enabled());
    }
    if (from.has_feed_hold_enabled()) {
      set_feed_hold_enabled(from.feed_hold_enabled());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_feed_override_enabled()) {
      set_feed_override_enabled(from.feed_override_enabled());
    }
    if (from.has_feedrate()) {
      set_feedrate(from.feedrate());
    }
    if (from.has_g5x_index()) {
      set_g5x_index(from.g5x_index());
    }
    if (from.has_g5x_offset()) {
      mutable_g5x_offset()->::pb::Position::MergeFrom(from.g5x_offset());
    }
    if (from.has_g92_offset()) {
      mutable_g92_offset()->::pb::Position::MergeFrom(from.g92_offset());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_inpos()) {
      set_inpos(from.inpos());
    }
    if (from.has_joint_actual_position()) {
      mutable_joint_actual_position()->::pb::Position::MergeFrom(from.joint_actual_position());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_joint_position()) {
      mutable_joint_position()->::pb::Position::MergeFrom(from.joint_position());
    }
    if (from.has_motion_line()) {
      set_motion_line(from.motion_line());
    }
    if (from.has_motion_type()) {
      set_motion_type(from.motion_type());
    }
    if (from.has_motion_mode()) {
      set_motion_mode(from.motion_mode());
    }
    if (from.has_paused()) {
      set_paused(from.paused());
    }
    if (from.has_position()) {
      mutable_position()->::pb::Position::MergeFrom(from.position());
    }
    if (from.has_probe_tripped()) {
      set_probe_tripped(from.probe_tripped());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_probe_val()) {
      set_probe_val(from.probe_val());
    }
    if (from.has_probed_position()) {
      mutable_probed_position()->::pb::Position::MergeFrom(from.probed_position());
    }
    if (from.has_probing()) {
      set_probing(from.probing());
    }
    if (from.has_queue()) {
      set_queue(from.queue());
    }
    if (from.has_queue_full()) {
      set_queue_full(from.queue_full());
    }
    if (from.has_rotation_xy()) {
      set_rotation_xy(from.rotation_xy());
    }
    if (from.has_spindle_brake()) {
      set_spindle_brake(from.spindle_brake());
    }
    if (from.has_spindle_direction()) {
      set_spindle_direction(from.spindle_direction());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_spindle_enabled()) {
      set_spindle_enabled(from.spindle_enabled());
    }
    if (from.has_spindle_increasing()) {
      set_spindle_increasing(from.spindle_increasing());
    }
    if (from.has_spindle_override_enabled()) {
      set_spindle_override_enabled(from.spindle_override_enabled());
    }
    if (from.has_spindle_speed()) {
      set_spindle_speed(from.spindle_speed());
    }
    if (from.has_spindlerate()) {
      set_spindlerate(from.spindlerate());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_max_velocity()) {
      set_max_velocity(from.max_velocity());
    }
    if (from.has_max_acceleration()) {
      set_max_acceleration(from.max_acceleration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusMotion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusMotion::CopyFrom(const EmcStatusMotion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusMotion::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ain())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->aout())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->axis())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->din())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->dout())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->limit())) return false;
  return true;
}

void EmcStatusMotion::Swap(EmcStatusMotion* other) {
  if (other != this) {
    std::swap(active_queue_, other->active_queue_);
    std::swap(actual_position_, other->actual_position_);
    std::swap(adaptive_feed_enabled_, other->adaptive_feed_enabled_);
    ain_.Swap(&other->ain_);
    aout_.Swap(&other->aout_);
    axis_.Swap(&other->axis_);
    std::swap(block_delete_, other->block_delete_);
    std::swap(current_line_, other->current_line_);
    std::swap(current_vel_, other->current_vel_);
    std::swap(delay_left_, other->delay_left_);
    din_.Swap(&other->din_);
    std::swap(distance_to_go_, other->distance_to_go_);
    dout_.Swap(&other->dout_);
    std::swap(dtg_, other->dtg_);
    std::swap(enabled_, other->enabled_);
    std::swap(feed_hold_enabled_, other->feed_hold_enabled_);
    std::swap(feed_override_enabled_, other->feed_override_enabled_);
    std::swap(feedrate_, other->feedrate_);
    std::swap(g5x_index_, other->g5x_index_);
    std::swap(g5x_offset_, other->g5x_offset_);
    std::swap(g92_offset_, other->g92_offset_);
    std::swap(id_, other->id_);
    std::swap(inpos_, other->inpos_);
    std::swap(joint_actual_position_, other->joint_actual_position_);
    std::swap(joint_position_, other->joint_position_);
    limit_.Swap(&other->limit_);
    std::swap(motion_line_, other->motion_line_);
    std::swap(motion_type_, other->motion_type_);
    std::swap(motion_mode_, other->motion_mode_);
    std::swap(paused_, other->paused_);
    std::swap(position_, other->position_);
    std::swap(probe_tripped_, other->probe_tripped_);
    std::swap(probe_val_, other->probe_val_);
    std::swap(probed_position_, other->probed_position_);
    std::swap(probing_, other->probing_);
    std::swap(queue_, other->queue_);
    std::swap(queue_full_, other->queue_full_);
    std::swap(rotation_xy_, other->rotation_xy_);
    std::swap(spindle_brake_, other->spindle_brake_);
    std::swap(spindle_direction_, other->spindle_direction_);
    std::swap(spindle_enabled_, other->spindle_enabled_);
    std::swap(spindle_increasing_, other->spindle_increasing_);
    std::swap(spindle_override_enabled_, other->spindle_override_enabled_);
    std::swap(spindle_speed_, other->spindle_speed_);
    std::swap(spindlerate_, other->spindlerate_);
    std::swap(state_, other->state_);
    std::swap(max_velocity_, other->max_velocity_);
    std::swap(max_acceleration_, other->max_acceleration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusMotion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusMotion_descriptor_;
  metadata.reflection = EmcStatusMotion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusIo::kEstopFieldNumber;
const int EmcStatusIo::kFloodFieldNumber;
const int EmcStatusIo::kLubeFieldNumber;
const int EmcStatusIo::kLubeLevelFieldNumber;
const int EmcStatusIo::kMistFieldNumber;
const int EmcStatusIo::kPocketPreppedFieldNumber;
const int EmcStatusIo::kToolInSpindleFieldNumber;
const int EmcStatusIo::kToolOffsetFieldNumber;
const int EmcStatusIo::kToolTableFieldNumber;
#endif  // !_MSC_VER

EmcStatusIo::EmcStatusIo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusIo)
}

void EmcStatusIo::InitAsDefaultInstance() {
  tool_offset_ = const_cast< ::pb::Position*>(&::pb::Position::default_instance());
}

EmcStatusIo::EmcStatusIo(const EmcStatusIo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusIo)
}

void EmcStatusIo::SharedCtor() {
  _cached_size_ = 0;
  estop_ = false;
  flood_ = false;
  lube_ = false;
  lube_level_ = false;
  mist_ = false;
  pocket_prepped_ = false;
  tool_in_spindle_ = false;
  tool_offset_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusIo::~EmcStatusIo() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusIo)
  SharedDtor();
}

void EmcStatusIo::SharedDtor() {
  if (this != default_instance_) {
    delete tool_offset_;
  }
}

void EmcStatusIo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusIo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusIo_descriptor_;
}

const EmcStatusIo& EmcStatusIo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusIo* EmcStatusIo::default_instance_ = NULL;

EmcStatusIo* EmcStatusIo::New() const {
  return new EmcStatusIo;
}

void EmcStatusIo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusIo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(estop_, tool_in_spindle_);
    if (has_tool_offset()) {
      if (tool_offset_ != NULL) tool_offset_->::pb::Position::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  tool_table_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusIo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusIo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool estop = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &estop_)));
          set_has_estop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_flood;
        break;
      }

      // optional bool flood = 2;
      case 2: {
        if (tag == 16) {
         parse_flood:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flood_)));
          set_has_flood();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_lube;
        break;
      }

      // optional bool lube = 3;
      case 3: {
        if (tag == 24) {
         parse_lube:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lube_)));
          set_has_lube();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_lube_level;
        break;
      }

      // optional bool lube_level = 4;
      case 4: {
        if (tag == 32) {
         parse_lube_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lube_level_)));
          set_has_lube_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mist;
        break;
      }

      // optional bool mist = 5;
      case 5: {
        if (tag == 40) {
         parse_mist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mist_)));
          set_has_mist();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_pocket_prepped;
        break;
      }

      // optional bool pocket_prepped = 6;
      case 6: {
        if (tag == 48) {
         parse_pocket_prepped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pocket_prepped_)));
          set_has_pocket_prepped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tool_in_spindle;
        break;
      }

      // optional bool tool_in_spindle = 7;
      case 7: {
        if (tag == 56) {
         parse_tool_in_spindle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &tool_in_spindle_)));
          set_has_tool_in_spindle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_tool_offset;
        break;
      }

      // optional .pb.Position tool_offset = 8;
      case 8: {
        if (tag == 66) {
         parse_tool_offset:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tool_offset()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_tool_table;
        break;
      }

      // repeated .pb.EmcToolData tool_table = 9;
      case 9: {
        if (tag == 74) {
         parse_tool_table:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tool_table()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_tool_table;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusIo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusIo)
  return false;
#undef DO_
}

void EmcStatusIo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusIo)
  // optional bool estop = 1;
  if (has_estop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->estop(), output);
  }

  // optional bool flood = 2;
  if (has_flood()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->flood(), output);
  }

  // optional bool lube = 3;
  if (has_lube()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->lube(), output);
  }

  // optional bool lube_level = 4;
  if (has_lube_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->lube_level(), output);
  }

  // optional bool mist = 5;
  if (has_mist()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->mist(), output);
  }

  // optional bool pocket_prepped = 6;
  if (has_pocket_prepped()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->pocket_prepped(), output);
  }

  // optional bool tool_in_spindle = 7;
  if (has_tool_in_spindle()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->tool_in_spindle(), output);
  }

  // optional .pb.Position tool_offset = 8;
  if (has_tool_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->tool_offset(), output);
  }

  // repeated .pb.EmcToolData tool_table = 9;
  for (int i = 0; i < this->tool_table_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->tool_table(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusIo)
}

::google::protobuf::uint8* EmcStatusIo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusIo)
  // optional bool estop = 1;
  if (has_estop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->estop(), target);
  }

  // optional bool flood = 2;
  if (has_flood()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->flood(), target);
  }

  // optional bool lube = 3;
  if (has_lube()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->lube(), target);
  }

  // optional bool lube_level = 4;
  if (has_lube_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->lube_level(), target);
  }

  // optional bool mist = 5;
  if (has_mist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->mist(), target);
  }

  // optional bool pocket_prepped = 6;
  if (has_pocket_prepped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->pocket_prepped(), target);
  }

  // optional bool tool_in_spindle = 7;
  if (has_tool_in_spindle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->tool_in_spindle(), target);
  }

  // optional .pb.Position tool_offset = 8;
  if (has_tool_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->tool_offset(), target);
  }

  // repeated .pb.EmcToolData tool_table = 9;
  for (int i = 0; i < this->tool_table_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->tool_table(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusIo)
  return target;
}

int EmcStatusIo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool estop = 1;
    if (has_estop()) {
      total_size += 1 + 1;
    }

    // optional bool flood = 2;
    if (has_flood()) {
      total_size += 1 + 1;
    }

    // optional bool lube = 3;
    if (has_lube()) {
      total_size += 1 + 1;
    }

    // optional bool lube_level = 4;
    if (has_lube_level()) {
      total_size += 1 + 1;
    }

    // optional bool mist = 5;
    if (has_mist()) {
      total_size += 1 + 1;
    }

    // optional bool pocket_prepped = 6;
    if (has_pocket_prepped()) {
      total_size += 1 + 1;
    }

    // optional bool tool_in_spindle = 7;
    if (has_tool_in_spindle()) {
      total_size += 1 + 1;
    }

    // optional .pb.Position tool_offset = 8;
    if (has_tool_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tool_offset());
    }

  }
  // repeated .pb.EmcToolData tool_table = 9;
  total_size += 1 * this->tool_table_size();
  for (int i = 0; i < this->tool_table_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tool_table(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusIo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusIo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusIo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusIo::MergeFrom(const EmcStatusIo& from) {
  GOOGLE_CHECK_NE(&from, this);
  tool_table_.MergeFrom(from.tool_table_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_estop()) {
      set_estop(from.estop());
    }
    if (from.has_flood()) {
      set_flood(from.flood());
    }
    if (from.has_lube()) {
      set_lube(from.lube());
    }
    if (from.has_lube_level()) {
      set_lube_level(from.lube_level());
    }
    if (from.has_mist()) {
      set_mist(from.mist());
    }
    if (from.has_pocket_prepped()) {
      set_pocket_prepped(from.pocket_prepped());
    }
    if (from.has_tool_in_spindle()) {
      set_tool_in_spindle(from.tool_in_spindle());
    }
    if (from.has_tool_offset()) {
      mutable_tool_offset()->::pb::Position::MergeFrom(from.tool_offset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusIo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusIo::CopyFrom(const EmcStatusIo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusIo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->tool_table())) return false;
  return true;
}

void EmcStatusIo::Swap(EmcStatusIo* other) {
  if (other != this) {
    std::swap(estop_, other->estop_);
    std::swap(flood_, other->flood_);
    std::swap(lube_, other->lube_);
    std::swap(lube_level_, other->lube_level_);
    std::swap(mist_, other->mist_);
    std::swap(pocket_prepped_, other->pocket_prepped_);
    std::swap(tool_in_spindle_, other->tool_in_spindle_);
    std::swap(tool_offset_, other->tool_offset_);
    tool_table_.Swap(&other->tool_table_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusIo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusIo_descriptor_;
  metadata.reflection = EmcStatusIo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusTask::kEchoSerialNumberFieldNumber;
const int EmcStatusTask::kExecStateFieldNumber;
const int EmcStatusTask::kFileFieldNumber;
const int EmcStatusTask::kInputTimeoutFieldNumber;
const int EmcStatusTask::kOptionalStopFieldNumber;
const int EmcStatusTask::kReadLineFieldNumber;
const int EmcStatusTask::kTaskModeFieldNumber;
const int EmcStatusTask::kTaskPausedFieldNumber;
const int EmcStatusTask::kTaskStateFieldNumber;
const int EmcStatusTask::kTotalLinesFieldNumber;
#endif  // !_MSC_VER

EmcStatusTask::EmcStatusTask()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusTask)
}

void EmcStatusTask::InitAsDefaultInstance() {
}

EmcStatusTask::EmcStatusTask(const EmcStatusTask& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusTask)
}

void EmcStatusTask::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  echo_serial_number_ = 0;
  exec_state_ = 1;
  file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  input_timeout_ = false;
  optional_stop_ = false;
  read_line_ = 0;
  task_mode_ = 1;
  task_paused_ = 0;
  task_state_ = 1;
  total_lines_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusTask::~EmcStatusTask() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusTask)
  SharedDtor();
}

void EmcStatusTask::SharedDtor() {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (this != default_instance_) {
  }
}

void EmcStatusTask::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusTask::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusTask_descriptor_;
}

const EmcStatusTask& EmcStatusTask::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusTask* EmcStatusTask::default_instance_ = NULL;

EmcStatusTask* EmcStatusTask::New() const {
  return new EmcStatusTask;
}

void EmcStatusTask::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcStatusTask*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(input_timeout_, read_line_);
    echo_serial_number_ = 0;
    exec_state_ = 1;
    if (has_file()) {
      if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_->clear();
      }
    }
    task_mode_ = 1;
    task_paused_ = 0;
  }
  if (_has_bits_[8 / 32] & 768) {
    task_state_ = 1;
    total_lines_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusTask::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusTask)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 echo_serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &echo_serial_number_)));
          set_has_echo_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_exec_state;
        break;
      }

      // optional .pb.EmcTaskExecStateType exec_state = 2;
      case 2: {
        if (tag == 16) {
         parse_exec_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTaskExecStateType_IsValid(value)) {
            set_exec_state(static_cast< ::pb::EmcTaskExecStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_file;
        break;
      }

      // optional string file = 3;
      case 3: {
        if (tag == 26) {
         parse_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->file().data(), this->file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "file");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_input_timeout;
        break;
      }

      // optional bool input_timeout = 4;
      case 4: {
        if (tag == 32) {
         parse_input_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &input_timeout_)));
          set_has_input_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_optional_stop;
        break;
      }

      // optional bool optional_stop = 5;
      case 5: {
        if (tag == 40) {
         parse_optional_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &optional_stop_)));
          set_has_optional_stop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_read_line;
        break;
      }

      // optional int32 read_line = 6;
      case 6: {
        if (tag == 48) {
         parse_read_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &read_line_)));
          set_has_read_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_task_mode;
        break;
      }

      // optional .pb.EmcTaskModeType task_mode = 7;
      case 7: {
        if (tag == 56) {
         parse_task_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTaskModeType_IsValid(value)) {
            set_task_mode(static_cast< ::pb::EmcTaskModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_task_paused;
        break;
      }

      // optional int32 task_paused = 8;
      case 8: {
        if (tag == 64) {
         parse_task_paused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &task_paused_)));
          set_has_task_paused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_task_state;
        break;
      }

      // optional .pb.EmcTaskStateType task_state = 9;
      case 9: {
        if (tag == 72) {
         parse_task_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTaskStateType_IsValid(value)) {
            set_task_state(static_cast< ::pb::EmcTaskStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_total_lines;
        break;
      }

      // optional int32 total_lines = 10;
      case 10: {
        if (tag == 80) {
         parse_total_lines:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_lines_)));
          set_has_total_lines();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusTask)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusTask)
  return false;
#undef DO_
}

void EmcStatusTask::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusTask)
  // optional int32 echo_serial_number = 1;
  if (has_echo_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->echo_serial_number(), output);
  }

  // optional .pb.EmcTaskExecStateType exec_state = 2;
  if (has_exec_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->exec_state(), output);
  }

  // optional string file = 3;
  if (has_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file().data(), this->file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->file(), output);
  }

  // optional bool input_timeout = 4;
  if (has_input_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->input_timeout(), output);
  }

  // optional bool optional_stop = 5;
  if (has_optional_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->optional_stop(), output);
  }

  // optional int32 read_line = 6;
  if (has_read_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->read_line(), output);
  }

  // optional .pb.EmcTaskModeType task_mode = 7;
  if (has_task_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->task_mode(), output);
  }

  // optional int32 task_paused = 8;
  if (has_task_paused()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->task_paused(), output);
  }

  // optional .pb.EmcTaskStateType task_state = 9;
  if (has_task_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->task_state(), output);
  }

  // optional int32 total_lines = 10;
  if (has_total_lines()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->total_lines(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusTask)
}

::google::protobuf::uint8* EmcStatusTask::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusTask)
  // optional int32 echo_serial_number = 1;
  if (has_echo_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->echo_serial_number(), target);
  }

  // optional .pb.EmcTaskExecStateType exec_state = 2;
  if (has_exec_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->exec_state(), target);
  }

  // optional string file = 3;
  if (has_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->file().data(), this->file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->file(), target);
  }

  // optional bool input_timeout = 4;
  if (has_input_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->input_timeout(), target);
  }

  // optional bool optional_stop = 5;
  if (has_optional_stop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->optional_stop(), target);
  }

  // optional int32 read_line = 6;
  if (has_read_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->read_line(), target);
  }

  // optional .pb.EmcTaskModeType task_mode = 7;
  if (has_task_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->task_mode(), target);
  }

  // optional int32 task_paused = 8;
  if (has_task_paused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->task_paused(), target);
  }

  // optional .pb.EmcTaskStateType task_state = 9;
  if (has_task_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->task_state(), target);
  }

  // optional int32 total_lines = 10;
  if (has_total_lines()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->total_lines(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusTask)
  return target;
}

int EmcStatusTask::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 echo_serial_number = 1;
    if (has_echo_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->echo_serial_number());
    }

    // optional .pb.EmcTaskExecStateType exec_state = 2;
    if (has_exec_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->exec_state());
    }

    // optional string file = 3;
    if (has_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file());
    }

    // optional bool input_timeout = 4;
    if (has_input_timeout()) {
      total_size += 1 + 1;
    }

    // optional bool optional_stop = 5;
    if (has_optional_stop()) {
      total_size += 1 + 1;
    }

    // optional int32 read_line = 6;
    if (has_read_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->read_line());
    }

    // optional .pb.EmcTaskModeType task_mode = 7;
    if (has_task_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->task_mode());
    }

    // optional int32 task_paused = 8;
    if (has_task_paused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->task_paused());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .pb.EmcTaskStateType task_state = 9;
    if (has_task_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->task_state());
    }

    // optional int32 total_lines = 10;
    if (has_total_lines()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_lines());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusTask::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusTask* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusTask*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusTask::MergeFrom(const EmcStatusTask& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_echo_serial_number()) {
      set_echo_serial_number(from.echo_serial_number());
    }
    if (from.has_exec_state()) {
      set_exec_state(from.exec_state());
    }
    if (from.has_file()) {
      set_file(from.file());
    }
    if (from.has_input_timeout()) {
      set_input_timeout(from.input_timeout());
    }
    if (from.has_optional_stop()) {
      set_optional_stop(from.optional_stop());
    }
    if (from.has_read_line()) {
      set_read_line(from.read_line());
    }
    if (from.has_task_mode()) {
      set_task_mode(from.task_mode());
    }
    if (from.has_task_paused()) {
      set_task_paused(from.task_paused());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_task_state()) {
      set_task_state(from.task_state());
    }
    if (from.has_total_lines()) {
      set_total_lines(from.total_lines());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusTask::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusTask::CopyFrom(const EmcStatusTask& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusTask::IsInitialized() const {

  return true;
}

void EmcStatusTask::Swap(EmcStatusTask* other) {
  if (other != this) {
    std::swap(echo_serial_number_, other->echo_serial_number_);
    std::swap(exec_state_, other->exec_state_);
    std::swap(file_, other->file_);
    std::swap(input_timeout_, other->input_timeout_);
    std::swap(optional_stop_, other->optional_stop_);
    std::swap(read_line_, other->read_line_);
    std::swap(task_mode_, other->task_mode_);
    std::swap(task_paused_, other->task_paused_);
    std::swap(task_state_, other->task_state_);
    std::swap(total_lines_, other->total_lines_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusTask::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusTask_descriptor_;
  metadata.reflection = EmcStatusTask_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusInterp::kCommandFieldNumber;
const int EmcStatusInterp::kGcodesFieldNumber;
const int EmcStatusInterp::kInterpStateFieldNumber;
const int EmcStatusInterp::kInterpreterErrcodeFieldNumber;
const int EmcStatusInterp::kMcodesFieldNumber;
const int EmcStatusInterp::kSettingsFieldNumber;
#endif  // !_MSC_VER

EmcStatusInterp::EmcStatusInterp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusInterp)
}

void EmcStatusInterp::InitAsDefaultInstance() {
}

EmcStatusInterp::EmcStatusInterp(const EmcStatusInterp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusInterp)
}

void EmcStatusInterp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  interp_state_ = 1;
  interpreter_errcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusInterp::~EmcStatusInterp() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusInterp)
  SharedDtor();
}

void EmcStatusInterp::SharedDtor() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (this != default_instance_) {
  }
}

void EmcStatusInterp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusInterp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusInterp_descriptor_;
}

const EmcStatusInterp& EmcStatusInterp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusInterp* EmcStatusInterp::default_instance_ = NULL;

EmcStatusInterp* EmcStatusInterp::New() const {
  return new EmcStatusInterp;
}

void EmcStatusInterp::Clear() {
  if (_has_bits_[0 / 32] & 13) {
    if (has_command()) {
      if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        command_->clear();
      }
    }
    interp_state_ = 1;
    interpreter_errcode_ = 0;
  }
  gcodes_.Clear();
  mcodes_.Clear();
  settings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusInterp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusInterp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string command = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_command()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->command().data(), this->command().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "command");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gcodes;
        break;
      }

      // repeated .pb.EmcStatusGCode gcodes = 2;
      case 2: {
        if (tag == 18) {
         parse_gcodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gcodes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gcodes;
        if (input->ExpectTag(24)) goto parse_interp_state;
        break;
      }

      // optional .pb.EmcInterpStateType interp_state = 3;
      case 3: {
        if (tag == 24) {
         parse_interp_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcInterpStateType_IsValid(value)) {
            set_interp_state(static_cast< ::pb::EmcInterpStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_interpreter_errcode;
        break;
      }

      // optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
      case 4: {
        if (tag == 32) {
         parse_interpreter_errcode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcInterpExitCodeType_IsValid(value)) {
            set_interpreter_errcode(static_cast< ::pb::EmcInterpExitCodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mcodes;
        break;
      }

      // repeated .pb.EmcStatusMCode mcodes = 5;
      case 5: {
        if (tag == 42) {
         parse_mcodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mcodes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mcodes;
        if (input->ExpectTag(50)) goto parse_settings;
        break;
      }

      // repeated .pb.EmcStatusSetting settings = 6;
      case 6: {
        if (tag == 50) {
         parse_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_settings;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusInterp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusInterp)
  return false;
#undef DO_
}

void EmcStatusInterp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusInterp)
  // optional string command = 1;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->command(), output);
  }

  // repeated .pb.EmcStatusGCode gcodes = 2;
  for (int i = 0; i < this->gcodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gcodes(i), output);
  }

  // optional .pb.EmcInterpStateType interp_state = 3;
  if (has_interp_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->interp_state(), output);
  }

  // optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
  if (has_interpreter_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->interpreter_errcode(), output);
  }

  // repeated .pb.EmcStatusMCode mcodes = 5;
  for (int i = 0; i < this->mcodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->mcodes(i), output);
  }

  // repeated .pb.EmcStatusSetting settings = 6;
  for (int i = 0; i < this->settings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->settings(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusInterp)
}

::google::protobuf::uint8* EmcStatusInterp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusInterp)
  // optional string command = 1;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->command(), target);
  }

  // repeated .pb.EmcStatusGCode gcodes = 2;
  for (int i = 0; i < this->gcodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gcodes(i), target);
  }

  // optional .pb.EmcInterpStateType interp_state = 3;
  if (has_interp_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->interp_state(), target);
  }

  // optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
  if (has_interpreter_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->interpreter_errcode(), target);
  }

  // repeated .pb.EmcStatusMCode mcodes = 5;
  for (int i = 0; i < this->mcodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->mcodes(i), target);
  }

  // repeated .pb.EmcStatusSetting settings = 6;
  for (int i = 0; i < this->settings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->settings(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusInterp)
  return target;
}

int EmcStatusInterp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string command = 1;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->command());
    }

    // optional .pb.EmcInterpStateType interp_state = 3;
    if (has_interp_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->interp_state());
    }

    // optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
    if (has_interpreter_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->interpreter_errcode());
    }

  }
  // repeated .pb.EmcStatusGCode gcodes = 2;
  total_size += 1 * this->gcodes_size();
  for (int i = 0; i < this->gcodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gcodes(i));
  }

  // repeated .pb.EmcStatusMCode mcodes = 5;
  total_size += 1 * this->mcodes_size();
  for (int i = 0; i < this->mcodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mcodes(i));
  }

  // repeated .pb.EmcStatusSetting settings = 6;
  total_size += 1 * this->settings_size();
  for (int i = 0; i < this->settings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->settings(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusInterp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusInterp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusInterp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusInterp::MergeFrom(const EmcStatusInterp& from) {
  GOOGLE_CHECK_NE(&from, this);
  gcodes_.MergeFrom(from.gcodes_);
  mcodes_.MergeFrom(from.mcodes_);
  settings_.MergeFrom(from.settings_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_command()) {
      set_command(from.command());
    }
    if (from.has_interp_state()) {
      set_interp_state(from.interp_state());
    }
    if (from.has_interpreter_errcode()) {
      set_interpreter_errcode(from.interpreter_errcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusInterp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusInterp::CopyFrom(const EmcStatusInterp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusInterp::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->gcodes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->mcodes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->settings())) return false;
  return true;
}

void EmcStatusInterp::Swap(EmcStatusInterp* other) {
  if (other != this) {
    std::swap(command_, other->command_);
    gcodes_.Swap(&other->gcodes_);
    std::swap(interp_state_, other->interp_state_);
    std::swap(interpreter_errcode_, other->interpreter_errcode_);
    mcodes_.Swap(&other->mcodes_);
    settings_.Swap(&other->settings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusInterp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusInterp_descriptor_;
  metadata.reflection = EmcStatusInterp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcCommandParameters::kIndexFieldNumber;
const int EmcCommandParameters::kDebugLevelFieldNumber;
const int EmcCommandParameters::kLineNumberFieldNumber;
const int EmcCommandParameters::kScaleFieldNumber;
const int EmcCommandParameters::kVelocityFieldNumber;
const int EmcCommandParameters::kDistanceFieldNumber;
const int EmcCommandParameters::kValueFieldNumber;
const int EmcCommandParameters::kEnableFieldNumber;
const int EmcCommandParameters::kCommandFieldNumber;
const int EmcCommandParameters::kPathFieldNumber;
const int EmcCommandParameters::kTaskModeFieldNumber;
const int EmcCommandParameters::kTaskStateFieldNumber;
const int EmcCommandParameters::kTrajModeFieldNumber;
const int EmcCommandParameters::kPoseFieldNumber;
const int EmcCommandParameters::kToolDataFieldNumber;
#endif  // !_MSC_VER

EmcCommandParameters::EmcCommandParameters()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcCommandParameters)
}

void EmcCommandParameters::InitAsDefaultInstance() {
  pose_ = const_cast< ::pb::EmcPose*>(&::pb::EmcPose::default_instance());
  tool_data_ = const_cast< ::pb::EmcToolData*>(&::pb::EmcToolData::default_instance());
}

EmcCommandParameters::EmcCommandParameters(const EmcCommandParameters& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcCommandParameters)
}

void EmcCommandParameters::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0u;
  debug_level_ = 0u;
  line_number_ = 0;
  scale_ = 0;
  velocity_ = 0;
  distance_ = 0;
  value_ = 0;
  enable_ = false;
  command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_mode_ = 1;
  task_state_ = 1;
  traj_mode_ = 1;
  pose_ = NULL;
  tool_data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcCommandParameters::~EmcCommandParameters() {
  // @@protoc_insertion_point(destructor:pb.EmcCommandParameters)
  SharedDtor();
}

void EmcCommandParameters::SharedDtor() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (this != default_instance_) {
    delete pose_;
    delete tool_data_;
  }
}

void EmcCommandParameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcCommandParameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcCommandParameters_descriptor_;
}

const EmcCommandParameters& EmcCommandParameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcCommandParameters* EmcCommandParameters::default_instance_ = NULL;

EmcCommandParameters* EmcCommandParameters::New() const {
  return new EmcCommandParameters;
}

void EmcCommandParameters::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmcCommandParameters*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(index_, value_);
  }
  if (_has_bits_[8 / 32] & 32512) {
    if (has_command()) {
      if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        command_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
    task_mode_ = 1;
    task_state_ = 1;
    traj_mode_ = 1;
    if (has_pose()) {
      if (pose_ != NULL) pose_->::pb::EmcPose::Clear();
    }
    if (has_tool_data()) {
      if (tool_data_ != NULL) tool_data_->::pb::EmcToolData::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcCommandParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcCommandParameters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_debug_level;
        break;
      }

      // optional uint32 debug_level = 2;
      case 2: {
        if (tag == 16) {
         parse_debug_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &debug_level_)));
          set_has_debug_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_line_number;
        break;
      }

      // optional int32 line_number = 3;
      case 3: {
        if (tag == 24) {
         parse_line_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &line_number_)));
          set_has_line_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_scale;
        break;
      }

      // optional double scale = 4;
      case 4: {
        if (tag == 33) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_velocity;
        break;
      }

      // optional double velocity = 5;
      case 5: {
        if (tag == 41) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_distance;
        break;
      }

      // optional double distance = 6;
      case 6: {
        if (tag == 49) {
         parse_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &distance_)));
          set_has_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_value;
        break;
      }

      // optional double value = 7;
      case 7: {
        if (tag == 57) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_enable;
        break;
      }

      // optional bool enable = 8;
      case 8: {
        if (tag == 64) {
         parse_enable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_)));
          set_has_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_command;
        break;
      }

      // optional string command = 9;
      case 9: {
        if (tag == 74) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_command()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->command().data(), this->command().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "command");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_path;
        break;
      }

      // optional string path = 10;
      case 10: {
        if (tag == 82) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(800)) goto parse_task_mode;
        break;
      }

      // optional .pb.EmcTaskModeType task_mode = 100;
      case 100: {
        if (tag == 800) {
         parse_task_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTaskModeType_IsValid(value)) {
            set_task_mode(static_cast< ::pb::EmcTaskModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(100, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(808)) goto parse_task_state;
        break;
      }

      // optional .pb.EmcTaskStateType task_state = 101;
      case 101: {
        if (tag == 808) {
         parse_task_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTaskStateType_IsValid(value)) {
            set_task_state(static_cast< ::pb::EmcTaskStateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(101, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(816)) goto parse_traj_mode;
        break;
      }

      // optional .pb.EmcTrajectoryModeType traj_mode = 102;
      case 102: {
        if (tag == 816) {
         parse_traj_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::pb::EmcTrajectoryModeType_IsValid(value)) {
            set_traj_mode(static_cast< ::pb::EmcTrajectoryModeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(102, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(826)) goto parse_pose;
        break;
      }

      // optional .pb.EmcPose pose = 103;
      case 103: {
        if (tag == 826) {
         parse_pose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pose()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(834)) goto parse_tool_data;
        break;
      }

      // optional .pb.EmcToolData tool_data = 104;
      case 104: {
        if (tag == 834) {
         parse_tool_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tool_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcCommandParameters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcCommandParameters)
  return false;
#undef DO_
}

void EmcCommandParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcCommandParameters)
  // optional uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // optional uint32 debug_level = 2;
  if (has_debug_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->debug_level(), output);
  }

  // optional int32 line_number = 3;
  if (has_line_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->line_number(), output);
  }

  // optional double scale = 4;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->scale(), output);
  }

  // optional double velocity = 5;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->velocity(), output);
  }

  // optional double distance = 6;
  if (has_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->distance(), output);
  }

  // optional double value = 7;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->value(), output);
  }

  // optional bool enable = 8;
  if (has_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->enable(), output);
  }

  // optional string command = 9;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->command(), output);
  }

  // optional string path = 10;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->path(), output);
  }

  // optional .pb.EmcTaskModeType task_mode = 100;
  if (has_task_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      100, this->task_mode(), output);
  }

  // optional .pb.EmcTaskStateType task_state = 101;
  if (has_task_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      101, this->task_state(), output);
  }

  // optional .pb.EmcTrajectoryModeType traj_mode = 102;
  if (has_traj_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      102, this->traj_mode(), output);
  }

  // optional .pb.EmcPose pose = 103;
  if (has_pose()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      103, this->pose(), output);
  }

  // optional .pb.EmcToolData tool_data = 104;
  if (has_tool_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      104, this->tool_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcCommandParameters)
}

::google::protobuf::uint8* EmcCommandParameters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcCommandParameters)
  // optional uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // optional uint32 debug_level = 2;
  if (has_debug_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->debug_level(), target);
  }

  // optional int32 line_number = 3;
  if (has_line_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->line_number(), target);
  }

  // optional double scale = 4;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->scale(), target);
  }

  // optional double velocity = 5;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->velocity(), target);
  }

  // optional double distance = 6;
  if (has_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->distance(), target);
  }

  // optional double value = 7;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->value(), target);
  }

  // optional bool enable = 8;
  if (has_enable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->enable(), target);
  }

  // optional string command = 9;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->command(), target);
  }

  // optional string path = 10;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->path(), target);
  }

  // optional .pb.EmcTaskModeType task_mode = 100;
  if (has_task_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      100, this->task_mode(), target);
  }

  // optional .pb.EmcTaskStateType task_state = 101;
  if (has_task_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      101, this->task_state(), target);
  }

  // optional .pb.EmcTrajectoryModeType traj_mode = 102;
  if (has_traj_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      102, this->traj_mode(), target);
  }

  // optional .pb.EmcPose pose = 103;
  if (has_pose()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        103, this->pose(), target);
  }

  // optional .pb.EmcToolData tool_data = 104;
  if (has_tool_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        104, this->tool_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcCommandParameters)
  return target;
}

int EmcCommandParameters::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional uint32 debug_level = 2;
    if (has_debug_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->debug_level());
    }

    // optional int32 line_number = 3;
    if (has_line_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->line_number());
    }

    // optional double scale = 4;
    if (has_scale()) {
      total_size += 1 + 8;
    }

    // optional double velocity = 5;
    if (has_velocity()) {
      total_size += 1 + 8;
    }

    // optional double distance = 6;
    if (has_distance()) {
      total_size += 1 + 8;
    }

    // optional double value = 7;
    if (has_value()) {
      total_size += 1 + 8;
    }

    // optional bool enable = 8;
    if (has_enable()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string command = 9;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->command());
    }

    // optional string path = 10;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional .pb.EmcTaskModeType task_mode = 100;
    if (has_task_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->task_mode());
    }

    // optional .pb.EmcTaskStateType task_state = 101;
    if (has_task_state()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->task_state());
    }

    // optional .pb.EmcTrajectoryModeType traj_mode = 102;
    if (has_traj_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->traj_mode());
    }

    // optional .pb.EmcPose pose = 103;
    if (has_pose()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pose());
    }

    // optional .pb.EmcToolData tool_data = 104;
    if (has_tool_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tool_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcCommandParameters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcCommandParameters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcCommandParameters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcCommandParameters::MergeFrom(const EmcCommandParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_debug_level()) {
      set_debug_level(from.debug_level());
    }
    if (from.has_line_number()) {
      set_line_number(from.line_number());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_distance()) {
      set_distance(from.distance());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_enable()) {
      set_enable(from.enable());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_command()) {
      set_command(from.command());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_task_mode()) {
      set_task_mode(from.task_mode());
    }
    if (from.has_task_state()) {
      set_task_state(from.task_state());
    }
    if (from.has_traj_mode()) {
      set_traj_mode(from.traj_mode());
    }
    if (from.has_pose()) {
      mutable_pose()->::pb::EmcPose::MergeFrom(from.pose());
    }
    if (from.has_tool_data()) {
      mutable_tool_data()->::pb::EmcToolData::MergeFrom(from.tool_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcCommandParameters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcCommandParameters::CopyFrom(const EmcCommandParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcCommandParameters::IsInitialized() const {

  if (has_pose()) {
    if (!this->pose().IsInitialized()) return false;
  }
  if (has_tool_data()) {
    if (!this->tool_data().IsInitialized()) return false;
  }
  return true;
}

void EmcCommandParameters::Swap(EmcCommandParameters* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(debug_level_, other->debug_level_);
    std::swap(line_number_, other->line_number_);
    std::swap(scale_, other->scale_);
    std::swap(velocity_, other->velocity_);
    std::swap(distance_, other->distance_);
    std::swap(value_, other->value_);
    std::swap(enable_, other->enable_);
    std::swap(command_, other->command_);
    std::swap(path_, other->path_);
    std::swap(task_mode_, other->task_mode_);
    std::swap(task_state_, other->task_state_);
    std::swap(traj_mode_, other->traj_mode_);
    std::swap(pose_, other->pose_);
    std::swap(tool_data_, other->tool_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcCommandParameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcCommandParameters_descriptor_;
  metadata.reflection = EmcCommandParameters_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmcStatusUserCommand::kIndexFieldNumber;
const int EmcStatusUserCommand::kCommandFieldNumber;
#endif  // !_MSC_VER

EmcStatusUserCommand::EmcStatusUserCommand()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pb.EmcStatusUserCommand)
}

void EmcStatusUserCommand::InitAsDefaultInstance() {
}

EmcStatusUserCommand::EmcStatusUserCommand(const EmcStatusUserCommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:pb.EmcStatusUserCommand)
}

void EmcStatusUserCommand::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0;
  command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmcStatusUserCommand::~EmcStatusUserCommand() {
  // @@protoc_insertion_point(destructor:pb.EmcStatusUserCommand)
  SharedDtor();
}

void EmcStatusUserCommand::SharedDtor() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (this != default_instance_) {
  }
}

void EmcStatusUserCommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmcStatusUserCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmcStatusUserCommand_descriptor_;
}

const EmcStatusUserCommand& EmcStatusUserCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_status_2eproto();
  return *default_instance_;
}

EmcStatusUserCommand* EmcStatusUserCommand::default_instance_ = NULL;

EmcStatusUserCommand* EmcStatusUserCommand::New() const {
  return new EmcStatusUserCommand;
}

void EmcStatusUserCommand::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    index_ = 0;
    if (has_command()) {
      if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        command_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmcStatusUserCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:pb.EmcStatusUserCommand)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional string command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_command()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->command().data(), this->command().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "command");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:pb.EmcStatusUserCommand)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:pb.EmcStatusUserCommand)
  return false;
#undef DO_
}

void EmcStatusUserCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:pb.EmcStatusUserCommand)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional string command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->command(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:pb.EmcStatusUserCommand)
}

::google::protobuf::uint8* EmcStatusUserCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb.EmcStatusUserCommand)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional string command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->command().data(), this->command().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "command");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->command(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb.EmcStatusUserCommand)
  return target;
}

int EmcStatusUserCommand::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional string command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->command());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmcStatusUserCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmcStatusUserCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmcStatusUserCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmcStatusUserCommand::MergeFrom(const EmcStatusUserCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_command()) {
      set_command(from.command());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmcStatusUserCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmcStatusUserCommand::CopyFrom(const EmcStatusUserCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmcStatusUserCommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmcStatusUserCommand::Swap(EmcStatusUserCommand* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(command_, other->command_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmcStatusUserCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmcStatusUserCommand_descriptor_;
  metadata.reflection = EmcStatusUserCommand_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)
