// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motcmds.proto

#ifndef PROTOBUF_motcmds_2eproto__INCLUDED
#define PROTOBUF_motcmds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "emcclass.pb.h"
#include "nanopb.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motcmds_2eproto();
void protobuf_AssignDesc_motcmds_2eproto();
void protobuf_ShutdownFile_motcmds_2eproto();

class MotionCommand;
class MotionStatus;

enum MotionType {
  _EMC_MOTION_TYPE_NONE = 0,
  _EMC_MOTION_TYPE_TRAVERSE = 1,
  _EMC_MOTION_TYPE_FEED = 2,
  _EMC_MOTION_TYPE_ARC = 3,
  _EMC_MOTION_TYPE_TOOLCHANGE = 4,
  _EMC_MOTION_TYPE_PROBING = 5,
  _EMC_MOTION_TYPE_INDEXROTARY = 6
};
bool MotionType_IsValid(int value);
const MotionType MotionType_MIN = _EMC_MOTION_TYPE_NONE;
const MotionType MotionType_MAX = _EMC_MOTION_TYPE_INDEXROTARY;
const int MotionType_ARRAYSIZE = MotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionType_descriptor();
inline const ::std::string& MotionType_Name(MotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionType_descriptor(), value);
}
inline bool MotionType_Parse(
    const ::std::string& name, MotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionType>(
    MotionType_descriptor(), name, value);
}
enum cmd_code_t {
  EMCMOT_ABORT = 4000,
  EMCMOT_AXIS_ABORT = 4001,
  EMCMOT_ENABLE = 4002,
  EMCMOT_DISABLE = 4003,
  EMCMOT_ENABLE_AMPLIFIER = 4004,
  EMCMOT_DISABLE_AMPLIFIER = 4005,
  EMCMOT_ENABLE_WATCHDOG = 4006,
  EMCMOT_DISABLE_WATCHDOG = 4007,
  EMCMOT_ACTIVATE_JOINT = 4008,
  EMCMOT_DEACTIVATE_JOINT = 4009,
  EMCMOT_PAUSE = 4010,
  EMCMOT_RESUME = 4011,
  EMCMOT_STEP = 4012,
  EMCMOT_FREE = 4013,
  EMCMOT_COORD = 4014,
  EMCMOT_TELEOP = 4015,
  EMCMOT_SPINDLE_SCALE = 4016,
  EMCMOT_SS_ENABLE = 4017,
  EMCMOT_FEED_SCALE = 4018,
  EMCMOT_FS_ENABLE = 4019,
  EMCMOT_FH_ENABLE = 4020,
  EMCMOT_AF_ENABLE = 4021,
  EMCMOT_OVERRIDE_LIMITS = 4022,
  EMCMOT_HOME = 4023,
  EMCMOT_UNHOME = 4024,
  EMCMOT_JOG_CONT = 4025,
  EMCMOT_JOG_INCR = 4026,
  EMCMOT_JOG_ABS = 4027,
  EMCMOT_SET_LINE = 4028,
  EMCMOT_SET_CIRCLE = 4029,
  EMCMOT_SET_TELEOP_VECTOR = 4030,
  EMCMOT_CLEAR_PROBE_FLAGS = 4031,
  EMCMOT_PROBE = 4032,
  EMCMOT_RIGID_TAP = 4033,
  EMCMOT_SET_POSITION_LIMITS = 4034,
  EMCMOT_SET_BACKLASH = 4035,
  EMCMOT_SET_MIN_FERROR = 4036,
  EMCMOT_SET_MAX_FERROR = 4037,
  EMCMOT_SET_VEL = 4038,
  EMCMOT_SET_VEL_LIMIT = 4039,
  EMCMOT_SET_JOINT_VEL_LIMIT = 4040,
  EMCMOT_SET_JOINT_ACC_LIMIT = 4041,
  EMCMOT_SET_ACC = 4042,
  EMCMOT_SET_TERM_COND = 4043,
  EMCMOT_SET_NUM_AXES = 4044,
  EMCMOT_SET_WORLD_HOME = 4045,
  EMCMOT_SET_HOMING_PARAMS = 4046,
  EMCMOT_SET_DEBUG = 4047,
  EMCMOT_SET_DOUT = 4048,
  EMCMOT_SET_AOUT = 4049,
  EMCMOT_SET_SPINDLESYNC = 4050,
  EMCMOT_SPINDLE_ON = 4051,
  EMCMOT_SPINDLE_OFF = 4052,
  EMCMOT_SPINDLE_INCREASE = 4053,
  EMCMOT_SPINDLE_DECREASE = 4054,
  EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055,
  EMCMOT_SPINDLE_BRAKE_RELEASE = 4056,
  EMCMOT_SET_MOTOR_OFFSET = 4057,
  EMCMOT_SET_JOINT_COMP = 4058,
  EMCMOT_SET_OFFSET = 4059
};
bool cmd_code_t_IsValid(int value);
const cmd_code_t cmd_code_t_MIN = EMCMOT_ABORT;
const cmd_code_t cmd_code_t_MAX = EMCMOT_SET_OFFSET;
const int cmd_code_t_ARRAYSIZE = cmd_code_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_code_t_descriptor();
inline const ::std::string& cmd_code_t_Name(cmd_code_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_code_t_descriptor(), value);
}
inline bool cmd_code_t_Parse(
    const ::std::string& name, cmd_code_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_code_t>(
    cmd_code_t_descriptor(), name, value);
}
enum cmd_status_t {
  EMCMOT_COMMAND_OK = 0,
  EMCMOT_COMMAND_UNKNOWN_COMMAND = 1,
  EMCMOT_COMMAND_INVALID_COMMAND = 2,
  EMCMOT_COMMAND_INVALID_PARAMS = 3,
  EMCMOT_COMMAND_BAD_EXEC = 4
};
bool cmd_status_t_IsValid(int value);
const cmd_status_t cmd_status_t_MIN = EMCMOT_COMMAND_OK;
const cmd_status_t cmd_status_t_MAX = EMCMOT_COMMAND_BAD_EXEC;
const int cmd_status_t_ARRAYSIZE = cmd_status_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_status_t_descriptor();
inline const ::std::string& cmd_status_t_Name(cmd_status_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_status_t_descriptor(), value);
}
inline bool cmd_status_t_Parse(
    const ::std::string& name, cmd_status_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_status_t>(
    cmd_status_t_descriptor(), name, value);
}
// ===================================================================

class MotionCommand : public ::google::protobuf::Message {
 public:
  MotionCommand();
  virtual ~MotionCommand();

  MotionCommand(const MotionCommand& from);

  inline MotionCommand& operator=(const MotionCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionCommand& default_instance();

  void Swap(MotionCommand* other);

  // implements Message ----------------------------------------------

  MotionCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionCommand& from);
  void MergeFrom(const MotionCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.cmd_code_t command = 10;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 10;
  inline ::pb::cmd_code_t command() const;
  inline void set_command(::pb::cmd_code_t value);

  // required fixed32 commandNum = 20;
  inline bool has_commandnum() const;
  inline void clear_commandnum();
  static const int kCommandNumFieldNumber = 20;
  inline ::google::protobuf::uint32 commandnum() const;
  inline void set_commandnum(::google::protobuf::uint32 value);

  // optional double motor_offset = 30;
  inline bool has_motor_offset() const;
  inline void clear_motor_offset();
  static const int kMotorOffsetFieldNumber = 30;
  inline double motor_offset() const;
  inline void set_motor_offset(double value);

  // optional double maxLimit = 40;
  inline bool has_maxlimit() const;
  inline void clear_maxlimit();
  static const int kMaxLimitFieldNumber = 40;
  inline double maxlimit() const;
  inline void set_maxlimit(double value);

  // optional double minLimit = 50;
  inline bool has_minlimit() const;
  inline void clear_minlimit();
  static const int kMinLimitFieldNumber = 50;
  inline double minlimit() const;
  inline void set_minlimit(double value);

  // optional .pb.EmcPose pos = 60;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 60;
  inline const ::pb::EmcPose& pos() const;
  inline ::pb::EmcPose* mutable_pos();
  inline ::pb::EmcPose* release_pos();
  inline void set_allocated_pos(::pb::EmcPose* pos);

  // optional .pb.PmCartesian center = 70;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 70;
  inline const ::pb::PmCartesian& center() const;
  inline ::pb::PmCartesian* mutable_center();
  inline ::pb::PmCartesian* release_center();
  inline void set_allocated_center(::pb::PmCartesian* center);

  // optional .pb.PmCartesian normal = 80;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 80;
  inline const ::pb::PmCartesian& normal() const;
  inline ::pb::PmCartesian* mutable_normal();
  inline ::pb::PmCartesian* release_normal();
  inline void set_allocated_normal(::pb::PmCartesian* normal);

  // optional fixed32 turn = 90;
  inline bool has_turn() const;
  inline void clear_turn();
  static const int kTurnFieldNumber = 90;
  inline ::google::protobuf::uint32 turn() const;
  inline void set_turn(::google::protobuf::uint32 value);

  // optional double vel = 100;
  inline bool has_vel() const;
  inline void clear_vel();
  static const int kVelFieldNumber = 100;
  inline double vel() const;
  inline void set_vel(double value);

  // optional double ini_maxvel = 110;
  inline bool has_ini_maxvel() const;
  inline void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 110;
  inline double ini_maxvel() const;
  inline void set_ini_maxvel(double value);

  // optional .pb.MotionType motion_type = 120;
  inline bool has_motion_type() const;
  inline void clear_motion_type();
  static const int kMotionTypeFieldNumber = 120;
  inline ::pb::MotionType motion_type() const;
  inline void set_motion_type(::pb::MotionType value);

  // optional double spindlesync = 130;
  inline bool has_spindlesync() const;
  inline void clear_spindlesync();
  static const int kSpindlesyncFieldNumber = 130;
  inline double spindlesync() const;
  inline void set_spindlesync(double value);

  // optional double acc = 140;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 140;
  inline double acc() const;
  inline void set_acc(double value);

  // optional double backlash = 150;
  inline bool has_backlash() const;
  inline void clear_backlash();
  static const int kBacklashFieldNumber = 150;
  inline double backlash() const;
  inline void set_backlash(double value);

  // optional fixed32 id = 160;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 160;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional fixed32 termCond = 170;
  inline bool has_termcond() const;
  inline void clear_termcond();
  static const int kTermCondFieldNumber = 170;
  inline ::google::protobuf::uint32 termcond() const;
  inline void set_termcond(::google::protobuf::uint32 value);

  // optional double tolerance = 180;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 180;
  inline double tolerance() const;
  inline void set_tolerance(double value);

  // optional fixed32 axis = 190;
  inline bool has_axis() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 190;
  inline ::google::protobuf::uint32 axis() const;
  inline void set_axis(::google::protobuf::uint32 value);

  // optional double scale = 200;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 200;
  inline double scale() const;
  inline void set_scale(double value);

  // optional double offset = 210;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 210;
  inline double offset() const;
  inline void set_offset(double value);

  // optional double home = 220;
  inline bool has_home() const;
  inline void clear_home();
  static const int kHomeFieldNumber = 220;
  inline double home() const;
  inline void set_home(double value);

  // optional double home_final_vel = 230;
  inline bool has_home_final_vel() const;
  inline void clear_home_final_vel();
  static const int kHomeFinalVelFieldNumber = 230;
  inline double home_final_vel() const;
  inline void set_home_final_vel(double value);

  // optional double search_vel = 240;
  inline bool has_search_vel() const;
  inline void clear_search_vel();
  static const int kSearchVelFieldNumber = 240;
  inline double search_vel() const;
  inline void set_search_vel(double value);

  // optional double latch_vel = 250;
  inline bool has_latch_vel() const;
  inline void clear_latch_vel();
  static const int kLatchVelFieldNumber = 250;
  inline double latch_vel() const;
  inline void set_latch_vel(double value);

  // optional fixed32 flags = 260;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 260;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional fixed32 home_sequence = 270;
  inline bool has_home_sequence() const;
  inline void clear_home_sequence();
  static const int kHomeSequenceFieldNumber = 270;
  inline ::google::protobuf::uint32 home_sequence() const;
  inline void set_home_sequence(::google::protobuf::uint32 value);

  // optional fixed32 volatile_home = 280;
  inline bool has_volatile_home() const;
  inline void clear_volatile_home();
  static const int kVolatileHomeFieldNumber = 280;
  inline ::google::protobuf::uint32 volatile_home() const;
  inline void set_volatile_home(::google::protobuf::uint32 value);

  // optional double minFerror = 290;
  inline bool has_minferror() const;
  inline void clear_minferror();
  static const int kMinFerrorFieldNumber = 290;
  inline double minferror() const;
  inline void set_minferror(double value);

  // optional double maxFerror = 300;
  inline bool has_maxferror() const;
  inline void clear_maxferror();
  static const int kMaxFerrorFieldNumber = 300;
  inline double maxferror() const;
  inline void set_maxferror(double value);

  // optional fixed32 wdWait = 310;
  inline bool has_wdwait() const;
  inline void clear_wdwait();
  static const int kWdWaitFieldNumber = 310;
  inline ::google::protobuf::uint32 wdwait() const;
  inline void set_wdwait(::google::protobuf::uint32 value);

  // optional fixed32 debug = 320;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 320;
  inline ::google::protobuf::uint32 debug() const;
  inline void set_debug(::google::protobuf::uint32 value);

  // optional int32 now = 330;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 330;
  inline ::google::protobuf::int32 now() const;
  inline void set_now(::google::protobuf::int32 value);

  // optional int32 out = 340;
  inline bool has_out() const;
  inline void clear_out();
  static const int kOutFieldNumber = 340;
  inline ::google::protobuf::int32 out() const;
  inline void set_out(::google::protobuf::int32 value);

  // optional int32 start = 350;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 350;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // optional int32 end = 360;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 360;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // optional int32 mode = 370;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 370;
  inline ::google::protobuf::int32 mode() const;
  inline void set_mode(::google::protobuf::int32 value);

  // optional double comp_nominal = 380;
  inline bool has_comp_nominal() const;
  inline void clear_comp_nominal();
  static const int kCompNominalFieldNumber = 380;
  inline double comp_nominal() const;
  inline void set_comp_nominal(double value);

  // optional double comp_forward = 390;
  inline bool has_comp_forward() const;
  inline void clear_comp_forward();
  static const int kCompForwardFieldNumber = 390;
  inline double comp_forward() const;
  inline void set_comp_forward(double value);

  // optional double comp_reverse = 400;
  inline bool has_comp_reverse() const;
  inline void clear_comp_reverse();
  static const int kCompReverseFieldNumber = 400;
  inline double comp_reverse() const;
  inline void set_comp_reverse(double value);

  // optional int32 probe_type = 410;
  inline bool has_probe_type() const;
  inline void clear_probe_type();
  static const int kProbeTypeFieldNumber = 410;
  inline ::google::protobuf::int32 probe_type() const;
  inline void set_probe_type(::google::protobuf::int32 value);

  // optional .pb.EmcPose tool_offset = 420;
  inline bool has_tool_offset() const;
  inline void clear_tool_offset();
  static const int kToolOffsetFieldNumber = 420;
  inline const ::pb::EmcPose& tool_offset() const;
  inline ::pb::EmcPose* mutable_tool_offset();
  inline ::pb::EmcPose* release_tool_offset();
  inline void set_allocated_tool_offset(::pb::EmcPose* tool_offset);

  // @@protoc_insertion_point(class_scope:pb.MotionCommand)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_commandnum();
  inline void clear_has_commandnum();
  inline void set_has_motor_offset();
  inline void clear_has_motor_offset();
  inline void set_has_maxlimit();
  inline void clear_has_maxlimit();
  inline void set_has_minlimit();
  inline void clear_has_minlimit();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_turn();
  inline void clear_has_turn();
  inline void set_has_vel();
  inline void clear_has_vel();
  inline void set_has_ini_maxvel();
  inline void clear_has_ini_maxvel();
  inline void set_has_motion_type();
  inline void clear_has_motion_type();
  inline void set_has_spindlesync();
  inline void clear_has_spindlesync();
  inline void set_has_acc();
  inline void clear_has_acc();
  inline void set_has_backlash();
  inline void clear_has_backlash();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_termcond();
  inline void clear_has_termcond();
  inline void set_has_tolerance();
  inline void clear_has_tolerance();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_home();
  inline void clear_has_home();
  inline void set_has_home_final_vel();
  inline void clear_has_home_final_vel();
  inline void set_has_search_vel();
  inline void clear_has_search_vel();
  inline void set_has_latch_vel();
  inline void clear_has_latch_vel();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_home_sequence();
  inline void clear_has_home_sequence();
  inline void set_has_volatile_home();
  inline void clear_has_volatile_home();
  inline void set_has_minferror();
  inline void clear_has_minferror();
  inline void set_has_maxferror();
  inline void clear_has_maxferror();
  inline void set_has_wdwait();
  inline void clear_has_wdwait();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_out();
  inline void clear_has_out();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_comp_nominal();
  inline void clear_has_comp_nominal();
  inline void set_has_comp_forward();
  inline void clear_has_comp_forward();
  inline void set_has_comp_reverse();
  inline void clear_has_comp_reverse();
  inline void set_has_probe_type();
  inline void clear_has_probe_type();
  inline void set_has_tool_offset();
  inline void clear_has_tool_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  int command_;
  ::google::protobuf::uint32 commandnum_;
  double motor_offset_;
  double maxlimit_;
  double minlimit_;
  ::pb::EmcPose* pos_;
  ::pb::PmCartesian* center_;
  ::pb::PmCartesian* normal_;
  double vel_;
  ::google::protobuf::uint32 turn_;
  int motion_type_;
  double ini_maxvel_;
  double spindlesync_;
  double acc_;
  double backlash_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 termcond_;
  double tolerance_;
  double scale_;
  double offset_;
  double home_;
  ::google::protobuf::uint32 axis_;
  ::google::protobuf::uint32 flags_;
  double home_final_vel_;
  double search_vel_;
  double latch_vel_;
  ::google::protobuf::uint32 home_sequence_;
  ::google::protobuf::uint32 volatile_home_;
  double minferror_;
  double maxferror_;
  ::google::protobuf::uint32 wdwait_;
  ::google::protobuf::uint32 debug_;
  ::google::protobuf::int32 now_;
  ::google::protobuf::int32 out_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  double comp_nominal_;
  double comp_forward_;
  ::google::protobuf::int32 mode_;
  ::google::protobuf::int32 probe_type_;
  double comp_reverse_;
  ::pb::EmcPose* tool_offset_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_motcmds_2eproto();
  friend void protobuf_AssignDesc_motcmds_2eproto();
  friend void protobuf_ShutdownFile_motcmds_2eproto();

  void InitAsDefaultInstance();
  static MotionCommand* default_instance_;
};
// -------------------------------------------------------------------

class MotionStatus : public ::google::protobuf::Message {
 public:
  MotionStatus();
  virtual ~MotionStatus();

  MotionStatus(const MotionStatus& from);

  inline MotionStatus& operator=(const MotionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionStatus& default_instance();

  void Swap(MotionStatus* other);

  // implements Message ----------------------------------------------

  MotionStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionStatus& from);
  void MergeFrom(const MotionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.cmd_code_t commandEcho = 10;
  inline bool has_commandecho() const;
  inline void clear_commandecho();
  static const int kCommandEchoFieldNumber = 10;
  inline ::pb::cmd_code_t commandecho() const;
  inline void set_commandecho(::pb::cmd_code_t value);

  // required fixed32 commandNumEcho = 20;
  inline bool has_commandnumecho() const;
  inline void clear_commandnumecho();
  static const int kCommandNumEchoFieldNumber = 20;
  inline ::google::protobuf::uint32 commandnumecho() const;
  inline void set_commandnumecho(::google::protobuf::uint32 value);

  // required .pb.cmd_status_t commandStatus = 30;
  inline bool has_commandstatus() const;
  inline void clear_commandstatus();
  static const int kCommandStatusFieldNumber = 30;
  inline ::pb::cmd_status_t commandstatus() const;
  inline void set_commandstatus(::pb::cmd_status_t value);

  // optional .pb.EmcPose carte_pos_fb = 40;
  inline bool has_carte_pos_fb() const;
  inline void clear_carte_pos_fb();
  static const int kCartePosFbFieldNumber = 40;
  inline const ::pb::EmcPose& carte_pos_fb() const;
  inline ::pb::EmcPose* mutable_carte_pos_fb();
  inline ::pb::EmcPose* release_carte_pos_fb();
  inline void set_allocated_carte_pos_fb(::pb::EmcPose* carte_pos_fb);

  // @@protoc_insertion_point(class_scope:pb.MotionStatus)
 private:
  inline void set_has_commandecho();
  inline void clear_has_commandecho();
  inline void set_has_commandnumecho();
  inline void clear_has_commandnumecho();
  inline void set_has_commandstatus();
  inline void clear_has_commandstatus();
  inline void set_has_carte_pos_fb();
  inline void clear_has_carte_pos_fb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int commandecho_;
  ::google::protobuf::uint32 commandnumecho_;
  ::pb::EmcPose* carte_pos_fb_;
  int commandstatus_;
  friend void  protobuf_AddDesc_motcmds_2eproto();
  friend void protobuf_AssignDesc_motcmds_2eproto();
  friend void protobuf_ShutdownFile_motcmds_2eproto();

  void InitAsDefaultInstance();
  static MotionStatus* default_instance_;
};
// ===================================================================


// ===================================================================

// MotionCommand

// required .pb.cmd_code_t command = 10;
inline bool MotionCommand::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionCommand::clear_command() {
  command_ = 4000;
  clear_has_command();
}
inline ::pb::cmd_code_t MotionCommand::command() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.command)
  return static_cast< ::pb::cmd_code_t >(command_);
}
inline void MotionCommand::set_command(::pb::cmd_code_t value) {
  assert(::pb::cmd_code_t_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.command)
}

// required fixed32 commandNum = 20;
inline bool MotionCommand::has_commandnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_commandnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionCommand::clear_has_commandnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionCommand::clear_commandnum() {
  commandnum_ = 0u;
  clear_has_commandnum();
}
inline ::google::protobuf::uint32 MotionCommand::commandnum() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.commandNum)
  return commandnum_;
}
inline void MotionCommand::set_commandnum(::google::protobuf::uint32 value) {
  set_has_commandnum();
  commandnum_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.commandNum)
}

// optional double motor_offset = 30;
inline bool MotionCommand::has_motor_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_motor_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionCommand::clear_has_motor_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionCommand::clear_motor_offset() {
  motor_offset_ = 0;
  clear_has_motor_offset();
}
inline double MotionCommand::motor_offset() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.motor_offset)
  return motor_offset_;
}
inline void MotionCommand::set_motor_offset(double value) {
  set_has_motor_offset();
  motor_offset_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.motor_offset)
}

// optional double maxLimit = 40;
inline bool MotionCommand::has_maxlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_maxlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionCommand::clear_has_maxlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionCommand::clear_maxlimit() {
  maxlimit_ = 0;
  clear_has_maxlimit();
}
inline double MotionCommand::maxlimit() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.maxLimit)
  return maxlimit_;
}
inline void MotionCommand::set_maxlimit(double value) {
  set_has_maxlimit();
  maxlimit_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.maxLimit)
}

// optional double minLimit = 50;
inline bool MotionCommand::has_minlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_minlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionCommand::clear_has_minlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionCommand::clear_minlimit() {
  minlimit_ = 0;
  clear_has_minlimit();
}
inline double MotionCommand::minlimit() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.minLimit)
  return minlimit_;
}
inline void MotionCommand::set_minlimit(double value) {
  set_has_minlimit();
  minlimit_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.minLimit)
}

// optional .pb.EmcPose pos = 60;
inline bool MotionCommand::has_pos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_pos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionCommand::clear_has_pos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionCommand::clear_pos() {
  if (pos_ != NULL) pos_->::pb::EmcPose::Clear();
  clear_has_pos();
}
inline const ::pb::EmcPose& MotionCommand::pos() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::pb::EmcPose* MotionCommand::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::pb::EmcPose;
  // @@protoc_insertion_point(field_mutable:pb.MotionCommand.pos)
  return pos_;
}
inline ::pb::EmcPose* MotionCommand::release_pos() {
  clear_has_pos();
  ::pb::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_pos(::pb::EmcPose* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MotionCommand.pos)
}

// optional .pb.PmCartesian center = 70;
inline bool MotionCommand::has_center() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_center() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionCommand::clear_has_center() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionCommand::clear_center() {
  if (center_ != NULL) center_->::pb::PmCartesian::Clear();
  clear_has_center();
}
inline const ::pb::PmCartesian& MotionCommand::center() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.center)
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::pb::PmCartesian* MotionCommand::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::pb::PmCartesian;
  // @@protoc_insertion_point(field_mutable:pb.MotionCommand.center)
  return center_;
}
inline ::pb::PmCartesian* MotionCommand::release_center() {
  clear_has_center();
  ::pb::PmCartesian* temp = center_;
  center_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_center(::pb::PmCartesian* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MotionCommand.center)
}

// optional .pb.PmCartesian normal = 80;
inline bool MotionCommand::has_normal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_normal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionCommand::clear_has_normal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionCommand::clear_normal() {
  if (normal_ != NULL) normal_->::pb::PmCartesian::Clear();
  clear_has_normal();
}
inline const ::pb::PmCartesian& MotionCommand::normal() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.normal)
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::pb::PmCartesian* MotionCommand::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::pb::PmCartesian;
  // @@protoc_insertion_point(field_mutable:pb.MotionCommand.normal)
  return normal_;
}
inline ::pb::PmCartesian* MotionCommand::release_normal() {
  clear_has_normal();
  ::pb::PmCartesian* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_normal(::pb::PmCartesian* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MotionCommand.normal)
}

// optional fixed32 turn = 90;
inline bool MotionCommand::has_turn() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_turn() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionCommand::clear_has_turn() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionCommand::clear_turn() {
  turn_ = 0u;
  clear_has_turn();
}
inline ::google::protobuf::uint32 MotionCommand::turn() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.turn)
  return turn_;
}
inline void MotionCommand::set_turn(::google::protobuf::uint32 value) {
  set_has_turn();
  turn_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.turn)
}

// optional double vel = 100;
inline bool MotionCommand::has_vel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_vel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionCommand::clear_has_vel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionCommand::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double MotionCommand::vel() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.vel)
  return vel_;
}
inline void MotionCommand::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.vel)
}

// optional double ini_maxvel = 110;
inline bool MotionCommand::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionCommand::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionCommand::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionCommand::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double MotionCommand::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.ini_maxvel)
  return ini_maxvel_;
}
inline void MotionCommand::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.ini_maxvel)
}

// optional .pb.MotionType motion_type = 120;
inline bool MotionCommand::has_motion_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MotionCommand::set_has_motion_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MotionCommand::clear_has_motion_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MotionCommand::clear_motion_type() {
  motion_type_ = 0;
  clear_has_motion_type();
}
inline ::pb::MotionType MotionCommand::motion_type() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.motion_type)
  return static_cast< ::pb::MotionType >(motion_type_);
}
inline void MotionCommand::set_motion_type(::pb::MotionType value) {
  assert(::pb::MotionType_IsValid(value));
  set_has_motion_type();
  motion_type_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.motion_type)
}

// optional double spindlesync = 130;
inline bool MotionCommand::has_spindlesync() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MotionCommand::set_has_spindlesync() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MotionCommand::clear_has_spindlesync() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MotionCommand::clear_spindlesync() {
  spindlesync_ = 0;
  clear_has_spindlesync();
}
inline double MotionCommand::spindlesync() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.spindlesync)
  return spindlesync_;
}
inline void MotionCommand::set_spindlesync(double value) {
  set_has_spindlesync();
  spindlesync_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.spindlesync)
}

// optional double acc = 140;
inline bool MotionCommand::has_acc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MotionCommand::set_has_acc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MotionCommand::clear_has_acc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MotionCommand::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double MotionCommand::acc() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.acc)
  return acc_;
}
inline void MotionCommand::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.acc)
}

// optional double backlash = 150;
inline bool MotionCommand::has_backlash() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MotionCommand::set_has_backlash() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MotionCommand::clear_has_backlash() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MotionCommand::clear_backlash() {
  backlash_ = 0;
  clear_has_backlash();
}
inline double MotionCommand::backlash() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.backlash)
  return backlash_;
}
inline void MotionCommand::set_backlash(double value) {
  set_has_backlash();
  backlash_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.backlash)
}

// optional fixed32 id = 160;
inline bool MotionCommand::has_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MotionCommand::set_has_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MotionCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MotionCommand::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MotionCommand::id() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.id)
  return id_;
}
inline void MotionCommand::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.id)
}

// optional fixed32 termCond = 170;
inline bool MotionCommand::has_termcond() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MotionCommand::set_has_termcond() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MotionCommand::clear_has_termcond() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MotionCommand::clear_termcond() {
  termcond_ = 0u;
  clear_has_termcond();
}
inline ::google::protobuf::uint32 MotionCommand::termcond() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.termCond)
  return termcond_;
}
inline void MotionCommand::set_termcond(::google::protobuf::uint32 value) {
  set_has_termcond();
  termcond_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.termCond)
}

// optional double tolerance = 180;
inline bool MotionCommand::has_tolerance() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MotionCommand::set_has_tolerance() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MotionCommand::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MotionCommand::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double MotionCommand::tolerance() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.tolerance)
  return tolerance_;
}
inline void MotionCommand::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.tolerance)
}

// optional fixed32 axis = 190;
inline bool MotionCommand::has_axis() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MotionCommand::set_has_axis() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MotionCommand::clear_has_axis() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MotionCommand::clear_axis() {
  axis_ = 0u;
  clear_has_axis();
}
inline ::google::protobuf::uint32 MotionCommand::axis() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.axis)
  return axis_;
}
inline void MotionCommand::set_axis(::google::protobuf::uint32 value) {
  set_has_axis();
  axis_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.axis)
}

// optional double scale = 200;
inline bool MotionCommand::has_scale() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MotionCommand::set_has_scale() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MotionCommand::clear_has_scale() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MotionCommand::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double MotionCommand::scale() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.scale)
  return scale_;
}
inline void MotionCommand::set_scale(double value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.scale)
}

// optional double offset = 210;
inline bool MotionCommand::has_offset() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MotionCommand::set_has_offset() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MotionCommand::clear_has_offset() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MotionCommand::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double MotionCommand::offset() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.offset)
  return offset_;
}
inline void MotionCommand::set_offset(double value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.offset)
}

// optional double home = 220;
inline bool MotionCommand::has_home() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MotionCommand::set_has_home() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MotionCommand::clear_has_home() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MotionCommand::clear_home() {
  home_ = 0;
  clear_has_home();
}
inline double MotionCommand::home() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.home)
  return home_;
}
inline void MotionCommand::set_home(double value) {
  set_has_home();
  home_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.home)
}

// optional double home_final_vel = 230;
inline bool MotionCommand::has_home_final_vel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MotionCommand::set_has_home_final_vel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MotionCommand::clear_has_home_final_vel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MotionCommand::clear_home_final_vel() {
  home_final_vel_ = 0;
  clear_has_home_final_vel();
}
inline double MotionCommand::home_final_vel() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.home_final_vel)
  return home_final_vel_;
}
inline void MotionCommand::set_home_final_vel(double value) {
  set_has_home_final_vel();
  home_final_vel_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.home_final_vel)
}

// optional double search_vel = 240;
inline bool MotionCommand::has_search_vel() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MotionCommand::set_has_search_vel() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MotionCommand::clear_has_search_vel() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MotionCommand::clear_search_vel() {
  search_vel_ = 0;
  clear_has_search_vel();
}
inline double MotionCommand::search_vel() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.search_vel)
  return search_vel_;
}
inline void MotionCommand::set_search_vel(double value) {
  set_has_search_vel();
  search_vel_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.search_vel)
}

// optional double latch_vel = 250;
inline bool MotionCommand::has_latch_vel() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MotionCommand::set_has_latch_vel() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MotionCommand::clear_has_latch_vel() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MotionCommand::clear_latch_vel() {
  latch_vel_ = 0;
  clear_has_latch_vel();
}
inline double MotionCommand::latch_vel() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.latch_vel)
  return latch_vel_;
}
inline void MotionCommand::set_latch_vel(double value) {
  set_has_latch_vel();
  latch_vel_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.latch_vel)
}

// optional fixed32 flags = 260;
inline bool MotionCommand::has_flags() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MotionCommand::set_has_flags() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MotionCommand::clear_has_flags() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MotionCommand::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MotionCommand::flags() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.flags)
  return flags_;
}
inline void MotionCommand::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.flags)
}

// optional fixed32 home_sequence = 270;
inline bool MotionCommand::has_home_sequence() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MotionCommand::set_has_home_sequence() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MotionCommand::clear_has_home_sequence() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MotionCommand::clear_home_sequence() {
  home_sequence_ = 0u;
  clear_has_home_sequence();
}
inline ::google::protobuf::uint32 MotionCommand::home_sequence() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.home_sequence)
  return home_sequence_;
}
inline void MotionCommand::set_home_sequence(::google::protobuf::uint32 value) {
  set_has_home_sequence();
  home_sequence_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.home_sequence)
}

// optional fixed32 volatile_home = 280;
inline bool MotionCommand::has_volatile_home() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MotionCommand::set_has_volatile_home() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MotionCommand::clear_has_volatile_home() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MotionCommand::clear_volatile_home() {
  volatile_home_ = 0u;
  clear_has_volatile_home();
}
inline ::google::protobuf::uint32 MotionCommand::volatile_home() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.volatile_home)
  return volatile_home_;
}
inline void MotionCommand::set_volatile_home(::google::protobuf::uint32 value) {
  set_has_volatile_home();
  volatile_home_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.volatile_home)
}

// optional double minFerror = 290;
inline bool MotionCommand::has_minferror() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MotionCommand::set_has_minferror() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MotionCommand::clear_has_minferror() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MotionCommand::clear_minferror() {
  minferror_ = 0;
  clear_has_minferror();
}
inline double MotionCommand::minferror() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.minFerror)
  return minferror_;
}
inline void MotionCommand::set_minferror(double value) {
  set_has_minferror();
  minferror_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.minFerror)
}

// optional double maxFerror = 300;
inline bool MotionCommand::has_maxferror() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MotionCommand::set_has_maxferror() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MotionCommand::clear_has_maxferror() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MotionCommand::clear_maxferror() {
  maxferror_ = 0;
  clear_has_maxferror();
}
inline double MotionCommand::maxferror() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.maxFerror)
  return maxferror_;
}
inline void MotionCommand::set_maxferror(double value) {
  set_has_maxferror();
  maxferror_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.maxFerror)
}

// optional fixed32 wdWait = 310;
inline bool MotionCommand::has_wdwait() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MotionCommand::set_has_wdwait() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MotionCommand::clear_has_wdwait() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MotionCommand::clear_wdwait() {
  wdwait_ = 0u;
  clear_has_wdwait();
}
inline ::google::protobuf::uint32 MotionCommand::wdwait() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.wdWait)
  return wdwait_;
}
inline void MotionCommand::set_wdwait(::google::protobuf::uint32 value) {
  set_has_wdwait();
  wdwait_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.wdWait)
}

// optional fixed32 debug = 320;
inline bool MotionCommand::has_debug() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MotionCommand::set_has_debug() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MotionCommand::clear_has_debug() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MotionCommand::clear_debug() {
  debug_ = 0u;
  clear_has_debug();
}
inline ::google::protobuf::uint32 MotionCommand::debug() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.debug)
  return debug_;
}
inline void MotionCommand::set_debug(::google::protobuf::uint32 value) {
  set_has_debug();
  debug_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.debug)
}

// optional int32 now = 330;
inline bool MotionCommand::has_now() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_now() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MotionCommand::clear_has_now() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MotionCommand::clear_now() {
  now_ = 0;
  clear_has_now();
}
inline ::google::protobuf::int32 MotionCommand::now() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.now)
  return now_;
}
inline void MotionCommand::set_now(::google::protobuf::int32 value) {
  set_has_now();
  now_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.now)
}

// optional int32 out = 340;
inline bool MotionCommand::has_out() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_out() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MotionCommand::clear_has_out() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MotionCommand::clear_out() {
  out_ = 0;
  clear_has_out();
}
inline ::google::protobuf::int32 MotionCommand::out() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.out)
  return out_;
}
inline void MotionCommand::set_out(::google::protobuf::int32 value) {
  set_has_out();
  out_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.out)
}

// optional int32 start = 350;
inline bool MotionCommand::has_start() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_start() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MotionCommand::clear_has_start() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MotionCommand::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 MotionCommand::start() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.start)
  return start_;
}
inline void MotionCommand::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.start)
}

// optional int32 end = 360;
inline bool MotionCommand::has_end() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_end() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MotionCommand::clear_has_end() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MotionCommand::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 MotionCommand::end() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.end)
  return end_;
}
inline void MotionCommand::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.end)
}

// optional int32 mode = 370;
inline bool MotionCommand::has_mode() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_mode() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MotionCommand::clear_has_mode() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MotionCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 MotionCommand::mode() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.mode)
  return mode_;
}
inline void MotionCommand::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.mode)
}

// optional double comp_nominal = 380;
inline bool MotionCommand::has_comp_nominal() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_comp_nominal() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MotionCommand::clear_has_comp_nominal() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MotionCommand::clear_comp_nominal() {
  comp_nominal_ = 0;
  clear_has_comp_nominal();
}
inline double MotionCommand::comp_nominal() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.comp_nominal)
  return comp_nominal_;
}
inline void MotionCommand::set_comp_nominal(double value) {
  set_has_comp_nominal();
  comp_nominal_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.comp_nominal)
}

// optional double comp_forward = 390;
inline bool MotionCommand::has_comp_forward() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_comp_forward() {
  _has_bits_[1] |= 0x00000040u;
}
inline void MotionCommand::clear_has_comp_forward() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void MotionCommand::clear_comp_forward() {
  comp_forward_ = 0;
  clear_has_comp_forward();
}
inline double MotionCommand::comp_forward() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.comp_forward)
  return comp_forward_;
}
inline void MotionCommand::set_comp_forward(double value) {
  set_has_comp_forward();
  comp_forward_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.comp_forward)
}

// optional double comp_reverse = 400;
inline bool MotionCommand::has_comp_reverse() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_comp_reverse() {
  _has_bits_[1] |= 0x00000080u;
}
inline void MotionCommand::clear_has_comp_reverse() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void MotionCommand::clear_comp_reverse() {
  comp_reverse_ = 0;
  clear_has_comp_reverse();
}
inline double MotionCommand::comp_reverse() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.comp_reverse)
  return comp_reverse_;
}
inline void MotionCommand::set_comp_reverse(double value) {
  set_has_comp_reverse();
  comp_reverse_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.comp_reverse)
}

// optional int32 probe_type = 410;
inline bool MotionCommand::has_probe_type() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_probe_type() {
  _has_bits_[1] |= 0x00000100u;
}
inline void MotionCommand::clear_has_probe_type() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void MotionCommand::clear_probe_type() {
  probe_type_ = 0;
  clear_has_probe_type();
}
inline ::google::protobuf::int32 MotionCommand::probe_type() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.probe_type)
  return probe_type_;
}
inline void MotionCommand::set_probe_type(::google::protobuf::int32 value) {
  set_has_probe_type();
  probe_type_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionCommand.probe_type)
}

// optional .pb.EmcPose tool_offset = 420;
inline bool MotionCommand::has_tool_offset() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_tool_offset() {
  _has_bits_[1] |= 0x00000200u;
}
inline void MotionCommand::clear_has_tool_offset() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void MotionCommand::clear_tool_offset() {
  if (tool_offset_ != NULL) tool_offset_->::pb::EmcPose::Clear();
  clear_has_tool_offset();
}
inline const ::pb::EmcPose& MotionCommand::tool_offset() const {
  // @@protoc_insertion_point(field_get:pb.MotionCommand.tool_offset)
  return tool_offset_ != NULL ? *tool_offset_ : *default_instance_->tool_offset_;
}
inline ::pb::EmcPose* MotionCommand::mutable_tool_offset() {
  set_has_tool_offset();
  if (tool_offset_ == NULL) tool_offset_ = new ::pb::EmcPose;
  // @@protoc_insertion_point(field_mutable:pb.MotionCommand.tool_offset)
  return tool_offset_;
}
inline ::pb::EmcPose* MotionCommand::release_tool_offset() {
  clear_has_tool_offset();
  ::pb::EmcPose* temp = tool_offset_;
  tool_offset_ = NULL;
  return temp;
}
inline void MotionCommand::set_allocated_tool_offset(::pb::EmcPose* tool_offset) {
  delete tool_offset_;
  tool_offset_ = tool_offset;
  if (tool_offset) {
    set_has_tool_offset();
  } else {
    clear_has_tool_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MotionCommand.tool_offset)
}

// -------------------------------------------------------------------

// MotionStatus

// required .pb.cmd_code_t commandEcho = 10;
inline bool MotionStatus::has_commandecho() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionStatus::set_has_commandecho() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionStatus::clear_has_commandecho() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionStatus::clear_commandecho() {
  commandecho_ = 4000;
  clear_has_commandecho();
}
inline ::pb::cmd_code_t MotionStatus::commandecho() const {
  // @@protoc_insertion_point(field_get:pb.MotionStatus.commandEcho)
  return static_cast< ::pb::cmd_code_t >(commandecho_);
}
inline void MotionStatus::set_commandecho(::pb::cmd_code_t value) {
  assert(::pb::cmd_code_t_IsValid(value));
  set_has_commandecho();
  commandecho_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionStatus.commandEcho)
}

// required fixed32 commandNumEcho = 20;
inline bool MotionStatus::has_commandnumecho() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionStatus::set_has_commandnumecho() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionStatus::clear_has_commandnumecho() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionStatus::clear_commandnumecho() {
  commandnumecho_ = 0u;
  clear_has_commandnumecho();
}
inline ::google::protobuf::uint32 MotionStatus::commandnumecho() const {
  // @@protoc_insertion_point(field_get:pb.MotionStatus.commandNumEcho)
  return commandnumecho_;
}
inline void MotionStatus::set_commandnumecho(::google::protobuf::uint32 value) {
  set_has_commandnumecho();
  commandnumecho_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionStatus.commandNumEcho)
}

// required .pb.cmd_status_t commandStatus = 30;
inline bool MotionStatus::has_commandstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionStatus::set_has_commandstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionStatus::clear_has_commandstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionStatus::clear_commandstatus() {
  commandstatus_ = 0;
  clear_has_commandstatus();
}
inline ::pb::cmd_status_t MotionStatus::commandstatus() const {
  // @@protoc_insertion_point(field_get:pb.MotionStatus.commandStatus)
  return static_cast< ::pb::cmd_status_t >(commandstatus_);
}
inline void MotionStatus::set_commandstatus(::pb::cmd_status_t value) {
  assert(::pb::cmd_status_t_IsValid(value));
  set_has_commandstatus();
  commandstatus_ = value;
  // @@protoc_insertion_point(field_set:pb.MotionStatus.commandStatus)
}

// optional .pb.EmcPose carte_pos_fb = 40;
inline bool MotionStatus::has_carte_pos_fb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionStatus::set_has_carte_pos_fb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionStatus::clear_has_carte_pos_fb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionStatus::clear_carte_pos_fb() {
  if (carte_pos_fb_ != NULL) carte_pos_fb_->::pb::EmcPose::Clear();
  clear_has_carte_pos_fb();
}
inline const ::pb::EmcPose& MotionStatus::carte_pos_fb() const {
  // @@protoc_insertion_point(field_get:pb.MotionStatus.carte_pos_fb)
  return carte_pos_fb_ != NULL ? *carte_pos_fb_ : *default_instance_->carte_pos_fb_;
}
inline ::pb::EmcPose* MotionStatus::mutable_carte_pos_fb() {
  set_has_carte_pos_fb();
  if (carte_pos_fb_ == NULL) carte_pos_fb_ = new ::pb::EmcPose;
  // @@protoc_insertion_point(field_mutable:pb.MotionStatus.carte_pos_fb)
  return carte_pos_fb_;
}
inline ::pb::EmcPose* MotionStatus::release_carte_pos_fb() {
  clear_has_carte_pos_fb();
  ::pb::EmcPose* temp = carte_pos_fb_;
  carte_pos_fb_ = NULL;
  return temp;
}
inline void MotionStatus::set_allocated_carte_pos_fb(::pb::EmcPose* carte_pos_fb) {
  delete carte_pos_fb_;
  carte_pos_fb_ = carte_pos_fb;
  if (carte_pos_fb) {
    set_has_carte_pos_fb();
  } else {
    clear_has_carte_pos_fb();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.MotionStatus.carte_pos_fb)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::MotionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::MotionType>() {
  return ::pb::MotionType_descriptor();
}
template <> struct is_proto_enum< ::pb::cmd_code_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::cmd_code_t>() {
  return ::pb::cmd_code_t_descriptor();
}
template <> struct is_proto_enum< ::pb::cmd_status_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::cmd_status_t>() {
  return ::pb::cmd_status_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motcmds_2eproto__INCLUDED
