// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#ifndef PROTOBUF_status_2eproto__INCLUDED
#define PROTOBUF_status_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "preview.pb.h"
#include "emcclass.pb.h"
#include "motcmds.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_status_2eproto();
void protobuf_AssignDesc_status_2eproto();
void protobuf_ShutdownFile_status_2eproto();

class EmcToolData;
class EmcStatusMotionAxis;
class EmcStatusConfigAxis;
class EmcProgramExtension;
class EmcStatusAnalogIO;
class EmcStatusDigitalIO;
class EmcStatusLimit;
class EmcStatusGCode;
class EmcStatusMCode;
class EmcStatusSetting;
class EmcStatusConfig;
class EmcStatusMotion;
class EmcStatusIo;
class EmcStatusTask;
class EmcStatusInterp;
class EmcCommandParameters;
class EmcStatusUserCommand;

enum EmcTaskExecStateType {
  EMC_TASK_EXEC_ERROR = 1,
  EMC_TASK_EXEC_DONE = 2,
  EMC_TASK_EXEC_WAITING_FOR_MOTION = 3,
  EMC_TASK_EXEC_WAITING_FOR_MOTION_QUEUE = 4,
  EMC_TASK_EXEC_WAITING_FOR_IO = 5,
  EMC_TASK_EXEC_WAITING_FOR_MOTION_AND_IO = 7,
  EMC_TASK_EXEC_WAITING_FOR_DELAY = 8,
  EMC_TASK_EXEC_WAITING_FOR_SYSTEM_CMD = 9,
  EMC_TASK_EXEC_WAITING_FOR_SPINDLE_ORIENTED = 10
};
bool EmcTaskExecStateType_IsValid(int value);
const EmcTaskExecStateType EmcTaskExecStateType_MIN = EMC_TASK_EXEC_ERROR;
const EmcTaskExecStateType EmcTaskExecStateType_MAX = EMC_TASK_EXEC_WAITING_FOR_SPINDLE_ORIENTED;
const int EmcTaskExecStateType_ARRAYSIZE = EmcTaskExecStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcTaskExecStateType_descriptor();
inline const ::std::string& EmcTaskExecStateType_Name(EmcTaskExecStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcTaskExecStateType_descriptor(), value);
}
inline bool EmcTaskExecStateType_Parse(
    const ::std::string& name, EmcTaskExecStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcTaskExecStateType>(
    EmcTaskExecStateType_descriptor(), name, value);
}
enum EmcInterpStateType {
  EMC_TASK_INTERP_IDLE = 1,
  EMC_TASK_INTERP_READING = 2,
  EMC_TASK_INTERP_PAUSED = 3,
  EMC_TASK_INTERP_WAITING = 4
};
bool EmcInterpStateType_IsValid(int value);
const EmcInterpStateType EmcInterpStateType_MIN = EMC_TASK_INTERP_IDLE;
const EmcInterpStateType EmcInterpStateType_MAX = EMC_TASK_INTERP_WAITING;
const int EmcInterpStateType_ARRAYSIZE = EmcInterpStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcInterpStateType_descriptor();
inline const ::std::string& EmcInterpStateType_Name(EmcInterpStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcInterpStateType_descriptor(), value);
}
inline bool EmcInterpStateType_Parse(
    const ::std::string& name, EmcInterpStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcInterpStateType>(
    EmcInterpStateType_descriptor(), name, value);
}
enum EmcInterpExitCodeType {
  EMC_INTERP_EXIT_OK = 0,
  EMC_INTERP_EXIT_EXIT = 1,
  EMC_INTERP_EXIT_EXECUTE_FINISH = 2,
  EMC_INTERP_EXIT_ENDFILE = 3,
  EMC_INTERP_EXIT_FILE_NOT_OPEN = 4,
  EMC_INTERP_EXIT_ERROR = 5
};
bool EmcInterpExitCodeType_IsValid(int value);
const EmcInterpExitCodeType EmcInterpExitCodeType_MIN = EMC_INTERP_EXIT_OK;
const EmcInterpExitCodeType EmcInterpExitCodeType_MAX = EMC_INTERP_EXIT_ERROR;
const int EmcInterpExitCodeType_ARRAYSIZE = EmcInterpExitCodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcInterpExitCodeType_descriptor();
inline const ::std::string& EmcInterpExitCodeType_Name(EmcInterpExitCodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcInterpExitCodeType_descriptor(), value);
}
inline bool EmcInterpExitCodeType_Parse(
    const ::std::string& name, EmcInterpExitCodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcInterpExitCodeType>(
    EmcInterpExitCodeType_descriptor(), name, value);
}
enum EmcKinematicsType {
  KINEMATICS_IDENTITY = 1,
  KINEMATICS_FORWARD_ONLY = 2,
  KINEMATICS_INVERSE_ONLY = 3,
  KINEMATICS_BOTH = 4
};
bool EmcKinematicsType_IsValid(int value);
const EmcKinematicsType EmcKinematicsType_MIN = KINEMATICS_IDENTITY;
const EmcKinematicsType EmcKinematicsType_MAX = KINEMATICS_BOTH;
const int EmcKinematicsType_ARRAYSIZE = EmcKinematicsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcKinematicsType_descriptor();
inline const ::std::string& EmcKinematicsType_Name(EmcKinematicsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcKinematicsType_descriptor(), value);
}
inline bool EmcKinematicsType_Parse(
    const ::std::string& name, EmcKinematicsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcKinematicsType>(
    EmcKinematicsType_descriptor(), name, value);
}
enum EmcTrajectoryModeType {
  EMC_TRAJ_MODE_FREE = 1,
  EMC_TRAJ_MODE_COORD = 2,
  EMC_TRAJ_MODE_TELEOP = 3
};
bool EmcTrajectoryModeType_IsValid(int value);
const EmcTrajectoryModeType EmcTrajectoryModeType_MIN = EMC_TRAJ_MODE_FREE;
const EmcTrajectoryModeType EmcTrajectoryModeType_MAX = EMC_TRAJ_MODE_TELEOP;
const int EmcTrajectoryModeType_ARRAYSIZE = EmcTrajectoryModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcTrajectoryModeType_descriptor();
inline const ::std::string& EmcTrajectoryModeType_Name(EmcTrajectoryModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcTrajectoryModeType_descriptor(), value);
}
inline bool EmcTrajectoryModeType_Parse(
    const ::std::string& name, EmcTrajectoryModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcTrajectoryModeType>(
    EmcTrajectoryModeType_descriptor(), name, value);
}
enum EmcCanonUnitsType {
  CANON_UNITS_INCHES = 1,
  CANON_UNITS_MM = 2,
  CANON_UNITS_CM = 3
};
bool EmcCanonUnitsType_IsValid(int value);
const EmcCanonUnitsType EmcCanonUnitsType_MIN = CANON_UNITS_INCHES;
const EmcCanonUnitsType EmcCanonUnitsType_MAX = CANON_UNITS_CM;
const int EmcCanonUnitsType_ARRAYSIZE = EmcCanonUnitsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcCanonUnitsType_descriptor();
inline const ::std::string& EmcCanonUnitsType_Name(EmcCanonUnitsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcCanonUnitsType_descriptor(), value);
}
inline bool EmcCanonUnitsType_Parse(
    const ::std::string& name, EmcCanonUnitsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcCanonUnitsType>(
    EmcCanonUnitsType_descriptor(), name, value);
}
enum EmcTimeUnitsType {
  TIME_UNITS_MINUTE = 1,
  TIME_UNITS_SECOND = 2
};
bool EmcTimeUnitsType_IsValid(int value);
const EmcTimeUnitsType EmcTimeUnitsType_MIN = TIME_UNITS_MINUTE;
const EmcTimeUnitsType EmcTimeUnitsType_MAX = TIME_UNITS_SECOND;
const int EmcTimeUnitsType_ARRAYSIZE = EmcTimeUnitsType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcTimeUnitsType_descriptor();
inline const ::std::string& EmcTimeUnitsType_Name(EmcTimeUnitsType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcTimeUnitsType_descriptor(), value);
}
inline bool EmcTimeUnitsType_Parse(
    const ::std::string& name, EmcTimeUnitsType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcTimeUnitsType>(
    EmcTimeUnitsType_descriptor(), name, value);
}
enum EmcTaskModeType {
  EMC_TASK_MODE_MANUAL = 1,
  EMC_TASK_MODE_AUTO = 2,
  EMC_TASK_MODE_MDI = 3
};
bool EmcTaskModeType_IsValid(int value);
const EmcTaskModeType EmcTaskModeType_MIN = EMC_TASK_MODE_MANUAL;
const EmcTaskModeType EmcTaskModeType_MAX = EMC_TASK_MODE_MDI;
const int EmcTaskModeType_ARRAYSIZE = EmcTaskModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcTaskModeType_descriptor();
inline const ::std::string& EmcTaskModeType_Name(EmcTaskModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcTaskModeType_descriptor(), value);
}
inline bool EmcTaskModeType_Parse(
    const ::std::string& name, EmcTaskModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcTaskModeType>(
    EmcTaskModeType_descriptor(), name, value);
}
enum EmcTaskStateType {
  EMC_TASK_STATE_ESTOP = 1,
  EMC_TASK_STATE_ESTOP_RESET = 2,
  EMC_TASK_STATE_OFF = 3,
  EMC_TASK_STATE_ON = 4
};
bool EmcTaskStateType_IsValid(int value);
const EmcTaskStateType EmcTaskStateType_MIN = EMC_TASK_STATE_ESTOP;
const EmcTaskStateType EmcTaskStateType_MAX = EMC_TASK_STATE_ON;
const int EmcTaskStateType_ARRAYSIZE = EmcTaskStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcTaskStateType_descriptor();
inline const ::std::string& EmcTaskStateType_Name(EmcTaskStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcTaskStateType_descriptor(), value);
}
inline bool EmcTaskStateType_Parse(
    const ::std::string& name, EmcTaskStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcTaskStateType>(
    EmcTaskStateType_descriptor(), name, value);
}
enum EmcAxisType {
  EMC_AXIS_LINEAR = 1,
  EMC_AXIS_ANGULAR = 2
};
bool EmcAxisType_IsValid(int value);
const EmcAxisType EmcAxisType_MIN = EMC_AXIS_LINEAR;
const EmcAxisType EmcAxisType_MAX = EMC_AXIS_ANGULAR;
const int EmcAxisType_ARRAYSIZE = EmcAxisType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcAxisType_descriptor();
inline const ::std::string& EmcAxisType_Name(EmcAxisType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcAxisType_descriptor(), value);
}
inline bool EmcAxisType_Parse(
    const ::std::string& name, EmcAxisType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcAxisType>(
    EmcAxisType_descriptor(), name, value);
}
enum EmcPositionOffsetType {
  EMC_CONFIG_RELATIVE_OFFSET = 1,
  EMC_CONFIG_MACHINE_OFFSET = 2
};
bool EmcPositionOffsetType_IsValid(int value);
const EmcPositionOffsetType EmcPositionOffsetType_MIN = EMC_CONFIG_RELATIVE_OFFSET;
const EmcPositionOffsetType EmcPositionOffsetType_MAX = EMC_CONFIG_MACHINE_OFFSET;
const int EmcPositionOffsetType_ARRAYSIZE = EmcPositionOffsetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcPositionOffsetType_descriptor();
inline const ::std::string& EmcPositionOffsetType_Name(EmcPositionOffsetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcPositionOffsetType_descriptor(), value);
}
inline bool EmcPositionOffsetType_Parse(
    const ::std::string& name, EmcPositionOffsetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcPositionOffsetType>(
    EmcPositionOffsetType_descriptor(), name, value);
}
enum EmcPositionFeedbackType {
  EMC_CONFIG_ACTUAL_FEEDBACK = 1,
  EMC_CONFIG_COMMANDED_FEEDBACK = 2
};
bool EmcPositionFeedbackType_IsValid(int value);
const EmcPositionFeedbackType EmcPositionFeedbackType_MIN = EMC_CONFIG_ACTUAL_FEEDBACK;
const EmcPositionFeedbackType EmcPositionFeedbackType_MAX = EMC_CONFIG_COMMANDED_FEEDBACK;
const int EmcPositionFeedbackType_ARRAYSIZE = EmcPositionFeedbackType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmcPositionFeedbackType_descriptor();
inline const ::std::string& EmcPositionFeedbackType_Name(EmcPositionFeedbackType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmcPositionFeedbackType_descriptor(), value);
}
inline bool EmcPositionFeedbackType_Parse(
    const ::std::string& name, EmcPositionFeedbackType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmcPositionFeedbackType>(
    EmcPositionFeedbackType_descriptor(), name, value);
}
// ===================================================================

class EmcToolData : public ::google::protobuf::Message {
 public:
  EmcToolData();
  virtual ~EmcToolData();

  EmcToolData(const EmcToolData& from);

  inline EmcToolData& operator=(const EmcToolData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcToolData& default_instance();

  void Swap(EmcToolData* other);

  // implements Message ----------------------------------------------

  EmcToolData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcToolData& from);
  void MergeFrom(const EmcToolData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional double xOffset = 3;
  inline bool has_xoffset() const;
  inline void clear_xoffset();
  static const int kXOffsetFieldNumber = 3;
  inline double xoffset() const;
  inline void set_xoffset(double value);

  // optional double yOffset = 4;
  inline bool has_yoffset() const;
  inline void clear_yoffset();
  static const int kYOffsetFieldNumber = 4;
  inline double yoffset() const;
  inline void set_yoffset(double value);

  // optional double zOffset = 5;
  inline bool has_zoffset() const;
  inline void clear_zoffset();
  static const int kZOffsetFieldNumber = 5;
  inline double zoffset() const;
  inline void set_zoffset(double value);

  // optional double aOffset = 6;
  inline bool has_aoffset() const;
  inline void clear_aoffset();
  static const int kAOffsetFieldNumber = 6;
  inline double aoffset() const;
  inline void set_aoffset(double value);

  // optional double bOffset = 7;
  inline bool has_boffset() const;
  inline void clear_boffset();
  static const int kBOffsetFieldNumber = 7;
  inline double boffset() const;
  inline void set_boffset(double value);

  // optional double cOffset = 8;
  inline bool has_coffset() const;
  inline void clear_coffset();
  static const int kCOffsetFieldNumber = 8;
  inline double coffset() const;
  inline void set_coffset(double value);

  // optional double uOffset = 9;
  inline bool has_uoffset() const;
  inline void clear_uoffset();
  static const int kUOffsetFieldNumber = 9;
  inline double uoffset() const;
  inline void set_uoffset(double value);

  // optional double vOffset = 10;
  inline bool has_voffset() const;
  inline void clear_voffset();
  static const int kVOffsetFieldNumber = 10;
  inline double voffset() const;
  inline void set_voffset(double value);

  // optional double wOffset = 11;
  inline bool has_woffset() const;
  inline void clear_woffset();
  static const int kWOffsetFieldNumber = 11;
  inline double woffset() const;
  inline void set_woffset(double value);

  // optional double diameter = 12;
  inline bool has_diameter() const;
  inline void clear_diameter();
  static const int kDiameterFieldNumber = 12;
  inline double diameter() const;
  inline void set_diameter(double value);

  // optional double frontangle = 13;
  inline bool has_frontangle() const;
  inline void clear_frontangle();
  static const int kFrontangleFieldNumber = 13;
  inline double frontangle() const;
  inline void set_frontangle(double value);

  // optional double backangle = 14;
  inline bool has_backangle() const;
  inline void clear_backangle();
  static const int kBackangleFieldNumber = 14;
  inline double backangle() const;
  inline void set_backangle(double value);

  // optional int32 orientation = 15;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 15;
  inline ::google::protobuf::int32 orientation() const;
  inline void set_orientation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.EmcToolData)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_xoffset();
  inline void clear_has_xoffset();
  inline void set_has_yoffset();
  inline void clear_has_yoffset();
  inline void set_has_zoffset();
  inline void clear_has_zoffset();
  inline void set_has_aoffset();
  inline void clear_has_aoffset();
  inline void set_has_boffset();
  inline void clear_has_boffset();
  inline void set_has_coffset();
  inline void clear_has_coffset();
  inline void set_has_uoffset();
  inline void clear_has_uoffset();
  inline void set_has_voffset();
  inline void clear_has_voffset();
  inline void set_has_woffset();
  inline void clear_has_woffset();
  inline void set_has_diameter();
  inline void clear_has_diameter();
  inline void set_has_frontangle();
  inline void clear_has_frontangle();
  inline void set_has_backangle();
  inline void clear_has_backangle();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 id_;
  double xoffset_;
  double yoffset_;
  double zoffset_;
  double aoffset_;
  double boffset_;
  double coffset_;
  double uoffset_;
  double voffset_;
  double woffset_;
  double diameter_;
  double frontangle_;
  double backangle_;
  ::google::protobuf::int32 orientation_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcToolData* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusMotionAxis : public ::google::protobuf::Message {
 public:
  EmcStatusMotionAxis();
  virtual ~EmcStatusMotionAxis();

  EmcStatusMotionAxis(const EmcStatusMotionAxis& from);

  inline EmcStatusMotionAxis& operator=(const EmcStatusMotionAxis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusMotionAxis& default_instance();

  void Swap(EmcStatusMotionAxis* other);

  // implements Message ----------------------------------------------

  EmcStatusMotionAxis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusMotionAxis& from);
  void MergeFrom(const EmcStatusMotionAxis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional bool enabled = 2;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool fault = 3;
  inline bool has_fault() const;
  inline void clear_fault();
  static const int kFaultFieldNumber = 3;
  inline bool fault() const;
  inline void set_fault(bool value);

  // optional double ferror_current = 4;
  inline bool has_ferror_current() const;
  inline void clear_ferror_current();
  static const int kFerrorCurrentFieldNumber = 4;
  inline double ferror_current() const;
  inline void set_ferror_current(double value);

  // optional double ferror_highmark = 5;
  inline bool has_ferror_highmark() const;
  inline void clear_ferror_highmark();
  static const int kFerrorHighmarkFieldNumber = 5;
  inline double ferror_highmark() const;
  inline void set_ferror_highmark(double value);

  // optional bool homed = 6;
  inline bool has_homed() const;
  inline void clear_homed();
  static const int kHomedFieldNumber = 6;
  inline bool homed() const;
  inline void set_homed(bool value);

  // optional bool homing = 7;
  inline bool has_homing() const;
  inline void clear_homing();
  static const int kHomingFieldNumber = 7;
  inline bool homing() const;
  inline void set_homing(bool value);

  // optional bool inpos = 8;
  inline bool has_inpos() const;
  inline void clear_inpos();
  static const int kInposFieldNumber = 8;
  inline bool inpos() const;
  inline void set_inpos(bool value);

  // optional double input = 9;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 9;
  inline double input() const;
  inline void set_input(double value);

  // optional bool max_hard_limit = 10;
  inline bool has_max_hard_limit() const;
  inline void clear_max_hard_limit();
  static const int kMaxHardLimitFieldNumber = 10;
  inline bool max_hard_limit() const;
  inline void set_max_hard_limit(bool value);

  // optional bool max_soft_limit = 11;
  inline bool has_max_soft_limit() const;
  inline void clear_max_soft_limit();
  static const int kMaxSoftLimitFieldNumber = 11;
  inline bool max_soft_limit() const;
  inline void set_max_soft_limit(bool value);

  // optional bool min_hard_limit = 12;
  inline bool has_min_hard_limit() const;
  inline void clear_min_hard_limit();
  static const int kMinHardLimitFieldNumber = 12;
  inline bool min_hard_limit() const;
  inline void set_min_hard_limit(bool value);

  // optional bool min_soft_limit = 13;
  inline bool has_min_soft_limit() const;
  inline void clear_min_soft_limit();
  static const int kMinSoftLimitFieldNumber = 13;
  inline bool min_soft_limit() const;
  inline void set_min_soft_limit(bool value);

  // optional double output = 14;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 14;
  inline double output() const;
  inline void set_output(double value);

  // optional bool override_limits = 15;
  inline bool has_override_limits() const;
  inline void clear_override_limits();
  static const int kOverrideLimitsFieldNumber = 15;
  inline bool override_limits() const;
  inline void set_override_limits(bool value);

  // optional double velocity = 16;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 16;
  inline double velocity() const;
  inline void set_velocity(double value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusMotionAxis)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_fault();
  inline void clear_has_fault();
  inline void set_has_ferror_current();
  inline void clear_has_ferror_current();
  inline void set_has_ferror_highmark();
  inline void clear_has_ferror_highmark();
  inline void set_has_homed();
  inline void clear_has_homed();
  inline void set_has_homing();
  inline void clear_has_homing();
  inline void set_has_inpos();
  inline void clear_has_inpos();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_max_hard_limit();
  inline void clear_has_max_hard_limit();
  inline void set_has_max_soft_limit();
  inline void clear_has_max_soft_limit();
  inline void set_has_min_hard_limit();
  inline void clear_has_min_hard_limit();
  inline void set_has_min_soft_limit();
  inline void clear_has_min_soft_limit();
  inline void set_has_output();
  inline void clear_has_output();
  inline void set_has_override_limits();
  inline void clear_has_override_limits();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  bool enabled_;
  bool fault_;
  bool homed_;
  bool homing_;
  double ferror_current_;
  double ferror_highmark_;
  double input_;
  bool inpos_;
  bool max_hard_limit_;
  bool max_soft_limit_;
  bool min_hard_limit_;
  bool min_soft_limit_;
  bool override_limits_;
  double output_;
  double velocity_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusMotionAxis* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusConfigAxis : public ::google::protobuf::Message {
 public:
  EmcStatusConfigAxis();
  virtual ~EmcStatusConfigAxis();

  EmcStatusConfigAxis(const EmcStatusConfigAxis& from);

  inline EmcStatusConfigAxis& operator=(const EmcStatusConfigAxis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusConfigAxis& default_instance();

  void Swap(EmcStatusConfigAxis* other);

  // implements Message ----------------------------------------------

  EmcStatusConfigAxis* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusConfigAxis& from);
  void MergeFrom(const EmcStatusConfigAxis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional .pb.EmcAxisType axisType = 2;
  inline bool has_axistype() const;
  inline void clear_axistype();
  static const int kAxisTypeFieldNumber = 2;
  inline ::pb::EmcAxisType axistype() const;
  inline void set_axistype(::pb::EmcAxisType value);

  // optional double backlash = 3;
  inline bool has_backlash() const;
  inline void clear_backlash();
  static const int kBacklashFieldNumber = 3;
  inline double backlash() const;
  inline void set_backlash(double value);

  // optional double max_ferror = 4;
  inline bool has_max_ferror() const;
  inline void clear_max_ferror();
  static const int kMaxFerrorFieldNumber = 4;
  inline double max_ferror() const;
  inline void set_max_ferror(double value);

  // optional double max_position_limit = 5;
  inline bool has_max_position_limit() const;
  inline void clear_max_position_limit();
  static const int kMaxPositionLimitFieldNumber = 5;
  inline double max_position_limit() const;
  inline void set_max_position_limit(double value);

  // optional double min_ferror = 6;
  inline bool has_min_ferror() const;
  inline void clear_min_ferror();
  static const int kMinFerrorFieldNumber = 6;
  inline double min_ferror() const;
  inline void set_min_ferror(double value);

  // optional double min_position_limit = 7;
  inline bool has_min_position_limit() const;
  inline void clear_min_position_limit();
  static const int kMinPositionLimitFieldNumber = 7;
  inline double min_position_limit() const;
  inline void set_min_position_limit(double value);

  // optional double units = 8;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 8;
  inline double units() const;
  inline void set_units(double value);

  // optional int32 home_sequence = 9;
  inline bool has_home_sequence() const;
  inline void clear_home_sequence();
  static const int kHomeSequenceFieldNumber = 9;
  inline ::google::protobuf::int32 home_sequence() const;
  inline void set_home_sequence(::google::protobuf::int32 value);

  // optional double max_acceleration = 10;
  inline bool has_max_acceleration() const;
  inline void clear_max_acceleration();
  static const int kMaxAccelerationFieldNumber = 10;
  inline double max_acceleration() const;
  inline void set_max_acceleration(double value);

  // optional double max_velocity = 11;
  inline bool has_max_velocity() const;
  inline void clear_max_velocity();
  static const int kMaxVelocityFieldNumber = 11;
  inline double max_velocity() const;
  inline void set_max_velocity(double value);

  // optional string increments = 12;
  inline bool has_increments() const;
  inline void clear_increments();
  static const int kIncrementsFieldNumber = 12;
  inline const ::std::string& increments() const;
  inline void set_increments(const ::std::string& value);
  inline void set_increments(const char* value);
  inline void set_increments(const char* value, size_t size);
  inline ::std::string* mutable_increments();
  inline ::std::string* release_increments();
  inline void set_allocated_increments(::std::string* increments);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusConfigAxis)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_axistype();
  inline void clear_has_axistype();
  inline void set_has_backlash();
  inline void clear_has_backlash();
  inline void set_has_max_ferror();
  inline void clear_has_max_ferror();
  inline void set_has_max_position_limit();
  inline void clear_has_max_position_limit();
  inline void set_has_min_ferror();
  inline void clear_has_min_ferror();
  inline void set_has_min_position_limit();
  inline void clear_has_min_position_limit();
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_home_sequence();
  inline void clear_has_home_sequence();
  inline void set_has_max_acceleration();
  inline void clear_has_max_acceleration();
  inline void set_has_max_velocity();
  inline void clear_has_max_velocity();
  inline void set_has_increments();
  inline void clear_has_increments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  int axistype_;
  double backlash_;
  double max_ferror_;
  double max_position_limit_;
  double min_ferror_;
  double min_position_limit_;
  double units_;
  double max_acceleration_;
  double max_velocity_;
  ::std::string* increments_;
  ::google::protobuf::int32 home_sequence_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusConfigAxis* default_instance_;
};
// -------------------------------------------------------------------

class EmcProgramExtension : public ::google::protobuf::Message {
 public:
  EmcProgramExtension();
  virtual ~EmcProgramExtension();

  EmcProgramExtension(const EmcProgramExtension& from);

  inline EmcProgramExtension& operator=(const EmcProgramExtension& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcProgramExtension& default_instance();

  void Swap(EmcProgramExtension* other);

  // implements Message ----------------------------------------------

  EmcProgramExtension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcProgramExtension& from);
  void MergeFrom(const EmcProgramExtension& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string extension = 2;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 2;
  inline const ::std::string& extension() const;
  inline void set_extension(const ::std::string& value);
  inline void set_extension(const char* value);
  inline void set_extension(const char* value, size_t size);
  inline ::std::string* mutable_extension();
  inline ::std::string* release_extension();
  inline void set_allocated_extension(::std::string* extension);

  // @@protoc_insertion_point(class_scope:pb.EmcProgramExtension)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_extension();
  inline void clear_has_extension();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* extension_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcProgramExtension* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusAnalogIO : public ::google::protobuf::Message {
 public:
  EmcStatusAnalogIO();
  virtual ~EmcStatusAnalogIO();

  EmcStatusAnalogIO(const EmcStatusAnalogIO& from);

  inline EmcStatusAnalogIO& operator=(const EmcStatusAnalogIO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusAnalogIO& default_instance();

  void Swap(EmcStatusAnalogIO* other);

  // implements Message ----------------------------------------------

  EmcStatusAnalogIO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusAnalogIO& from);
  void MergeFrom(const EmcStatusAnalogIO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusAnalogIO)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double value_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusAnalogIO* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusDigitalIO : public ::google::protobuf::Message {
 public:
  EmcStatusDigitalIO();
  virtual ~EmcStatusDigitalIO();

  EmcStatusDigitalIO(const EmcStatusDigitalIO& from);

  inline EmcStatusDigitalIO& operator=(const EmcStatusDigitalIO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusDigitalIO& default_instance();

  void Swap(EmcStatusDigitalIO* other);

  // implements Message ----------------------------------------------

  EmcStatusDigitalIO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusDigitalIO& from);
  void MergeFrom(const EmcStatusDigitalIO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusDigitalIO)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  bool value_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusDigitalIO* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusLimit : public ::google::protobuf::Message {
 public:
  EmcStatusLimit();
  virtual ~EmcStatusLimit();

  EmcStatusLimit(const EmcStatusLimit& from);

  inline EmcStatusLimit& operator=(const EmcStatusLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusLimit& default_instance();

  void Swap(EmcStatusLimit* other);

  // implements Message ----------------------------------------------

  EmcStatusLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusLimit& from);
  void MergeFrom(const EmcStatusLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusLimit)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusLimit* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusGCode : public ::google::protobuf::Message {
 public:
  EmcStatusGCode();
  virtual ~EmcStatusGCode();

  EmcStatusGCode(const EmcStatusGCode& from);

  inline EmcStatusGCode& operator=(const EmcStatusGCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusGCode& default_instance();

  void Swap(EmcStatusGCode* other);

  // implements Message ----------------------------------------------

  EmcStatusGCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusGCode& from);
  void MergeFrom(const EmcStatusGCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusGCode)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusGCode* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusMCode : public ::google::protobuf::Message {
 public:
  EmcStatusMCode();
  virtual ~EmcStatusMCode();

  EmcStatusMCode(const EmcStatusMCode& from);

  inline EmcStatusMCode& operator=(const EmcStatusMCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusMCode& default_instance();

  void Swap(EmcStatusMCode* other);

  // implements Message ----------------------------------------------

  EmcStatusMCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusMCode& from);
  void MergeFrom(const EmcStatusMCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusMCode)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusMCode* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusSetting : public ::google::protobuf::Message {
 public:
  EmcStatusSetting();
  virtual ~EmcStatusSetting();

  EmcStatusSetting(const EmcStatusSetting& from);

  inline EmcStatusSetting& operator=(const EmcStatusSetting& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusSetting& default_instance();

  void Swap(EmcStatusSetting* other);

  // implements Message ----------------------------------------------

  EmcStatusSetting* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusSetting& from);
  void MergeFrom(const EmcStatusSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusSetting)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double value_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusSetting* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusConfig : public ::google::protobuf::Message {
 public:
  EmcStatusConfig();
  virtual ~EmcStatusConfig();

  EmcStatusConfig(const EmcStatusConfig& from);

  inline EmcStatusConfig& operator=(const EmcStatusConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusConfig& default_instance();

  void Swap(EmcStatusConfig* other);

  // implements Message ----------------------------------------------

  EmcStatusConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusConfig& from);
  void MergeFrom(const EmcStatusConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double default_acceleration = 1;
  inline bool has_default_acceleration() const;
  inline void clear_default_acceleration();
  static const int kDefaultAccelerationFieldNumber = 1;
  inline double default_acceleration() const;
  inline void set_default_acceleration(double value);

  // optional double angular_units = 2;
  inline bool has_angular_units() const;
  inline void clear_angular_units();
  static const int kAngularUnitsFieldNumber = 2;
  inline double angular_units() const;
  inline void set_angular_units(double value);

  // optional int32 axes = 3;
  inline bool has_axes() const;
  inline void clear_axes();
  static const int kAxesFieldNumber = 3;
  inline ::google::protobuf::int32 axes() const;
  inline void set_axes(::google::protobuf::int32 value);

  // repeated .pb.EmcStatusConfigAxis axis = 4;
  inline int axis_size() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 4;
  inline const ::pb::EmcStatusConfigAxis& axis(int index) const;
  inline ::pb::EmcStatusConfigAxis* mutable_axis(int index);
  inline ::pb::EmcStatusConfigAxis* add_axis();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusConfigAxis >&
      axis() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusConfigAxis >*
      mutable_axis();

  // optional int32 axis_mask = 5;
  inline bool has_axis_mask() const;
  inline void clear_axis_mask();
  static const int kAxisMaskFieldNumber = 5;
  inline ::google::protobuf::int32 axis_mask() const;
  inline void set_axis_mask(::google::protobuf::int32 value);

  // optional double cycle_time = 6;
  inline bool has_cycle_time() const;
  inline void clear_cycle_time();
  static const int kCycleTimeFieldNumber = 6;
  inline double cycle_time() const;
  inline void set_cycle_time(double value);

  // optional int32 debug = 7;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 7;
  inline ::google::protobuf::int32 debug() const;
  inline void set_debug(::google::protobuf::int32 value);

  // optional .pb.EmcKinematicsType kinematics_type = 8;
  inline bool has_kinematics_type() const;
  inline void clear_kinematics_type();
  static const int kKinematicsTypeFieldNumber = 8;
  inline ::pb::EmcKinematicsType kinematics_type() const;
  inline void set_kinematics_type(::pb::EmcKinematicsType value);

  // optional double linear_units = 9;
  inline bool has_linear_units() const;
  inline void clear_linear_units();
  static const int kLinearUnitsFieldNumber = 9;
  inline double linear_units() const;
  inline void set_linear_units(double value);

  // optional double max_acceleration = 10;
  inline bool has_max_acceleration() const;
  inline void clear_max_acceleration();
  static const int kMaxAccelerationFieldNumber = 10;
  inline double max_acceleration() const;
  inline void set_max_acceleration(double value);

  // optional double max_velocity = 11;
  inline bool has_max_velocity() const;
  inline void clear_max_velocity();
  static const int kMaxVelocityFieldNumber = 11;
  inline double max_velocity() const;
  inline void set_max_velocity(double value);

  // optional .pb.EmcCanonUnitsType program_units = 12;
  inline bool has_program_units() const;
  inline void clear_program_units();
  static const int kProgramUnitsFieldNumber = 12;
  inline ::pb::EmcCanonUnitsType program_units() const;
  inline void set_program_units(::pb::EmcCanonUnitsType value);

  // optional double default_velocity = 13;
  inline bool has_default_velocity() const;
  inline void clear_default_velocity();
  static const int kDefaultVelocityFieldNumber = 13;
  inline double default_velocity() const;
  inline void set_default_velocity(double value);

  // repeated .pb.EmcProgramExtension program_extension = 14;
  inline int program_extension_size() const;
  inline void clear_program_extension();
  static const int kProgramExtensionFieldNumber = 14;
  inline const ::pb::EmcProgramExtension& program_extension(int index) const;
  inline ::pb::EmcProgramExtension* mutable_program_extension(int index);
  inline ::pb::EmcProgramExtension* add_program_extension();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcProgramExtension >&
      program_extension() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcProgramExtension >*
      mutable_program_extension();

  // optional .pb.EmcPositionOffsetType position_offset = 15;
  inline bool has_position_offset() const;
  inline void clear_position_offset();
  static const int kPositionOffsetFieldNumber = 15;
  inline ::pb::EmcPositionOffsetType position_offset() const;
  inline void set_position_offset(::pb::EmcPositionOffsetType value);

  // optional .pb.EmcPositionFeedbackType position_feedback = 16;
  inline bool has_position_feedback() const;
  inline void clear_position_feedback();
  static const int kPositionFeedbackFieldNumber = 16;
  inline ::pb::EmcPositionFeedbackType position_feedback() const;
  inline void set_position_feedback(::pb::EmcPositionFeedbackType value);

  // optional double max_feed_override = 17;
  inline bool has_max_feed_override() const;
  inline void clear_max_feed_override();
  static const int kMaxFeedOverrideFieldNumber = 17;
  inline double max_feed_override() const;
  inline void set_max_feed_override(double value);

  // optional double min_feed_override = 18;
  inline bool has_min_feed_override() const;
  inline void clear_min_feed_override();
  static const int kMinFeedOverrideFieldNumber = 18;
  inline double min_feed_override() const;
  inline void set_min_feed_override(double value);

  // optional double max_spindle_override = 19;
  inline bool has_max_spindle_override() const;
  inline void clear_max_spindle_override();
  static const int kMaxSpindleOverrideFieldNumber = 19;
  inline double max_spindle_override() const;
  inline void set_max_spindle_override(double value);

  // optional double min_spindle_override = 20;
  inline bool has_min_spindle_override() const;
  inline void clear_min_spindle_override();
  static const int kMinSpindleOverrideFieldNumber = 20;
  inline double min_spindle_override() const;
  inline void set_min_spindle_override(double value);

  // optional double default_spindle_speed = 21;
  inline bool has_default_spindle_speed() const;
  inline void clear_default_spindle_speed();
  static const int kDefaultSpindleSpeedFieldNumber = 21;
  inline double default_spindle_speed() const;
  inline void set_default_spindle_speed(double value);

  // optional double default_linear_velocity = 22;
  inline bool has_default_linear_velocity() const;
  inline void clear_default_linear_velocity();
  static const int kDefaultLinearVelocityFieldNumber = 22;
  inline double default_linear_velocity() const;
  inline void set_default_linear_velocity(double value);

  // optional double min_velocity = 23;
  inline bool has_min_velocity() const;
  inline void clear_min_velocity();
  static const int kMinVelocityFieldNumber = 23;
  inline double min_velocity() const;
  inline void set_min_velocity(double value);

  // optional double max_linear_velocity = 24;
  inline bool has_max_linear_velocity() const;
  inline void clear_max_linear_velocity();
  static const int kMaxLinearVelocityFieldNumber = 24;
  inline double max_linear_velocity() const;
  inline void set_max_linear_velocity(double value);

  // optional double min_linear_velocity = 25;
  inline bool has_min_linear_velocity() const;
  inline void clear_min_linear_velocity();
  static const int kMinLinearVelocityFieldNumber = 25;
  inline double min_linear_velocity() const;
  inline void set_min_linear_velocity(double value);

  // optional double default_angular_velocity = 26;
  inline bool has_default_angular_velocity() const;
  inline void clear_default_angular_velocity();
  static const int kDefaultAngularVelocityFieldNumber = 26;
  inline double default_angular_velocity() const;
  inline void set_default_angular_velocity(double value);

  // optional double max_angular_velocity = 27;
  inline bool has_max_angular_velocity() const;
  inline void clear_max_angular_velocity();
  static const int kMaxAngularVelocityFieldNumber = 27;
  inline double max_angular_velocity() const;
  inline void set_max_angular_velocity(double value);

  // optional double min_angular_velocity = 28;
  inline bool has_min_angular_velocity() const;
  inline void clear_min_angular_velocity();
  static const int kMinAngularVelocityFieldNumber = 28;
  inline double min_angular_velocity() const;
  inline void set_min_angular_velocity(double value);

  // optional string increments = 29;
  inline bool has_increments() const;
  inline void clear_increments();
  static const int kIncrementsFieldNumber = 29;
  inline const ::std::string& increments() const;
  inline void set_increments(const ::std::string& value);
  inline void set_increments(const char* value);
  inline void set_increments(const char* value, size_t size);
  inline ::std::string* mutable_increments();
  inline ::std::string* release_increments();
  inline void set_allocated_increments(::std::string* increments);

  // optional string grids = 30;
  inline bool has_grids() const;
  inline void clear_grids();
  static const int kGridsFieldNumber = 30;
  inline const ::std::string& grids() const;
  inline void set_grids(const ::std::string& value);
  inline void set_grids(const char* value);
  inline void set_grids(const char* value, size_t size);
  inline ::std::string* mutable_grids();
  inline ::std::string* release_grids();
  inline void set_allocated_grids(::std::string* grids);

  // optional bool lathe = 31;
  inline bool has_lathe() const;
  inline void clear_lathe();
  static const int kLatheFieldNumber = 31;
  inline bool lathe() const;
  inline void set_lathe(bool value);

  // optional string geometry = 32;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 32;
  inline const ::std::string& geometry() const;
  inline void set_geometry(const ::std::string& value);
  inline void set_geometry(const char* value);
  inline void set_geometry(const char* value, size_t size);
  inline ::std::string* mutable_geometry();
  inline ::std::string* release_geometry();
  inline void set_allocated_geometry(::std::string* geometry);

  // optional uint32 arcdivision = 33;
  inline bool has_arcdivision() const;
  inline void clear_arcdivision();
  static const int kArcdivisionFieldNumber = 33;
  inline ::google::protobuf::uint32 arcdivision() const;
  inline void set_arcdivision(::google::protobuf::uint32 value);

  // optional bool no_force_homing = 34;
  inline bool has_no_force_homing() const;
  inline void clear_no_force_homing();
  static const int kNoForceHomingFieldNumber = 34;
  inline bool no_force_homing() const;
  inline void set_no_force_homing(bool value);

  // optional string remote_path = 35;
  inline bool has_remote_path() const;
  inline void clear_remote_path();
  static const int kRemotePathFieldNumber = 35;
  inline const ::std::string& remote_path() const;
  inline void set_remote_path(const ::std::string& value);
  inline void set_remote_path(const char* value);
  inline void set_remote_path(const char* value, size_t size);
  inline ::std::string* mutable_remote_path();
  inline ::std::string* release_remote_path();
  inline void set_allocated_remote_path(::std::string* remote_path);

  // optional .pb.EmcTimeUnitsType time_units = 36;
  inline bool has_time_units() const;
  inline void clear_time_units();
  static const int kTimeUnitsFieldNumber = 36;
  inline ::pb::EmcTimeUnitsType time_units() const;
  inline void set_time_units(::pb::EmcTimeUnitsType value);

  // optional string name = 37;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 37;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .pb.EmcStatusUserCommand user_command = 38;
  inline int user_command_size() const;
  inline void clear_user_command();
  static const int kUserCommandFieldNumber = 38;
  inline const ::pb::EmcStatusUserCommand& user_command(int index) const;
  inline ::pb::EmcStatusUserCommand* mutable_user_command(int index);
  inline ::pb::EmcStatusUserCommand* add_user_command();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusUserCommand >&
      user_command() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusUserCommand >*
      mutable_user_command();

  // @@protoc_insertion_point(class_scope:pb.EmcStatusConfig)
 private:
  inline void set_has_default_acceleration();
  inline void clear_has_default_acceleration();
  inline void set_has_angular_units();
  inline void clear_has_angular_units();
  inline void set_has_axes();
  inline void clear_has_axes();
  inline void set_has_axis_mask();
  inline void clear_has_axis_mask();
  inline void set_has_cycle_time();
  inline void clear_has_cycle_time();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_kinematics_type();
  inline void clear_has_kinematics_type();
  inline void set_has_linear_units();
  inline void clear_has_linear_units();
  inline void set_has_max_acceleration();
  inline void clear_has_max_acceleration();
  inline void set_has_max_velocity();
  inline void clear_has_max_velocity();
  inline void set_has_program_units();
  inline void clear_has_program_units();
  inline void set_has_default_velocity();
  inline void clear_has_default_velocity();
  inline void set_has_position_offset();
  inline void clear_has_position_offset();
  inline void set_has_position_feedback();
  inline void clear_has_position_feedback();
  inline void set_has_max_feed_override();
  inline void clear_has_max_feed_override();
  inline void set_has_min_feed_override();
  inline void clear_has_min_feed_override();
  inline void set_has_max_spindle_override();
  inline void clear_has_max_spindle_override();
  inline void set_has_min_spindle_override();
  inline void clear_has_min_spindle_override();
  inline void set_has_default_spindle_speed();
  inline void clear_has_default_spindle_speed();
  inline void set_has_default_linear_velocity();
  inline void clear_has_default_linear_velocity();
  inline void set_has_min_velocity();
  inline void clear_has_min_velocity();
  inline void set_has_max_linear_velocity();
  inline void clear_has_max_linear_velocity();
  inline void set_has_min_linear_velocity();
  inline void clear_has_min_linear_velocity();
  inline void set_has_default_angular_velocity();
  inline void clear_has_default_angular_velocity();
  inline void set_has_max_angular_velocity();
  inline void clear_has_max_angular_velocity();
  inline void set_has_min_angular_velocity();
  inline void clear_has_min_angular_velocity();
  inline void set_has_increments();
  inline void clear_has_increments();
  inline void set_has_grids();
  inline void clear_has_grids();
  inline void set_has_lathe();
  inline void clear_has_lathe();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_arcdivision();
  inline void clear_has_arcdivision();
  inline void set_has_no_force_homing();
  inline void clear_has_no_force_homing();
  inline void set_has_remote_path();
  inline void clear_has_remote_path();
  inline void set_has_time_units();
  inline void clear_has_time_units();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  double default_acceleration_;
  double angular_units_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusConfigAxis > axis_;
  ::google::protobuf::int32 axes_;
  ::google::protobuf::int32 axis_mask_;
  double cycle_time_;
  ::google::protobuf::int32 debug_;
  int kinematics_type_;
  double linear_units_;
  double max_acceleration_;
  double max_velocity_;
  double default_velocity_;
  int program_units_;
  int position_offset_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcProgramExtension > program_extension_;
  double max_feed_override_;
  double min_feed_override_;
  double max_spindle_override_;
  double min_spindle_override_;
  double default_spindle_speed_;
  double default_linear_velocity_;
  double min_velocity_;
  double max_linear_velocity_;
  double min_linear_velocity_;
  double default_angular_velocity_;
  double max_angular_velocity_;
  int position_feedback_;
  bool lathe_;
  bool no_force_homing_;
  double min_angular_velocity_;
  ::std::string* increments_;
  ::std::string* grids_;
  ::std::string* geometry_;
  ::google::protobuf::uint32 arcdivision_;
  int time_units_;
  ::std::string* remote_path_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusUserCommand > user_command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusConfig* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusMotion : public ::google::protobuf::Message {
 public:
  EmcStatusMotion();
  virtual ~EmcStatusMotion();

  EmcStatusMotion(const EmcStatusMotion& from);

  inline EmcStatusMotion& operator=(const EmcStatusMotion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusMotion& default_instance();

  void Swap(EmcStatusMotion* other);

  // implements Message ----------------------------------------------

  EmcStatusMotion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusMotion& from);
  void MergeFrom(const EmcStatusMotion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 active_queue = 1;
  inline bool has_active_queue() const;
  inline void clear_active_queue();
  static const int kActiveQueueFieldNumber = 1;
  inline ::google::protobuf::int32 active_queue() const;
  inline void set_active_queue(::google::protobuf::int32 value);

  // optional .pb.Position actual_position = 2;
  inline bool has_actual_position() const;
  inline void clear_actual_position();
  static const int kActualPositionFieldNumber = 2;
  inline const ::pb::Position& actual_position() const;
  inline ::pb::Position* mutable_actual_position();
  inline ::pb::Position* release_actual_position();
  inline void set_allocated_actual_position(::pb::Position* actual_position);

  // optional bool adaptive_feed_enabled = 3;
  inline bool has_adaptive_feed_enabled() const;
  inline void clear_adaptive_feed_enabled();
  static const int kAdaptiveFeedEnabledFieldNumber = 3;
  inline bool adaptive_feed_enabled() const;
  inline void set_adaptive_feed_enabled(bool value);

  // repeated .pb.EmcStatusAnalogIO ain = 4;
  inline int ain_size() const;
  inline void clear_ain();
  static const int kAinFieldNumber = 4;
  inline const ::pb::EmcStatusAnalogIO& ain(int index) const;
  inline ::pb::EmcStatusAnalogIO* mutable_ain(int index);
  inline ::pb::EmcStatusAnalogIO* add_ain();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >&
      ain() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >*
      mutable_ain();

  // repeated .pb.EmcStatusAnalogIO aout = 5;
  inline int aout_size() const;
  inline void clear_aout();
  static const int kAoutFieldNumber = 5;
  inline const ::pb::EmcStatusAnalogIO& aout(int index) const;
  inline ::pb::EmcStatusAnalogIO* mutable_aout(int index);
  inline ::pb::EmcStatusAnalogIO* add_aout();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >&
      aout() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >*
      mutable_aout();

  // repeated .pb.EmcStatusMotionAxis axis = 6;
  inline int axis_size() const;
  inline void clear_axis();
  static const int kAxisFieldNumber = 6;
  inline const ::pb::EmcStatusMotionAxis& axis(int index) const;
  inline ::pb::EmcStatusMotionAxis* mutable_axis(int index);
  inline ::pb::EmcStatusMotionAxis* add_axis();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMotionAxis >&
      axis() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMotionAxis >*
      mutable_axis();

  // optional bool block_delete = 7;
  inline bool has_block_delete() const;
  inline void clear_block_delete();
  static const int kBlockDeleteFieldNumber = 7;
  inline bool block_delete() const;
  inline void set_block_delete(bool value);

  // optional int32 current_line = 8;
  inline bool has_current_line() const;
  inline void clear_current_line();
  static const int kCurrentLineFieldNumber = 8;
  inline ::google::protobuf::int32 current_line() const;
  inline void set_current_line(::google::protobuf::int32 value);

  // optional double current_vel = 9;
  inline bool has_current_vel() const;
  inline void clear_current_vel();
  static const int kCurrentVelFieldNumber = 9;
  inline double current_vel() const;
  inline void set_current_vel(double value);

  // optional double delay_left = 10;
  inline bool has_delay_left() const;
  inline void clear_delay_left();
  static const int kDelayLeftFieldNumber = 10;
  inline double delay_left() const;
  inline void set_delay_left(double value);

  // repeated .pb.EmcStatusDigitalIO din = 11;
  inline int din_size() const;
  inline void clear_din();
  static const int kDinFieldNumber = 11;
  inline const ::pb::EmcStatusDigitalIO& din(int index) const;
  inline ::pb::EmcStatusDigitalIO* mutable_din(int index);
  inline ::pb::EmcStatusDigitalIO* add_din();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >&
      din() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >*
      mutable_din();

  // optional double distance_to_go = 12;
  inline bool has_distance_to_go() const;
  inline void clear_distance_to_go();
  static const int kDistanceToGoFieldNumber = 12;
  inline double distance_to_go() const;
  inline void set_distance_to_go(double value);

  // repeated .pb.EmcStatusDigitalIO dout = 13;
  inline int dout_size() const;
  inline void clear_dout();
  static const int kDoutFieldNumber = 13;
  inline const ::pb::EmcStatusDigitalIO& dout(int index) const;
  inline ::pb::EmcStatusDigitalIO* mutable_dout(int index);
  inline ::pb::EmcStatusDigitalIO* add_dout();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >&
      dout() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >*
      mutable_dout();

  // optional .pb.Position dtg = 14;
  inline bool has_dtg() const;
  inline void clear_dtg();
  static const int kDtgFieldNumber = 14;
  inline const ::pb::Position& dtg() const;
  inline ::pb::Position* mutable_dtg();
  inline ::pb::Position* release_dtg();
  inline void set_allocated_dtg(::pb::Position* dtg);

  // optional bool enabled = 15;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 15;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool feed_hold_enabled = 16;
  inline bool has_feed_hold_enabled() const;
  inline void clear_feed_hold_enabled();
  static const int kFeedHoldEnabledFieldNumber = 16;
  inline bool feed_hold_enabled() const;
  inline void set_feed_hold_enabled(bool value);

  // optional bool feed_override_enabled = 17;
  inline bool has_feed_override_enabled() const;
  inline void clear_feed_override_enabled();
  static const int kFeedOverrideEnabledFieldNumber = 17;
  inline bool feed_override_enabled() const;
  inline void set_feed_override_enabled(bool value);

  // optional double feedrate = 18;
  inline bool has_feedrate() const;
  inline void clear_feedrate();
  static const int kFeedrateFieldNumber = 18;
  inline double feedrate() const;
  inline void set_feedrate(double value);

  // optional .pb.OriginIndex g5x_index = 19;
  inline bool has_g5x_index() const;
  inline void clear_g5x_index();
  static const int kG5XIndexFieldNumber = 19;
  inline ::pb::OriginIndex g5x_index() const;
  inline void set_g5x_index(::pb::OriginIndex value);

  // optional .pb.Position g5x_offset = 20;
  inline bool has_g5x_offset() const;
  inline void clear_g5x_offset();
  static const int kG5XOffsetFieldNumber = 20;
  inline const ::pb::Position& g5x_offset() const;
  inline ::pb::Position* mutable_g5x_offset();
  inline ::pb::Position* release_g5x_offset();
  inline void set_allocated_g5x_offset(::pb::Position* g5x_offset);

  // optional .pb.Position g92_offset = 21;
  inline bool has_g92_offset() const;
  inline void clear_g92_offset();
  static const int kG92OffsetFieldNumber = 21;
  inline const ::pb::Position& g92_offset() const;
  inline ::pb::Position* mutable_g92_offset();
  inline ::pb::Position* release_g92_offset();
  inline void set_allocated_g92_offset(::pb::Position* g92_offset);

  // optional int32 id = 23;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 23;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bool inpos = 24;
  inline bool has_inpos() const;
  inline void clear_inpos();
  static const int kInposFieldNumber = 24;
  inline bool inpos() const;
  inline void set_inpos(bool value);

  // optional .pb.Position joint_actual_position = 25;
  inline bool has_joint_actual_position() const;
  inline void clear_joint_actual_position();
  static const int kJointActualPositionFieldNumber = 25;
  inline const ::pb::Position& joint_actual_position() const;
  inline ::pb::Position* mutable_joint_actual_position();
  inline ::pb::Position* release_joint_actual_position();
  inline void set_allocated_joint_actual_position(::pb::Position* joint_actual_position);

  // optional .pb.Position joint_position = 26;
  inline bool has_joint_position() const;
  inline void clear_joint_position();
  static const int kJointPositionFieldNumber = 26;
  inline const ::pb::Position& joint_position() const;
  inline ::pb::Position* mutable_joint_position();
  inline ::pb::Position* release_joint_position();
  inline void set_allocated_joint_position(::pb::Position* joint_position);

  // repeated .pb.EmcStatusLimit limit = 27;
  inline int limit_size() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 27;
  inline const ::pb::EmcStatusLimit& limit(int index) const;
  inline ::pb::EmcStatusLimit* mutable_limit(int index);
  inline ::pb::EmcStatusLimit* add_limit();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusLimit >&
      limit() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusLimit >*
      mutable_limit();

  // optional int32 motion_line = 28;
  inline bool has_motion_line() const;
  inline void clear_motion_line();
  static const int kMotionLineFieldNumber = 28;
  inline ::google::protobuf::int32 motion_line() const;
  inline void set_motion_line(::google::protobuf::int32 value);

  // optional .pb.MotionType motion_type = 29;
  inline bool has_motion_type() const;
  inline void clear_motion_type();
  static const int kMotionTypeFieldNumber = 29;
  inline ::pb::MotionType motion_type() const;
  inline void set_motion_type(::pb::MotionType value);

  // optional .pb.EmcTrajectoryModeType motion_mode = 30;
  inline bool has_motion_mode() const;
  inline void clear_motion_mode();
  static const int kMotionModeFieldNumber = 30;
  inline ::pb::EmcTrajectoryModeType motion_mode() const;
  inline void set_motion_mode(::pb::EmcTrajectoryModeType value);

  // optional bool paused = 31;
  inline bool has_paused() const;
  inline void clear_paused();
  static const int kPausedFieldNumber = 31;
  inline bool paused() const;
  inline void set_paused(bool value);

  // optional .pb.Position position = 32;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 32;
  inline const ::pb::Position& position() const;
  inline ::pb::Position* mutable_position();
  inline ::pb::Position* release_position();
  inline void set_allocated_position(::pb::Position* position);

  // optional bool probe_tripped = 33;
  inline bool has_probe_tripped() const;
  inline void clear_probe_tripped();
  static const int kProbeTrippedFieldNumber = 33;
  inline bool probe_tripped() const;
  inline void set_probe_tripped(bool value);

  // optional int32 probe_val = 34;
  inline bool has_probe_val() const;
  inline void clear_probe_val();
  static const int kProbeValFieldNumber = 34;
  inline ::google::protobuf::int32 probe_val() const;
  inline void set_probe_val(::google::protobuf::int32 value);

  // optional .pb.Position probed_position = 35;
  inline bool has_probed_position() const;
  inline void clear_probed_position();
  static const int kProbedPositionFieldNumber = 35;
  inline const ::pb::Position& probed_position() const;
  inline ::pb::Position* mutable_probed_position();
  inline ::pb::Position* release_probed_position();
  inline void set_allocated_probed_position(::pb::Position* probed_position);

  // optional bool probing = 36;
  inline bool has_probing() const;
  inline void clear_probing();
  static const int kProbingFieldNumber = 36;
  inline bool probing() const;
  inline void set_probing(bool value);

  // optional int32 queue = 37;
  inline bool has_queue() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 37;
  inline ::google::protobuf::int32 queue() const;
  inline void set_queue(::google::protobuf::int32 value);

  // optional bool queue_full = 38;
  inline bool has_queue_full() const;
  inline void clear_queue_full();
  static const int kQueueFullFieldNumber = 38;
  inline bool queue_full() const;
  inline void set_queue_full(bool value);

  // optional double rotation_xy = 39;
  inline bool has_rotation_xy() const;
  inline void clear_rotation_xy();
  static const int kRotationXyFieldNumber = 39;
  inline double rotation_xy() const;
  inline void set_rotation_xy(double value);

  // optional bool spindle_brake = 40;
  inline bool has_spindle_brake() const;
  inline void clear_spindle_brake();
  static const int kSpindleBrakeFieldNumber = 40;
  inline bool spindle_brake() const;
  inline void set_spindle_brake(bool value);

  // optional int32 spindle_direction = 41;
  inline bool has_spindle_direction() const;
  inline void clear_spindle_direction();
  static const int kSpindleDirectionFieldNumber = 41;
  inline ::google::protobuf::int32 spindle_direction() const;
  inline void set_spindle_direction(::google::protobuf::int32 value);

  // optional bool spindle_enabled = 42;
  inline bool has_spindle_enabled() const;
  inline void clear_spindle_enabled();
  static const int kSpindleEnabledFieldNumber = 42;
  inline bool spindle_enabled() const;
  inline void set_spindle_enabled(bool value);

  // optional int32 spindle_increasing = 43;
  inline bool has_spindle_increasing() const;
  inline void clear_spindle_increasing();
  static const int kSpindleIncreasingFieldNumber = 43;
  inline ::google::protobuf::int32 spindle_increasing() const;
  inline void set_spindle_increasing(::google::protobuf::int32 value);

  // optional bool spindle_override_enabled = 44;
  inline bool has_spindle_override_enabled() const;
  inline void clear_spindle_override_enabled();
  static const int kSpindleOverrideEnabledFieldNumber = 44;
  inline bool spindle_override_enabled() const;
  inline void set_spindle_override_enabled(bool value);

  // optional double spindle_speed = 45;
  inline bool has_spindle_speed() const;
  inline void clear_spindle_speed();
  static const int kSpindleSpeedFieldNumber = 45;
  inline double spindle_speed() const;
  inline void set_spindle_speed(double value);

  // optional double spindlerate = 46;
  inline bool has_spindlerate() const;
  inline void clear_spindlerate();
  static const int kSpindlerateFieldNumber = 46;
  inline double spindlerate() const;
  inline void set_spindlerate(double value);

  // optional .pb.RCS_STATUS state = 47;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 47;
  inline ::pb::RCS_STATUS state() const;
  inline void set_state(::pb::RCS_STATUS value);

  // optional double max_velocity = 48;
  inline bool has_max_velocity() const;
  inline void clear_max_velocity();
  static const int kMaxVelocityFieldNumber = 48;
  inline double max_velocity() const;
  inline void set_max_velocity(double value);

  // optional double max_acceleration = 49;
  inline bool has_max_acceleration() const;
  inline void clear_max_acceleration();
  static const int kMaxAccelerationFieldNumber = 49;
  inline double max_acceleration() const;
  inline void set_max_acceleration(double value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusMotion)
 private:
  inline void set_has_active_queue();
  inline void clear_has_active_queue();
  inline void set_has_actual_position();
  inline void clear_has_actual_position();
  inline void set_has_adaptive_feed_enabled();
  inline void clear_has_adaptive_feed_enabled();
  inline void set_has_block_delete();
  inline void clear_has_block_delete();
  inline void set_has_current_line();
  inline void clear_has_current_line();
  inline void set_has_current_vel();
  inline void clear_has_current_vel();
  inline void set_has_delay_left();
  inline void clear_has_delay_left();
  inline void set_has_distance_to_go();
  inline void clear_has_distance_to_go();
  inline void set_has_dtg();
  inline void clear_has_dtg();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_feed_hold_enabled();
  inline void clear_has_feed_hold_enabled();
  inline void set_has_feed_override_enabled();
  inline void clear_has_feed_override_enabled();
  inline void set_has_feedrate();
  inline void clear_has_feedrate();
  inline void set_has_g5x_index();
  inline void clear_has_g5x_index();
  inline void set_has_g5x_offset();
  inline void clear_has_g5x_offset();
  inline void set_has_g92_offset();
  inline void clear_has_g92_offset();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_inpos();
  inline void clear_has_inpos();
  inline void set_has_joint_actual_position();
  inline void clear_has_joint_actual_position();
  inline void set_has_joint_position();
  inline void clear_has_joint_position();
  inline void set_has_motion_line();
  inline void clear_has_motion_line();
  inline void set_has_motion_type();
  inline void clear_has_motion_type();
  inline void set_has_motion_mode();
  inline void clear_has_motion_mode();
  inline void set_has_paused();
  inline void clear_has_paused();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_probe_tripped();
  inline void clear_has_probe_tripped();
  inline void set_has_probe_val();
  inline void clear_has_probe_val();
  inline void set_has_probed_position();
  inline void clear_has_probed_position();
  inline void set_has_probing();
  inline void clear_has_probing();
  inline void set_has_queue();
  inline void clear_has_queue();
  inline void set_has_queue_full();
  inline void clear_has_queue_full();
  inline void set_has_rotation_xy();
  inline void clear_has_rotation_xy();
  inline void set_has_spindle_brake();
  inline void clear_has_spindle_brake();
  inline void set_has_spindle_direction();
  inline void clear_has_spindle_direction();
  inline void set_has_spindle_enabled();
  inline void clear_has_spindle_enabled();
  inline void set_has_spindle_increasing();
  inline void clear_has_spindle_increasing();
  inline void set_has_spindle_override_enabled();
  inline void clear_has_spindle_override_enabled();
  inline void set_has_spindle_speed();
  inline void clear_has_spindle_speed();
  inline void set_has_spindlerate();
  inline void clear_has_spindlerate();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_max_velocity();
  inline void clear_has_max_velocity();
  inline void set_has_max_acceleration();
  inline void clear_has_max_acceleration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::pb::Position* actual_position_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO > ain_;
  ::google::protobuf::int32 active_queue_;
  ::google::protobuf::int32 current_line_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO > aout_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMotionAxis > axis_;
  double current_vel_;
  double delay_left_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO > din_;
  double distance_to_go_;
  bool adaptive_feed_enabled_;
  bool block_delete_;
  bool enabled_;
  bool feed_hold_enabled_;
  int g5x_index_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO > dout_;
  ::pb::Position* dtg_;
  double feedrate_;
  ::pb::Position* g5x_offset_;
  ::pb::Position* g92_offset_;
  ::pb::Position* joint_actual_position_;
  ::google::protobuf::int32 id_;
  bool feed_override_enabled_;
  bool inpos_;
  bool paused_;
  bool probe_tripped_;
  ::pb::Position* joint_position_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusLimit > limit_;
  ::google::protobuf::int32 motion_line_;
  int motion_type_;
  ::pb::Position* position_;
  int motion_mode_;
  ::google::protobuf::int32 probe_val_;
  ::pb::Position* probed_position_;
  ::google::protobuf::int32 queue_;
  bool probing_;
  bool queue_full_;
  bool spindle_brake_;
  bool spindle_enabled_;
  double rotation_xy_;
  ::google::protobuf::int32 spindle_direction_;
  ::google::protobuf::int32 spindle_increasing_;
  double spindle_speed_;
  bool spindle_override_enabled_;
  int state_;
  double spindlerate_;
  double max_velocity_;
  double max_acceleration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusMotion* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusIo : public ::google::protobuf::Message {
 public:
  EmcStatusIo();
  virtual ~EmcStatusIo();

  EmcStatusIo(const EmcStatusIo& from);

  inline EmcStatusIo& operator=(const EmcStatusIo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusIo& default_instance();

  void Swap(EmcStatusIo* other);

  // implements Message ----------------------------------------------

  EmcStatusIo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusIo& from);
  void MergeFrom(const EmcStatusIo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool estop = 1;
  inline bool has_estop() const;
  inline void clear_estop();
  static const int kEstopFieldNumber = 1;
  inline bool estop() const;
  inline void set_estop(bool value);

  // optional bool flood = 2;
  inline bool has_flood() const;
  inline void clear_flood();
  static const int kFloodFieldNumber = 2;
  inline bool flood() const;
  inline void set_flood(bool value);

  // optional bool lube = 3;
  inline bool has_lube() const;
  inline void clear_lube();
  static const int kLubeFieldNumber = 3;
  inline bool lube() const;
  inline void set_lube(bool value);

  // optional bool lube_level = 4;
  inline bool has_lube_level() const;
  inline void clear_lube_level();
  static const int kLubeLevelFieldNumber = 4;
  inline bool lube_level() const;
  inline void set_lube_level(bool value);

  // optional bool mist = 5;
  inline bool has_mist() const;
  inline void clear_mist();
  static const int kMistFieldNumber = 5;
  inline bool mist() const;
  inline void set_mist(bool value);

  // optional bool pocket_prepped = 6;
  inline bool has_pocket_prepped() const;
  inline void clear_pocket_prepped();
  static const int kPocketPreppedFieldNumber = 6;
  inline bool pocket_prepped() const;
  inline void set_pocket_prepped(bool value);

  // optional bool tool_in_spindle = 7;
  inline bool has_tool_in_spindle() const;
  inline void clear_tool_in_spindle();
  static const int kToolInSpindleFieldNumber = 7;
  inline bool tool_in_spindle() const;
  inline void set_tool_in_spindle(bool value);

  // optional .pb.Position tool_offset = 8;
  inline bool has_tool_offset() const;
  inline void clear_tool_offset();
  static const int kToolOffsetFieldNumber = 8;
  inline const ::pb::Position& tool_offset() const;
  inline ::pb::Position* mutable_tool_offset();
  inline ::pb::Position* release_tool_offset();
  inline void set_allocated_tool_offset(::pb::Position* tool_offset);

  // repeated .pb.EmcToolData tool_table = 9;
  inline int tool_table_size() const;
  inline void clear_tool_table();
  static const int kToolTableFieldNumber = 9;
  inline const ::pb::EmcToolData& tool_table(int index) const;
  inline ::pb::EmcToolData* mutable_tool_table(int index);
  inline ::pb::EmcToolData* add_tool_table();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcToolData >&
      tool_table() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcToolData >*
      mutable_tool_table();

  // @@protoc_insertion_point(class_scope:pb.EmcStatusIo)
 private:
  inline void set_has_estop();
  inline void clear_has_estop();
  inline void set_has_flood();
  inline void clear_has_flood();
  inline void set_has_lube();
  inline void clear_has_lube();
  inline void set_has_lube_level();
  inline void clear_has_lube_level();
  inline void set_has_mist();
  inline void clear_has_mist();
  inline void set_has_pocket_prepped();
  inline void clear_has_pocket_prepped();
  inline void set_has_tool_in_spindle();
  inline void clear_has_tool_in_spindle();
  inline void set_has_tool_offset();
  inline void clear_has_tool_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool estop_;
  bool flood_;
  bool lube_;
  bool lube_level_;
  bool mist_;
  bool pocket_prepped_;
  bool tool_in_spindle_;
  ::pb::Position* tool_offset_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcToolData > tool_table_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusIo* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusTask : public ::google::protobuf::Message {
 public:
  EmcStatusTask();
  virtual ~EmcStatusTask();

  EmcStatusTask(const EmcStatusTask& from);

  inline EmcStatusTask& operator=(const EmcStatusTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusTask& default_instance();

  void Swap(EmcStatusTask* other);

  // implements Message ----------------------------------------------

  EmcStatusTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusTask& from);
  void MergeFrom(const EmcStatusTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 echo_serial_number = 1;
  inline bool has_echo_serial_number() const;
  inline void clear_echo_serial_number();
  static const int kEchoSerialNumberFieldNumber = 1;
  inline ::google::protobuf::int32 echo_serial_number() const;
  inline void set_echo_serial_number(::google::protobuf::int32 value);

  // optional .pb.EmcTaskExecStateType exec_state = 2;
  inline bool has_exec_state() const;
  inline void clear_exec_state();
  static const int kExecStateFieldNumber = 2;
  inline ::pb::EmcTaskExecStateType exec_state() const;
  inline void set_exec_state(::pb::EmcTaskExecStateType value);

  // optional string file = 3;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 3;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional bool input_timeout = 4;
  inline bool has_input_timeout() const;
  inline void clear_input_timeout();
  static const int kInputTimeoutFieldNumber = 4;
  inline bool input_timeout() const;
  inline void set_input_timeout(bool value);

  // optional bool optional_stop = 5;
  inline bool has_optional_stop() const;
  inline void clear_optional_stop();
  static const int kOptionalStopFieldNumber = 5;
  inline bool optional_stop() const;
  inline void set_optional_stop(bool value);

  // optional int32 read_line = 6;
  inline bool has_read_line() const;
  inline void clear_read_line();
  static const int kReadLineFieldNumber = 6;
  inline ::google::protobuf::int32 read_line() const;
  inline void set_read_line(::google::protobuf::int32 value);

  // optional .pb.EmcTaskModeType task_mode = 7;
  inline bool has_task_mode() const;
  inline void clear_task_mode();
  static const int kTaskModeFieldNumber = 7;
  inline ::pb::EmcTaskModeType task_mode() const;
  inline void set_task_mode(::pb::EmcTaskModeType value);

  // optional int32 task_paused = 8;
  inline bool has_task_paused() const;
  inline void clear_task_paused();
  static const int kTaskPausedFieldNumber = 8;
  inline ::google::protobuf::int32 task_paused() const;
  inline void set_task_paused(::google::protobuf::int32 value);

  // optional .pb.EmcTaskStateType task_state = 9;
  inline bool has_task_state() const;
  inline void clear_task_state();
  static const int kTaskStateFieldNumber = 9;
  inline ::pb::EmcTaskStateType task_state() const;
  inline void set_task_state(::pb::EmcTaskStateType value);

  // optional int32 total_lines = 10;
  inline bool has_total_lines() const;
  inline void clear_total_lines();
  static const int kTotalLinesFieldNumber = 10;
  inline ::google::protobuf::int32 total_lines() const;
  inline void set_total_lines(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusTask)
 private:
  inline void set_has_echo_serial_number();
  inline void clear_has_echo_serial_number();
  inline void set_has_exec_state();
  inline void clear_has_exec_state();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_input_timeout();
  inline void clear_has_input_timeout();
  inline void set_has_optional_stop();
  inline void clear_has_optional_stop();
  inline void set_has_read_line();
  inline void clear_has_read_line();
  inline void set_has_task_mode();
  inline void clear_has_task_mode();
  inline void set_has_task_paused();
  inline void clear_has_task_paused();
  inline void set_has_task_state();
  inline void clear_has_task_state();
  inline void set_has_total_lines();
  inline void clear_has_total_lines();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 echo_serial_number_;
  int exec_state_;
  ::std::string* file_;
  bool input_timeout_;
  bool optional_stop_;
  ::google::protobuf::int32 read_line_;
  int task_mode_;
  ::google::protobuf::int32 task_paused_;
  int task_state_;
  ::google::protobuf::int32 total_lines_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusTask* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusInterp : public ::google::protobuf::Message {
 public:
  EmcStatusInterp();
  virtual ~EmcStatusInterp();

  EmcStatusInterp(const EmcStatusInterp& from);

  inline EmcStatusInterp& operator=(const EmcStatusInterp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusInterp& default_instance();

  void Swap(EmcStatusInterp* other);

  // implements Message ----------------------------------------------

  EmcStatusInterp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusInterp& from);
  void MergeFrom(const EmcStatusInterp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // repeated .pb.EmcStatusGCode gcodes = 2;
  inline int gcodes_size() const;
  inline void clear_gcodes();
  static const int kGcodesFieldNumber = 2;
  inline const ::pb::EmcStatusGCode& gcodes(int index) const;
  inline ::pb::EmcStatusGCode* mutable_gcodes(int index);
  inline ::pb::EmcStatusGCode* add_gcodes();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusGCode >&
      gcodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusGCode >*
      mutable_gcodes();

  // optional .pb.EmcInterpStateType interp_state = 3;
  inline bool has_interp_state() const;
  inline void clear_interp_state();
  static const int kInterpStateFieldNumber = 3;
  inline ::pb::EmcInterpStateType interp_state() const;
  inline void set_interp_state(::pb::EmcInterpStateType value);

  // optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
  inline bool has_interpreter_errcode() const;
  inline void clear_interpreter_errcode();
  static const int kInterpreterErrcodeFieldNumber = 4;
  inline ::pb::EmcInterpExitCodeType interpreter_errcode() const;
  inline void set_interpreter_errcode(::pb::EmcInterpExitCodeType value);

  // repeated .pb.EmcStatusMCode mcodes = 5;
  inline int mcodes_size() const;
  inline void clear_mcodes();
  static const int kMcodesFieldNumber = 5;
  inline const ::pb::EmcStatusMCode& mcodes(int index) const;
  inline ::pb::EmcStatusMCode* mutable_mcodes(int index);
  inline ::pb::EmcStatusMCode* add_mcodes();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMCode >&
      mcodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMCode >*
      mutable_mcodes();

  // repeated .pb.EmcStatusSetting settings = 6;
  inline int settings_size() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 6;
  inline const ::pb::EmcStatusSetting& settings(int index) const;
  inline ::pb::EmcStatusSetting* mutable_settings(int index);
  inline ::pb::EmcStatusSetting* add_settings();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusSetting >&
      settings() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusSetting >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:pb.EmcStatusInterp)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_interp_state();
  inline void clear_has_interp_state();
  inline void set_has_interpreter_errcode();
  inline void clear_has_interpreter_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusGCode > gcodes_;
  int interp_state_;
  int interpreter_errcode_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMCode > mcodes_;
  ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusSetting > settings_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusInterp* default_instance_;
};
// -------------------------------------------------------------------

class EmcCommandParameters : public ::google::protobuf::Message {
 public:
  EmcCommandParameters();
  virtual ~EmcCommandParameters();

  EmcCommandParameters(const EmcCommandParameters& from);

  inline EmcCommandParameters& operator=(const EmcCommandParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcCommandParameters& default_instance();

  void Swap(EmcCommandParameters* other);

  // implements Message ----------------------------------------------

  EmcCommandParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcCommandParameters& from);
  void MergeFrom(const EmcCommandParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 debug_level = 2;
  inline bool has_debug_level() const;
  inline void clear_debug_level();
  static const int kDebugLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 debug_level() const;
  inline void set_debug_level(::google::protobuf::uint32 value);

  // optional int32 line_number = 3;
  inline bool has_line_number() const;
  inline void clear_line_number();
  static const int kLineNumberFieldNumber = 3;
  inline ::google::protobuf::int32 line_number() const;
  inline void set_line_number(::google::protobuf::int32 value);

  // optional double scale = 4;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline double scale() const;
  inline void set_scale(double value);

  // optional double velocity = 5;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 5;
  inline double velocity() const;
  inline void set_velocity(double value);

  // optional double distance = 6;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 6;
  inline double distance() const;
  inline void set_distance(double value);

  // optional double value = 7;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 7;
  inline double value() const;
  inline void set_value(double value);

  // optional bool enable = 8;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 8;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional string command = 9;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 9;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // optional string path = 10;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 10;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional .pb.EmcTaskModeType task_mode = 100;
  inline bool has_task_mode() const;
  inline void clear_task_mode();
  static const int kTaskModeFieldNumber = 100;
  inline ::pb::EmcTaskModeType task_mode() const;
  inline void set_task_mode(::pb::EmcTaskModeType value);

  // optional .pb.EmcTaskStateType task_state = 101;
  inline bool has_task_state() const;
  inline void clear_task_state();
  static const int kTaskStateFieldNumber = 101;
  inline ::pb::EmcTaskStateType task_state() const;
  inline void set_task_state(::pb::EmcTaskStateType value);

  // optional .pb.EmcTrajectoryModeType traj_mode = 102;
  inline bool has_traj_mode() const;
  inline void clear_traj_mode();
  static const int kTrajModeFieldNumber = 102;
  inline ::pb::EmcTrajectoryModeType traj_mode() const;
  inline void set_traj_mode(::pb::EmcTrajectoryModeType value);

  // optional .pb.EmcPose pose = 103;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 103;
  inline const ::pb::EmcPose& pose() const;
  inline ::pb::EmcPose* mutable_pose();
  inline ::pb::EmcPose* release_pose();
  inline void set_allocated_pose(::pb::EmcPose* pose);

  // optional .pb.EmcToolData tool_data = 104;
  inline bool has_tool_data() const;
  inline void clear_tool_data();
  static const int kToolDataFieldNumber = 104;
  inline const ::pb::EmcToolData& tool_data() const;
  inline ::pb::EmcToolData* mutable_tool_data();
  inline ::pb::EmcToolData* release_tool_data();
  inline void set_allocated_tool_data(::pb::EmcToolData* tool_data);

  // @@protoc_insertion_point(class_scope:pb.EmcCommandParameters)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_debug_level();
  inline void clear_has_debug_level();
  inline void set_has_line_number();
  inline void clear_has_line_number();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_task_mode();
  inline void clear_has_task_mode();
  inline void set_has_task_state();
  inline void clear_has_task_state();
  inline void set_has_traj_mode();
  inline void clear_has_traj_mode();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_tool_data();
  inline void clear_has_tool_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 debug_level_;
  double scale_;
  double velocity_;
  ::google::protobuf::int32 line_number_;
  bool enable_;
  double distance_;
  double value_;
  ::std::string* command_;
  ::std::string* path_;
  int task_mode_;
  int task_state_;
  ::pb::EmcPose* pose_;
  ::pb::EmcToolData* tool_data_;
  int traj_mode_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcCommandParameters* default_instance_;
};
// -------------------------------------------------------------------

class EmcStatusUserCommand : public ::google::protobuf::Message {
 public:
  EmcStatusUserCommand();
  virtual ~EmcStatusUserCommand();

  EmcStatusUserCommand(const EmcStatusUserCommand& from);

  inline EmcStatusUserCommand& operator=(const EmcStatusUserCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmcStatusUserCommand& default_instance();

  void Swap(EmcStatusUserCommand* other);

  // implements Message ----------------------------------------------

  EmcStatusUserCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmcStatusUserCommand& from);
  void MergeFrom(const EmcStatusUserCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // @@protoc_insertion_point(class_scope:pb.EmcStatusUserCommand)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static EmcStatusUserCommand* default_instance_;
};
// ===================================================================


// ===================================================================

// EmcToolData

// required int32 index = 1;
inline bool EmcToolData::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcToolData::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcToolData::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcToolData::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcToolData::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.index)
  return index_;
}
inline void EmcToolData::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.index)
}

// optional int32 id = 2;
inline bool EmcToolData::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcToolData::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcToolData::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcToolData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EmcToolData::id() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.id)
  return id_;
}
inline void EmcToolData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.id)
}

// optional double xOffset = 3;
inline bool EmcToolData::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcToolData::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcToolData::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcToolData::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline double EmcToolData::xoffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.xOffset)
  return xoffset_;
}
inline void EmcToolData::set_xoffset(double value) {
  set_has_xoffset();
  xoffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.xOffset)
}

// optional double yOffset = 4;
inline bool EmcToolData::has_yoffset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcToolData::set_has_yoffset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcToolData::clear_has_yoffset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcToolData::clear_yoffset() {
  yoffset_ = 0;
  clear_has_yoffset();
}
inline double EmcToolData::yoffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.yOffset)
  return yoffset_;
}
inline void EmcToolData::set_yoffset(double value) {
  set_has_yoffset();
  yoffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.yOffset)
}

// optional double zOffset = 5;
inline bool EmcToolData::has_zoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcToolData::set_has_zoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcToolData::clear_has_zoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcToolData::clear_zoffset() {
  zoffset_ = 0;
  clear_has_zoffset();
}
inline double EmcToolData::zoffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.zOffset)
  return zoffset_;
}
inline void EmcToolData::set_zoffset(double value) {
  set_has_zoffset();
  zoffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.zOffset)
}

// optional double aOffset = 6;
inline bool EmcToolData::has_aoffset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcToolData::set_has_aoffset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcToolData::clear_has_aoffset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcToolData::clear_aoffset() {
  aoffset_ = 0;
  clear_has_aoffset();
}
inline double EmcToolData::aoffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.aOffset)
  return aoffset_;
}
inline void EmcToolData::set_aoffset(double value) {
  set_has_aoffset();
  aoffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.aOffset)
}

// optional double bOffset = 7;
inline bool EmcToolData::has_boffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcToolData::set_has_boffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcToolData::clear_has_boffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcToolData::clear_boffset() {
  boffset_ = 0;
  clear_has_boffset();
}
inline double EmcToolData::boffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.bOffset)
  return boffset_;
}
inline void EmcToolData::set_boffset(double value) {
  set_has_boffset();
  boffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.bOffset)
}

// optional double cOffset = 8;
inline bool EmcToolData::has_coffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcToolData::set_has_coffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcToolData::clear_has_coffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcToolData::clear_coffset() {
  coffset_ = 0;
  clear_has_coffset();
}
inline double EmcToolData::coffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.cOffset)
  return coffset_;
}
inline void EmcToolData::set_coffset(double value) {
  set_has_coffset();
  coffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.cOffset)
}

// optional double uOffset = 9;
inline bool EmcToolData::has_uoffset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcToolData::set_has_uoffset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcToolData::clear_has_uoffset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcToolData::clear_uoffset() {
  uoffset_ = 0;
  clear_has_uoffset();
}
inline double EmcToolData::uoffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.uOffset)
  return uoffset_;
}
inline void EmcToolData::set_uoffset(double value) {
  set_has_uoffset();
  uoffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.uOffset)
}

// optional double vOffset = 10;
inline bool EmcToolData::has_voffset() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcToolData::set_has_voffset() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcToolData::clear_has_voffset() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcToolData::clear_voffset() {
  voffset_ = 0;
  clear_has_voffset();
}
inline double EmcToolData::voffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.vOffset)
  return voffset_;
}
inline void EmcToolData::set_voffset(double value) {
  set_has_voffset();
  voffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.vOffset)
}

// optional double wOffset = 11;
inline bool EmcToolData::has_woffset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmcToolData::set_has_woffset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmcToolData::clear_has_woffset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmcToolData::clear_woffset() {
  woffset_ = 0;
  clear_has_woffset();
}
inline double EmcToolData::woffset() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.wOffset)
  return woffset_;
}
inline void EmcToolData::set_woffset(double value) {
  set_has_woffset();
  woffset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.wOffset)
}

// optional double diameter = 12;
inline bool EmcToolData::has_diameter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcToolData::set_has_diameter() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcToolData::clear_has_diameter() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcToolData::clear_diameter() {
  diameter_ = 0;
  clear_has_diameter();
}
inline double EmcToolData::diameter() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.diameter)
  return diameter_;
}
inline void EmcToolData::set_diameter(double value) {
  set_has_diameter();
  diameter_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.diameter)
}

// optional double frontangle = 13;
inline bool EmcToolData::has_frontangle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmcToolData::set_has_frontangle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmcToolData::clear_has_frontangle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmcToolData::clear_frontangle() {
  frontangle_ = 0;
  clear_has_frontangle();
}
inline double EmcToolData::frontangle() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.frontangle)
  return frontangle_;
}
inline void EmcToolData::set_frontangle(double value) {
  set_has_frontangle();
  frontangle_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.frontangle)
}

// optional double backangle = 14;
inline bool EmcToolData::has_backangle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmcToolData::set_has_backangle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmcToolData::clear_has_backangle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmcToolData::clear_backangle() {
  backangle_ = 0;
  clear_has_backangle();
}
inline double EmcToolData::backangle() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.backangle)
  return backangle_;
}
inline void EmcToolData::set_backangle(double value) {
  set_has_backangle();
  backangle_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.backangle)
}

// optional int32 orientation = 15;
inline bool EmcToolData::has_orientation() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmcToolData::set_has_orientation() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmcToolData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmcToolData::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline ::google::protobuf::int32 EmcToolData::orientation() const {
  // @@protoc_insertion_point(field_get:pb.EmcToolData.orientation)
  return orientation_;
}
inline void EmcToolData::set_orientation(::google::protobuf::int32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcToolData.orientation)
}

// -------------------------------------------------------------------

// EmcStatusMotionAxis

// required int32 index = 1;
inline bool EmcStatusMotionAxis::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusMotionAxis::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusMotionAxis::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusMotionAxis::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusMotionAxis::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.index)
  return index_;
}
inline void EmcStatusMotionAxis::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.index)
}

// optional bool enabled = 2;
inline bool EmcStatusMotionAxis::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusMotionAxis::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusMotionAxis::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusMotionAxis::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool EmcStatusMotionAxis::enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.enabled)
  return enabled_;
}
inline void EmcStatusMotionAxis::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.enabled)
}

// optional bool fault = 3;
inline bool EmcStatusMotionAxis::has_fault() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusMotionAxis::set_has_fault() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusMotionAxis::clear_has_fault() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusMotionAxis::clear_fault() {
  fault_ = false;
  clear_has_fault();
}
inline bool EmcStatusMotionAxis::fault() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.fault)
  return fault_;
}
inline void EmcStatusMotionAxis::set_fault(bool value) {
  set_has_fault();
  fault_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.fault)
}

// optional double ferror_current = 4;
inline bool EmcStatusMotionAxis::has_ferror_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcStatusMotionAxis::set_has_ferror_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcStatusMotionAxis::clear_has_ferror_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcStatusMotionAxis::clear_ferror_current() {
  ferror_current_ = 0;
  clear_has_ferror_current();
}
inline double EmcStatusMotionAxis::ferror_current() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.ferror_current)
  return ferror_current_;
}
inline void EmcStatusMotionAxis::set_ferror_current(double value) {
  set_has_ferror_current();
  ferror_current_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.ferror_current)
}

// optional double ferror_highmark = 5;
inline bool EmcStatusMotionAxis::has_ferror_highmark() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcStatusMotionAxis::set_has_ferror_highmark() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcStatusMotionAxis::clear_has_ferror_highmark() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcStatusMotionAxis::clear_ferror_highmark() {
  ferror_highmark_ = 0;
  clear_has_ferror_highmark();
}
inline double EmcStatusMotionAxis::ferror_highmark() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.ferror_highmark)
  return ferror_highmark_;
}
inline void EmcStatusMotionAxis::set_ferror_highmark(double value) {
  set_has_ferror_highmark();
  ferror_highmark_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.ferror_highmark)
}

// optional bool homed = 6;
inline bool EmcStatusMotionAxis::has_homed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcStatusMotionAxis::set_has_homed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcStatusMotionAxis::clear_has_homed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcStatusMotionAxis::clear_homed() {
  homed_ = false;
  clear_has_homed();
}
inline bool EmcStatusMotionAxis::homed() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.homed)
  return homed_;
}
inline void EmcStatusMotionAxis::set_homed(bool value) {
  set_has_homed();
  homed_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.homed)
}

// optional bool homing = 7;
inline bool EmcStatusMotionAxis::has_homing() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusMotionAxis::set_has_homing() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusMotionAxis::clear_has_homing() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusMotionAxis::clear_homing() {
  homing_ = false;
  clear_has_homing();
}
inline bool EmcStatusMotionAxis::homing() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.homing)
  return homing_;
}
inline void EmcStatusMotionAxis::set_homing(bool value) {
  set_has_homing();
  homing_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.homing)
}

// optional bool inpos = 8;
inline bool EmcStatusMotionAxis::has_inpos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusMotionAxis::set_has_inpos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusMotionAxis::clear_has_inpos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusMotionAxis::clear_inpos() {
  inpos_ = false;
  clear_has_inpos();
}
inline bool EmcStatusMotionAxis::inpos() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.inpos)
  return inpos_;
}
inline void EmcStatusMotionAxis::set_inpos(bool value) {
  set_has_inpos();
  inpos_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.inpos)
}

// optional double input = 9;
inline bool EmcStatusMotionAxis::has_input() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcStatusMotionAxis::set_has_input() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcStatusMotionAxis::clear_has_input() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcStatusMotionAxis::clear_input() {
  input_ = 0;
  clear_has_input();
}
inline double EmcStatusMotionAxis::input() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.input)
  return input_;
}
inline void EmcStatusMotionAxis::set_input(double value) {
  set_has_input();
  input_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.input)
}

// optional bool max_hard_limit = 10;
inline bool EmcStatusMotionAxis::has_max_hard_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcStatusMotionAxis::set_has_max_hard_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcStatusMotionAxis::clear_has_max_hard_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcStatusMotionAxis::clear_max_hard_limit() {
  max_hard_limit_ = false;
  clear_has_max_hard_limit();
}
inline bool EmcStatusMotionAxis::max_hard_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.max_hard_limit)
  return max_hard_limit_;
}
inline void EmcStatusMotionAxis::set_max_hard_limit(bool value) {
  set_has_max_hard_limit();
  max_hard_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.max_hard_limit)
}

// optional bool max_soft_limit = 11;
inline bool EmcStatusMotionAxis::has_max_soft_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmcStatusMotionAxis::set_has_max_soft_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmcStatusMotionAxis::clear_has_max_soft_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmcStatusMotionAxis::clear_max_soft_limit() {
  max_soft_limit_ = false;
  clear_has_max_soft_limit();
}
inline bool EmcStatusMotionAxis::max_soft_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.max_soft_limit)
  return max_soft_limit_;
}
inline void EmcStatusMotionAxis::set_max_soft_limit(bool value) {
  set_has_max_soft_limit();
  max_soft_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.max_soft_limit)
}

// optional bool min_hard_limit = 12;
inline bool EmcStatusMotionAxis::has_min_hard_limit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcStatusMotionAxis::set_has_min_hard_limit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcStatusMotionAxis::clear_has_min_hard_limit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcStatusMotionAxis::clear_min_hard_limit() {
  min_hard_limit_ = false;
  clear_has_min_hard_limit();
}
inline bool EmcStatusMotionAxis::min_hard_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.min_hard_limit)
  return min_hard_limit_;
}
inline void EmcStatusMotionAxis::set_min_hard_limit(bool value) {
  set_has_min_hard_limit();
  min_hard_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.min_hard_limit)
}

// optional bool min_soft_limit = 13;
inline bool EmcStatusMotionAxis::has_min_soft_limit() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmcStatusMotionAxis::set_has_min_soft_limit() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmcStatusMotionAxis::clear_has_min_soft_limit() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmcStatusMotionAxis::clear_min_soft_limit() {
  min_soft_limit_ = false;
  clear_has_min_soft_limit();
}
inline bool EmcStatusMotionAxis::min_soft_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.min_soft_limit)
  return min_soft_limit_;
}
inline void EmcStatusMotionAxis::set_min_soft_limit(bool value) {
  set_has_min_soft_limit();
  min_soft_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.min_soft_limit)
}

// optional double output = 14;
inline bool EmcStatusMotionAxis::has_output() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmcStatusMotionAxis::set_has_output() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmcStatusMotionAxis::clear_has_output() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmcStatusMotionAxis::clear_output() {
  output_ = 0;
  clear_has_output();
}
inline double EmcStatusMotionAxis::output() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.output)
  return output_;
}
inline void EmcStatusMotionAxis::set_output(double value) {
  set_has_output();
  output_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.output)
}

// optional bool override_limits = 15;
inline bool EmcStatusMotionAxis::has_override_limits() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmcStatusMotionAxis::set_has_override_limits() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmcStatusMotionAxis::clear_has_override_limits() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmcStatusMotionAxis::clear_override_limits() {
  override_limits_ = false;
  clear_has_override_limits();
}
inline bool EmcStatusMotionAxis::override_limits() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.override_limits)
  return override_limits_;
}
inline void EmcStatusMotionAxis::set_override_limits(bool value) {
  set_has_override_limits();
  override_limits_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.override_limits)
}

// optional double velocity = 16;
inline bool EmcStatusMotionAxis::has_velocity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmcStatusMotionAxis::set_has_velocity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmcStatusMotionAxis::clear_has_velocity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmcStatusMotionAxis::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double EmcStatusMotionAxis::velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotionAxis.velocity)
  return velocity_;
}
inline void EmcStatusMotionAxis::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotionAxis.velocity)
}

// -------------------------------------------------------------------

// EmcStatusConfigAxis

// required int32 index = 1;
inline bool EmcStatusConfigAxis::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusConfigAxis::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusConfigAxis::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusConfigAxis::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusConfigAxis::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.index)
  return index_;
}
inline void EmcStatusConfigAxis::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.index)
}

// optional .pb.EmcAxisType axisType = 2;
inline bool EmcStatusConfigAxis::has_axistype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusConfigAxis::set_has_axistype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusConfigAxis::clear_has_axistype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusConfigAxis::clear_axistype() {
  axistype_ = 1;
  clear_has_axistype();
}
inline ::pb::EmcAxisType EmcStatusConfigAxis::axistype() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.axisType)
  return static_cast< ::pb::EmcAxisType >(axistype_);
}
inline void EmcStatusConfigAxis::set_axistype(::pb::EmcAxisType value) {
  assert(::pb::EmcAxisType_IsValid(value));
  set_has_axistype();
  axistype_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.axisType)
}

// optional double backlash = 3;
inline bool EmcStatusConfigAxis::has_backlash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusConfigAxis::set_has_backlash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusConfigAxis::clear_has_backlash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusConfigAxis::clear_backlash() {
  backlash_ = 0;
  clear_has_backlash();
}
inline double EmcStatusConfigAxis::backlash() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.backlash)
  return backlash_;
}
inline void EmcStatusConfigAxis::set_backlash(double value) {
  set_has_backlash();
  backlash_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.backlash)
}

// optional double max_ferror = 4;
inline bool EmcStatusConfigAxis::has_max_ferror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcStatusConfigAxis::set_has_max_ferror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcStatusConfigAxis::clear_has_max_ferror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcStatusConfigAxis::clear_max_ferror() {
  max_ferror_ = 0;
  clear_has_max_ferror();
}
inline double EmcStatusConfigAxis::max_ferror() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.max_ferror)
  return max_ferror_;
}
inline void EmcStatusConfigAxis::set_max_ferror(double value) {
  set_has_max_ferror();
  max_ferror_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.max_ferror)
}

// optional double max_position_limit = 5;
inline bool EmcStatusConfigAxis::has_max_position_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcStatusConfigAxis::set_has_max_position_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcStatusConfigAxis::clear_has_max_position_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcStatusConfigAxis::clear_max_position_limit() {
  max_position_limit_ = 0;
  clear_has_max_position_limit();
}
inline double EmcStatusConfigAxis::max_position_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.max_position_limit)
  return max_position_limit_;
}
inline void EmcStatusConfigAxis::set_max_position_limit(double value) {
  set_has_max_position_limit();
  max_position_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.max_position_limit)
}

// optional double min_ferror = 6;
inline bool EmcStatusConfigAxis::has_min_ferror() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcStatusConfigAxis::set_has_min_ferror() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcStatusConfigAxis::clear_has_min_ferror() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcStatusConfigAxis::clear_min_ferror() {
  min_ferror_ = 0;
  clear_has_min_ferror();
}
inline double EmcStatusConfigAxis::min_ferror() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.min_ferror)
  return min_ferror_;
}
inline void EmcStatusConfigAxis::set_min_ferror(double value) {
  set_has_min_ferror();
  min_ferror_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.min_ferror)
}

// optional double min_position_limit = 7;
inline bool EmcStatusConfigAxis::has_min_position_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusConfigAxis::set_has_min_position_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusConfigAxis::clear_has_min_position_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusConfigAxis::clear_min_position_limit() {
  min_position_limit_ = 0;
  clear_has_min_position_limit();
}
inline double EmcStatusConfigAxis::min_position_limit() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.min_position_limit)
  return min_position_limit_;
}
inline void EmcStatusConfigAxis::set_min_position_limit(double value) {
  set_has_min_position_limit();
  min_position_limit_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.min_position_limit)
}

// optional double units = 8;
inline bool EmcStatusConfigAxis::has_units() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusConfigAxis::set_has_units() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusConfigAxis::clear_has_units() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusConfigAxis::clear_units() {
  units_ = 0;
  clear_has_units();
}
inline double EmcStatusConfigAxis::units() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.units)
  return units_;
}
inline void EmcStatusConfigAxis::set_units(double value) {
  set_has_units();
  units_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.units)
}

// optional int32 home_sequence = 9;
inline bool EmcStatusConfigAxis::has_home_sequence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcStatusConfigAxis::set_has_home_sequence() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcStatusConfigAxis::clear_has_home_sequence() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcStatusConfigAxis::clear_home_sequence() {
  home_sequence_ = 0;
  clear_has_home_sequence();
}
inline ::google::protobuf::int32 EmcStatusConfigAxis::home_sequence() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.home_sequence)
  return home_sequence_;
}
inline void EmcStatusConfigAxis::set_home_sequence(::google::protobuf::int32 value) {
  set_has_home_sequence();
  home_sequence_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.home_sequence)
}

// optional double max_acceleration = 10;
inline bool EmcStatusConfigAxis::has_max_acceleration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcStatusConfigAxis::set_has_max_acceleration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcStatusConfigAxis::clear_has_max_acceleration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcStatusConfigAxis::clear_max_acceleration() {
  max_acceleration_ = 0;
  clear_has_max_acceleration();
}
inline double EmcStatusConfigAxis::max_acceleration() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.max_acceleration)
  return max_acceleration_;
}
inline void EmcStatusConfigAxis::set_max_acceleration(double value) {
  set_has_max_acceleration();
  max_acceleration_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.max_acceleration)
}

// optional double max_velocity = 11;
inline bool EmcStatusConfigAxis::has_max_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmcStatusConfigAxis::set_has_max_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmcStatusConfigAxis::clear_has_max_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmcStatusConfigAxis::clear_max_velocity() {
  max_velocity_ = 0;
  clear_has_max_velocity();
}
inline double EmcStatusConfigAxis::max_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.max_velocity)
  return max_velocity_;
}
inline void EmcStatusConfigAxis::set_max_velocity(double value) {
  set_has_max_velocity();
  max_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.max_velocity)
}

// optional string increments = 12;
inline bool EmcStatusConfigAxis::has_increments() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcStatusConfigAxis::set_has_increments() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcStatusConfigAxis::clear_has_increments() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcStatusConfigAxis::clear_increments() {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_->clear();
  }
  clear_has_increments();
}
inline const ::std::string& EmcStatusConfigAxis::increments() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfigAxis.increments)
  return *increments_;
}
inline void EmcStatusConfigAxis::set_increments(const ::std::string& value) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfigAxis.increments)
}
inline void EmcStatusConfigAxis::set_increments(const char* value) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfigAxis.increments)
}
inline void EmcStatusConfigAxis::set_increments(const char* value, size_t size) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfigAxis.increments)
}
inline ::std::string* EmcStatusConfigAxis::mutable_increments() {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfigAxis.increments)
  return increments_;
}
inline ::std::string* EmcStatusConfigAxis::release_increments() {
  clear_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = increments_;
    increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfigAxis::set_allocated_increments(::std::string* increments) {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete increments_;
  }
  if (increments) {
    set_has_increments();
    increments_ = increments;
  } else {
    clear_has_increments();
    increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfigAxis.increments)
}

// -------------------------------------------------------------------

// EmcProgramExtension

// required int32 index = 1;
inline bool EmcProgramExtension::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcProgramExtension::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcProgramExtension::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcProgramExtension::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcProgramExtension::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcProgramExtension.index)
  return index_;
}
inline void EmcProgramExtension::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcProgramExtension.index)
}

// optional string extension = 2;
inline bool EmcProgramExtension::has_extension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcProgramExtension::set_has_extension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcProgramExtension::clear_has_extension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcProgramExtension::clear_extension() {
  if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_->clear();
  }
  clear_has_extension();
}
inline const ::std::string& EmcProgramExtension::extension() const {
  // @@protoc_insertion_point(field_get:pb.EmcProgramExtension.extension)
  return *extension_;
}
inline void EmcProgramExtension::set_extension(const ::std::string& value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcProgramExtension.extension)
}
inline void EmcProgramExtension::set_extension(const char* value) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcProgramExtension.extension)
}
inline void EmcProgramExtension::set_extension(const char* value, size_t size) {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  extension_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcProgramExtension.extension)
}
inline ::std::string* EmcProgramExtension::mutable_extension() {
  set_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extension_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcProgramExtension.extension)
  return extension_;
}
inline ::std::string* EmcProgramExtension::release_extension() {
  clear_has_extension();
  if (extension_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extension_;
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcProgramExtension::set_allocated_extension(::std::string* extension) {
  if (extension_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extension_;
  }
  if (extension) {
    set_has_extension();
    extension_ = extension;
  } else {
    clear_has_extension();
    extension_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcProgramExtension.extension)
}

// -------------------------------------------------------------------

// EmcStatusAnalogIO

// required int32 index = 1;
inline bool EmcStatusAnalogIO::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusAnalogIO::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusAnalogIO::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusAnalogIO::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusAnalogIO::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusAnalogIO.index)
  return index_;
}
inline void EmcStatusAnalogIO::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusAnalogIO.index)
}

// optional double value = 2;
inline bool EmcStatusAnalogIO::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusAnalogIO::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusAnalogIO::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusAnalogIO::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double EmcStatusAnalogIO::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusAnalogIO.value)
  return value_;
}
inline void EmcStatusAnalogIO::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusAnalogIO.value)
}

// -------------------------------------------------------------------

// EmcStatusDigitalIO

// required int32 index = 1;
inline bool EmcStatusDigitalIO::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusDigitalIO::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusDigitalIO::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusDigitalIO::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusDigitalIO::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusDigitalIO.index)
  return index_;
}
inline void EmcStatusDigitalIO::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusDigitalIO.index)
}

// optional bool value = 2;
inline bool EmcStatusDigitalIO::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusDigitalIO::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusDigitalIO::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusDigitalIO::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool EmcStatusDigitalIO::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusDigitalIO.value)
  return value_;
}
inline void EmcStatusDigitalIO::set_value(bool value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusDigitalIO.value)
}

// -------------------------------------------------------------------

// EmcStatusLimit

// required int32 index = 1;
inline bool EmcStatusLimit::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusLimit::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusLimit::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusLimit::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusLimit::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusLimit.index)
  return index_;
}
inline void EmcStatusLimit::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusLimit.index)
}

// optional int32 value = 2;
inline bool EmcStatusLimit::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusLimit::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusLimit::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusLimit::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EmcStatusLimit::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusLimit.value)
  return value_;
}
inline void EmcStatusLimit::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusLimit.value)
}

// -------------------------------------------------------------------

// EmcStatusGCode

// required int32 index = 1;
inline bool EmcStatusGCode::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusGCode::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusGCode::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusGCode::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusGCode::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusGCode.index)
  return index_;
}
inline void EmcStatusGCode::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusGCode.index)
}

// optional int32 value = 2;
inline bool EmcStatusGCode::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusGCode::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusGCode::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusGCode::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EmcStatusGCode::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusGCode.value)
  return value_;
}
inline void EmcStatusGCode::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusGCode.value)
}

// -------------------------------------------------------------------

// EmcStatusMCode

// required int32 index = 1;
inline bool EmcStatusMCode::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusMCode::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusMCode::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusMCode::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusMCode::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMCode.index)
  return index_;
}
inline void EmcStatusMCode::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMCode.index)
}

// optional int32 value = 2;
inline bool EmcStatusMCode::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusMCode::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusMCode::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusMCode::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EmcStatusMCode::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMCode.value)
  return value_;
}
inline void EmcStatusMCode::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMCode.value)
}

// -------------------------------------------------------------------

// EmcStatusSetting

// required int32 index = 1;
inline bool EmcStatusSetting::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusSetting::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusSetting::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusSetting::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusSetting::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusSetting.index)
  return index_;
}
inline void EmcStatusSetting::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusSetting.index)
}

// optional double value = 2;
inline bool EmcStatusSetting::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusSetting::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusSetting::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusSetting::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double EmcStatusSetting::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusSetting.value)
  return value_;
}
inline void EmcStatusSetting::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusSetting.value)
}

// -------------------------------------------------------------------

// EmcStatusConfig

// optional double default_acceleration = 1;
inline bool EmcStatusConfig::has_default_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusConfig::set_has_default_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusConfig::clear_has_default_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusConfig::clear_default_acceleration() {
  default_acceleration_ = 0;
  clear_has_default_acceleration();
}
inline double EmcStatusConfig::default_acceleration() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.default_acceleration)
  return default_acceleration_;
}
inline void EmcStatusConfig::set_default_acceleration(double value) {
  set_has_default_acceleration();
  default_acceleration_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.default_acceleration)
}

// optional double angular_units = 2;
inline bool EmcStatusConfig::has_angular_units() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusConfig::set_has_angular_units() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusConfig::clear_has_angular_units() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusConfig::clear_angular_units() {
  angular_units_ = 0;
  clear_has_angular_units();
}
inline double EmcStatusConfig::angular_units() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.angular_units)
  return angular_units_;
}
inline void EmcStatusConfig::set_angular_units(double value) {
  set_has_angular_units();
  angular_units_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.angular_units)
}

// optional int32 axes = 3;
inline bool EmcStatusConfig::has_axes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusConfig::set_has_axes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusConfig::clear_has_axes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusConfig::clear_axes() {
  axes_ = 0;
  clear_has_axes();
}
inline ::google::protobuf::int32 EmcStatusConfig::axes() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.axes)
  return axes_;
}
inline void EmcStatusConfig::set_axes(::google::protobuf::int32 value) {
  set_has_axes();
  axes_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.axes)
}

// repeated .pb.EmcStatusConfigAxis axis = 4;
inline int EmcStatusConfig::axis_size() const {
  return axis_.size();
}
inline void EmcStatusConfig::clear_axis() {
  axis_.Clear();
}
inline const ::pb::EmcStatusConfigAxis& EmcStatusConfig::axis(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.axis)
  return axis_.Get(index);
}
inline ::pb::EmcStatusConfigAxis* EmcStatusConfig::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.axis)
  return axis_.Mutable(index);
}
inline ::pb::EmcStatusConfigAxis* EmcStatusConfig::add_axis() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusConfig.axis)
  return axis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusConfigAxis >&
EmcStatusConfig::axis() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusConfig.axis)
  return axis_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusConfigAxis >*
EmcStatusConfig::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusConfig.axis)
  return &axis_;
}

// optional int32 axis_mask = 5;
inline bool EmcStatusConfig::has_axis_mask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcStatusConfig::set_has_axis_mask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcStatusConfig::clear_has_axis_mask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcStatusConfig::clear_axis_mask() {
  axis_mask_ = 0;
  clear_has_axis_mask();
}
inline ::google::protobuf::int32 EmcStatusConfig::axis_mask() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.axis_mask)
  return axis_mask_;
}
inline void EmcStatusConfig::set_axis_mask(::google::protobuf::int32 value) {
  set_has_axis_mask();
  axis_mask_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.axis_mask)
}

// optional double cycle_time = 6;
inline bool EmcStatusConfig::has_cycle_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcStatusConfig::set_has_cycle_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcStatusConfig::clear_has_cycle_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcStatusConfig::clear_cycle_time() {
  cycle_time_ = 0;
  clear_has_cycle_time();
}
inline double EmcStatusConfig::cycle_time() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.cycle_time)
  return cycle_time_;
}
inline void EmcStatusConfig::set_cycle_time(double value) {
  set_has_cycle_time();
  cycle_time_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.cycle_time)
}

// optional int32 debug = 7;
inline bool EmcStatusConfig::has_debug() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusConfig::set_has_debug() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusConfig::clear_has_debug() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusConfig::clear_debug() {
  debug_ = 0;
  clear_has_debug();
}
inline ::google::protobuf::int32 EmcStatusConfig::debug() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.debug)
  return debug_;
}
inline void EmcStatusConfig::set_debug(::google::protobuf::int32 value) {
  set_has_debug();
  debug_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.debug)
}

// optional .pb.EmcKinematicsType kinematics_type = 8;
inline bool EmcStatusConfig::has_kinematics_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusConfig::set_has_kinematics_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusConfig::clear_has_kinematics_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusConfig::clear_kinematics_type() {
  kinematics_type_ = 1;
  clear_has_kinematics_type();
}
inline ::pb::EmcKinematicsType EmcStatusConfig::kinematics_type() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.kinematics_type)
  return static_cast< ::pb::EmcKinematicsType >(kinematics_type_);
}
inline void EmcStatusConfig::set_kinematics_type(::pb::EmcKinematicsType value) {
  assert(::pb::EmcKinematicsType_IsValid(value));
  set_has_kinematics_type();
  kinematics_type_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.kinematics_type)
}

// optional double linear_units = 9;
inline bool EmcStatusConfig::has_linear_units() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcStatusConfig::set_has_linear_units() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcStatusConfig::clear_has_linear_units() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcStatusConfig::clear_linear_units() {
  linear_units_ = 0;
  clear_has_linear_units();
}
inline double EmcStatusConfig::linear_units() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.linear_units)
  return linear_units_;
}
inline void EmcStatusConfig::set_linear_units(double value) {
  set_has_linear_units();
  linear_units_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.linear_units)
}

// optional double max_acceleration = 10;
inline bool EmcStatusConfig::has_max_acceleration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcStatusConfig::set_has_max_acceleration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcStatusConfig::clear_has_max_acceleration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcStatusConfig::clear_max_acceleration() {
  max_acceleration_ = 0;
  clear_has_max_acceleration();
}
inline double EmcStatusConfig::max_acceleration() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_acceleration)
  return max_acceleration_;
}
inline void EmcStatusConfig::set_max_acceleration(double value) {
  set_has_max_acceleration();
  max_acceleration_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_acceleration)
}

// optional double max_velocity = 11;
inline bool EmcStatusConfig::has_max_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmcStatusConfig::set_has_max_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmcStatusConfig::clear_has_max_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmcStatusConfig::clear_max_velocity() {
  max_velocity_ = 0;
  clear_has_max_velocity();
}
inline double EmcStatusConfig::max_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_velocity)
  return max_velocity_;
}
inline void EmcStatusConfig::set_max_velocity(double value) {
  set_has_max_velocity();
  max_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_velocity)
}

// optional .pb.EmcCanonUnitsType program_units = 12;
inline bool EmcStatusConfig::has_program_units() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcStatusConfig::set_has_program_units() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcStatusConfig::clear_has_program_units() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcStatusConfig::clear_program_units() {
  program_units_ = 1;
  clear_has_program_units();
}
inline ::pb::EmcCanonUnitsType EmcStatusConfig::program_units() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.program_units)
  return static_cast< ::pb::EmcCanonUnitsType >(program_units_);
}
inline void EmcStatusConfig::set_program_units(::pb::EmcCanonUnitsType value) {
  assert(::pb::EmcCanonUnitsType_IsValid(value));
  set_has_program_units();
  program_units_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.program_units)
}

// optional double default_velocity = 13;
inline bool EmcStatusConfig::has_default_velocity() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmcStatusConfig::set_has_default_velocity() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmcStatusConfig::clear_has_default_velocity() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmcStatusConfig::clear_default_velocity() {
  default_velocity_ = 0;
  clear_has_default_velocity();
}
inline double EmcStatusConfig::default_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.default_velocity)
  return default_velocity_;
}
inline void EmcStatusConfig::set_default_velocity(double value) {
  set_has_default_velocity();
  default_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.default_velocity)
}

// repeated .pb.EmcProgramExtension program_extension = 14;
inline int EmcStatusConfig::program_extension_size() const {
  return program_extension_.size();
}
inline void EmcStatusConfig::clear_program_extension() {
  program_extension_.Clear();
}
inline const ::pb::EmcProgramExtension& EmcStatusConfig::program_extension(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.program_extension)
  return program_extension_.Get(index);
}
inline ::pb::EmcProgramExtension* EmcStatusConfig::mutable_program_extension(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.program_extension)
  return program_extension_.Mutable(index);
}
inline ::pb::EmcProgramExtension* EmcStatusConfig::add_program_extension() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusConfig.program_extension)
  return program_extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcProgramExtension >&
EmcStatusConfig::program_extension() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusConfig.program_extension)
  return program_extension_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcProgramExtension >*
EmcStatusConfig::mutable_program_extension() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusConfig.program_extension)
  return &program_extension_;
}

// optional .pb.EmcPositionOffsetType position_offset = 15;
inline bool EmcStatusConfig::has_position_offset() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmcStatusConfig::set_has_position_offset() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmcStatusConfig::clear_has_position_offset() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmcStatusConfig::clear_position_offset() {
  position_offset_ = 1;
  clear_has_position_offset();
}
inline ::pb::EmcPositionOffsetType EmcStatusConfig::position_offset() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.position_offset)
  return static_cast< ::pb::EmcPositionOffsetType >(position_offset_);
}
inline void EmcStatusConfig::set_position_offset(::pb::EmcPositionOffsetType value) {
  assert(::pb::EmcPositionOffsetType_IsValid(value));
  set_has_position_offset();
  position_offset_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.position_offset)
}

// optional .pb.EmcPositionFeedbackType position_feedback = 16;
inline bool EmcStatusConfig::has_position_feedback() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmcStatusConfig::set_has_position_feedback() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmcStatusConfig::clear_has_position_feedback() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmcStatusConfig::clear_position_feedback() {
  position_feedback_ = 1;
  clear_has_position_feedback();
}
inline ::pb::EmcPositionFeedbackType EmcStatusConfig::position_feedback() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.position_feedback)
  return static_cast< ::pb::EmcPositionFeedbackType >(position_feedback_);
}
inline void EmcStatusConfig::set_position_feedback(::pb::EmcPositionFeedbackType value) {
  assert(::pb::EmcPositionFeedbackType_IsValid(value));
  set_has_position_feedback();
  position_feedback_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.position_feedback)
}

// optional double max_feed_override = 17;
inline bool EmcStatusConfig::has_max_feed_override() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EmcStatusConfig::set_has_max_feed_override() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EmcStatusConfig::clear_has_max_feed_override() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EmcStatusConfig::clear_max_feed_override() {
  max_feed_override_ = 0;
  clear_has_max_feed_override();
}
inline double EmcStatusConfig::max_feed_override() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_feed_override)
  return max_feed_override_;
}
inline void EmcStatusConfig::set_max_feed_override(double value) {
  set_has_max_feed_override();
  max_feed_override_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_feed_override)
}

// optional double min_feed_override = 18;
inline bool EmcStatusConfig::has_min_feed_override() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EmcStatusConfig::set_has_min_feed_override() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EmcStatusConfig::clear_has_min_feed_override() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EmcStatusConfig::clear_min_feed_override() {
  min_feed_override_ = 0;
  clear_has_min_feed_override();
}
inline double EmcStatusConfig::min_feed_override() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.min_feed_override)
  return min_feed_override_;
}
inline void EmcStatusConfig::set_min_feed_override(double value) {
  set_has_min_feed_override();
  min_feed_override_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.min_feed_override)
}

// optional double max_spindle_override = 19;
inline bool EmcStatusConfig::has_max_spindle_override() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EmcStatusConfig::set_has_max_spindle_override() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EmcStatusConfig::clear_has_max_spindle_override() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EmcStatusConfig::clear_max_spindle_override() {
  max_spindle_override_ = 0;
  clear_has_max_spindle_override();
}
inline double EmcStatusConfig::max_spindle_override() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_spindle_override)
  return max_spindle_override_;
}
inline void EmcStatusConfig::set_max_spindle_override(double value) {
  set_has_max_spindle_override();
  max_spindle_override_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_spindle_override)
}

// optional double min_spindle_override = 20;
inline bool EmcStatusConfig::has_min_spindle_override() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EmcStatusConfig::set_has_min_spindle_override() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EmcStatusConfig::clear_has_min_spindle_override() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EmcStatusConfig::clear_min_spindle_override() {
  min_spindle_override_ = 0;
  clear_has_min_spindle_override();
}
inline double EmcStatusConfig::min_spindle_override() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.min_spindle_override)
  return min_spindle_override_;
}
inline void EmcStatusConfig::set_min_spindle_override(double value) {
  set_has_min_spindle_override();
  min_spindle_override_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.min_spindle_override)
}

// optional double default_spindle_speed = 21;
inline bool EmcStatusConfig::has_default_spindle_speed() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EmcStatusConfig::set_has_default_spindle_speed() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EmcStatusConfig::clear_has_default_spindle_speed() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EmcStatusConfig::clear_default_spindle_speed() {
  default_spindle_speed_ = 0;
  clear_has_default_spindle_speed();
}
inline double EmcStatusConfig::default_spindle_speed() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.default_spindle_speed)
  return default_spindle_speed_;
}
inline void EmcStatusConfig::set_default_spindle_speed(double value) {
  set_has_default_spindle_speed();
  default_spindle_speed_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.default_spindle_speed)
}

// optional double default_linear_velocity = 22;
inline bool EmcStatusConfig::has_default_linear_velocity() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EmcStatusConfig::set_has_default_linear_velocity() {
  _has_bits_[0] |= 0x00200000u;
}
inline void EmcStatusConfig::clear_has_default_linear_velocity() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void EmcStatusConfig::clear_default_linear_velocity() {
  default_linear_velocity_ = 0;
  clear_has_default_linear_velocity();
}
inline double EmcStatusConfig::default_linear_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.default_linear_velocity)
  return default_linear_velocity_;
}
inline void EmcStatusConfig::set_default_linear_velocity(double value) {
  set_has_default_linear_velocity();
  default_linear_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.default_linear_velocity)
}

// optional double min_velocity = 23;
inline bool EmcStatusConfig::has_min_velocity() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void EmcStatusConfig::set_has_min_velocity() {
  _has_bits_[0] |= 0x00400000u;
}
inline void EmcStatusConfig::clear_has_min_velocity() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void EmcStatusConfig::clear_min_velocity() {
  min_velocity_ = 0;
  clear_has_min_velocity();
}
inline double EmcStatusConfig::min_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.min_velocity)
  return min_velocity_;
}
inline void EmcStatusConfig::set_min_velocity(double value) {
  set_has_min_velocity();
  min_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.min_velocity)
}

// optional double max_linear_velocity = 24;
inline bool EmcStatusConfig::has_max_linear_velocity() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void EmcStatusConfig::set_has_max_linear_velocity() {
  _has_bits_[0] |= 0x00800000u;
}
inline void EmcStatusConfig::clear_has_max_linear_velocity() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void EmcStatusConfig::clear_max_linear_velocity() {
  max_linear_velocity_ = 0;
  clear_has_max_linear_velocity();
}
inline double EmcStatusConfig::max_linear_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_linear_velocity)
  return max_linear_velocity_;
}
inline void EmcStatusConfig::set_max_linear_velocity(double value) {
  set_has_max_linear_velocity();
  max_linear_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_linear_velocity)
}

// optional double min_linear_velocity = 25;
inline bool EmcStatusConfig::has_min_linear_velocity() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void EmcStatusConfig::set_has_min_linear_velocity() {
  _has_bits_[0] |= 0x01000000u;
}
inline void EmcStatusConfig::clear_has_min_linear_velocity() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void EmcStatusConfig::clear_min_linear_velocity() {
  min_linear_velocity_ = 0;
  clear_has_min_linear_velocity();
}
inline double EmcStatusConfig::min_linear_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.min_linear_velocity)
  return min_linear_velocity_;
}
inline void EmcStatusConfig::set_min_linear_velocity(double value) {
  set_has_min_linear_velocity();
  min_linear_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.min_linear_velocity)
}

// optional double default_angular_velocity = 26;
inline bool EmcStatusConfig::has_default_angular_velocity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void EmcStatusConfig::set_has_default_angular_velocity() {
  _has_bits_[0] |= 0x02000000u;
}
inline void EmcStatusConfig::clear_has_default_angular_velocity() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void EmcStatusConfig::clear_default_angular_velocity() {
  default_angular_velocity_ = 0;
  clear_has_default_angular_velocity();
}
inline double EmcStatusConfig::default_angular_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.default_angular_velocity)
  return default_angular_velocity_;
}
inline void EmcStatusConfig::set_default_angular_velocity(double value) {
  set_has_default_angular_velocity();
  default_angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.default_angular_velocity)
}

// optional double max_angular_velocity = 27;
inline bool EmcStatusConfig::has_max_angular_velocity() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void EmcStatusConfig::set_has_max_angular_velocity() {
  _has_bits_[0] |= 0x04000000u;
}
inline void EmcStatusConfig::clear_has_max_angular_velocity() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void EmcStatusConfig::clear_max_angular_velocity() {
  max_angular_velocity_ = 0;
  clear_has_max_angular_velocity();
}
inline double EmcStatusConfig::max_angular_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.max_angular_velocity)
  return max_angular_velocity_;
}
inline void EmcStatusConfig::set_max_angular_velocity(double value) {
  set_has_max_angular_velocity();
  max_angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.max_angular_velocity)
}

// optional double min_angular_velocity = 28;
inline bool EmcStatusConfig::has_min_angular_velocity() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void EmcStatusConfig::set_has_min_angular_velocity() {
  _has_bits_[0] |= 0x08000000u;
}
inline void EmcStatusConfig::clear_has_min_angular_velocity() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void EmcStatusConfig::clear_min_angular_velocity() {
  min_angular_velocity_ = 0;
  clear_has_min_angular_velocity();
}
inline double EmcStatusConfig::min_angular_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.min_angular_velocity)
  return min_angular_velocity_;
}
inline void EmcStatusConfig::set_min_angular_velocity(double value) {
  set_has_min_angular_velocity();
  min_angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.min_angular_velocity)
}

// optional string increments = 29;
inline bool EmcStatusConfig::has_increments() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void EmcStatusConfig::set_has_increments() {
  _has_bits_[0] |= 0x10000000u;
}
inline void EmcStatusConfig::clear_has_increments() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void EmcStatusConfig::clear_increments() {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_->clear();
  }
  clear_has_increments();
}
inline const ::std::string& EmcStatusConfig::increments() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.increments)
  return *increments_;
}
inline void EmcStatusConfig::set_increments(const ::std::string& value) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.increments)
}
inline void EmcStatusConfig::set_increments(const char* value) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfig.increments)
}
inline void EmcStatusConfig::set_increments(const char* value, size_t size) {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  increments_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfig.increments)
}
inline ::std::string* EmcStatusConfig::mutable_increments() {
  set_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    increments_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.increments)
  return increments_;
}
inline ::std::string* EmcStatusConfig::release_increments() {
  clear_has_increments();
  if (increments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = increments_;
    increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfig::set_allocated_increments(::std::string* increments) {
  if (increments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete increments_;
  }
  if (increments) {
    set_has_increments();
    increments_ = increments;
  } else {
    clear_has_increments();
    increments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfig.increments)
}

// optional string grids = 30;
inline bool EmcStatusConfig::has_grids() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void EmcStatusConfig::set_has_grids() {
  _has_bits_[0] |= 0x20000000u;
}
inline void EmcStatusConfig::clear_has_grids() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void EmcStatusConfig::clear_grids() {
  if (grids_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grids_->clear();
  }
  clear_has_grids();
}
inline const ::std::string& EmcStatusConfig::grids() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.grids)
  return *grids_;
}
inline void EmcStatusConfig::set_grids(const ::std::string& value) {
  set_has_grids();
  if (grids_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grids_ = new ::std::string;
  }
  grids_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.grids)
}
inline void EmcStatusConfig::set_grids(const char* value) {
  set_has_grids();
  if (grids_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grids_ = new ::std::string;
  }
  grids_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfig.grids)
}
inline void EmcStatusConfig::set_grids(const char* value, size_t size) {
  set_has_grids();
  if (grids_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grids_ = new ::std::string;
  }
  grids_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfig.grids)
}
inline ::std::string* EmcStatusConfig::mutable_grids() {
  set_has_grids();
  if (grids_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    grids_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.grids)
  return grids_;
}
inline ::std::string* EmcStatusConfig::release_grids() {
  clear_has_grids();
  if (grids_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = grids_;
    grids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfig::set_allocated_grids(::std::string* grids) {
  if (grids_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete grids_;
  }
  if (grids) {
    set_has_grids();
    grids_ = grids;
  } else {
    clear_has_grids();
    grids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfig.grids)
}

// optional bool lathe = 31;
inline bool EmcStatusConfig::has_lathe() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void EmcStatusConfig::set_has_lathe() {
  _has_bits_[0] |= 0x40000000u;
}
inline void EmcStatusConfig::clear_has_lathe() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void EmcStatusConfig::clear_lathe() {
  lathe_ = false;
  clear_has_lathe();
}
inline bool EmcStatusConfig::lathe() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.lathe)
  return lathe_;
}
inline void EmcStatusConfig::set_lathe(bool value) {
  set_has_lathe();
  lathe_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.lathe)
}

// optional string geometry = 32;
inline bool EmcStatusConfig::has_geometry() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void EmcStatusConfig::set_has_geometry() {
  _has_bits_[0] |= 0x80000000u;
}
inline void EmcStatusConfig::clear_has_geometry() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void EmcStatusConfig::clear_geometry() {
  if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_->clear();
  }
  clear_has_geometry();
}
inline const ::std::string& EmcStatusConfig::geometry() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.geometry)
  return *geometry_;
}
inline void EmcStatusConfig::set_geometry(const ::std::string& value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.geometry)
}
inline void EmcStatusConfig::set_geometry(const char* value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfig.geometry)
}
inline void EmcStatusConfig::set_geometry(const char* value, size_t size) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfig.geometry)
}
inline ::std::string* EmcStatusConfig::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    geometry_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.geometry)
  return geometry_;
}
inline ::std::string* EmcStatusConfig::release_geometry() {
  clear_has_geometry();
  if (geometry_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = geometry_;
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfig::set_allocated_geometry(::std::string* geometry) {
  if (geometry_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete geometry_;
  }
  if (geometry) {
    set_has_geometry();
    geometry_ = geometry;
  } else {
    clear_has_geometry();
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfig.geometry)
}

// optional uint32 arcdivision = 33;
inline bool EmcStatusConfig::has_arcdivision() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void EmcStatusConfig::set_has_arcdivision() {
  _has_bits_[1] |= 0x00000001u;
}
inline void EmcStatusConfig::clear_has_arcdivision() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void EmcStatusConfig::clear_arcdivision() {
  arcdivision_ = 0u;
  clear_has_arcdivision();
}
inline ::google::protobuf::uint32 EmcStatusConfig::arcdivision() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.arcdivision)
  return arcdivision_;
}
inline void EmcStatusConfig::set_arcdivision(::google::protobuf::uint32 value) {
  set_has_arcdivision();
  arcdivision_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.arcdivision)
}

// optional bool no_force_homing = 34;
inline bool EmcStatusConfig::has_no_force_homing() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void EmcStatusConfig::set_has_no_force_homing() {
  _has_bits_[1] |= 0x00000002u;
}
inline void EmcStatusConfig::clear_has_no_force_homing() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void EmcStatusConfig::clear_no_force_homing() {
  no_force_homing_ = false;
  clear_has_no_force_homing();
}
inline bool EmcStatusConfig::no_force_homing() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.no_force_homing)
  return no_force_homing_;
}
inline void EmcStatusConfig::set_no_force_homing(bool value) {
  set_has_no_force_homing();
  no_force_homing_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.no_force_homing)
}

// optional string remote_path = 35;
inline bool EmcStatusConfig::has_remote_path() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void EmcStatusConfig::set_has_remote_path() {
  _has_bits_[1] |= 0x00000004u;
}
inline void EmcStatusConfig::clear_has_remote_path() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void EmcStatusConfig::clear_remote_path() {
  if (remote_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_path_->clear();
  }
  clear_has_remote_path();
}
inline const ::std::string& EmcStatusConfig::remote_path() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.remote_path)
  return *remote_path_;
}
inline void EmcStatusConfig::set_remote_path(const ::std::string& value) {
  set_has_remote_path();
  if (remote_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_path_ = new ::std::string;
  }
  remote_path_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.remote_path)
}
inline void EmcStatusConfig::set_remote_path(const char* value) {
  set_has_remote_path();
  if (remote_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_path_ = new ::std::string;
  }
  remote_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfig.remote_path)
}
inline void EmcStatusConfig::set_remote_path(const char* value, size_t size) {
  set_has_remote_path();
  if (remote_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_path_ = new ::std::string;
  }
  remote_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfig.remote_path)
}
inline ::std::string* EmcStatusConfig::mutable_remote_path() {
  set_has_remote_path();
  if (remote_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.remote_path)
  return remote_path_;
}
inline ::std::string* EmcStatusConfig::release_remote_path() {
  clear_has_remote_path();
  if (remote_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_path_;
    remote_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfig::set_allocated_remote_path(::std::string* remote_path) {
  if (remote_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_path_;
  }
  if (remote_path) {
    set_has_remote_path();
    remote_path_ = remote_path;
  } else {
    clear_has_remote_path();
    remote_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfig.remote_path)
}

// optional .pb.EmcTimeUnitsType time_units = 36;
inline bool EmcStatusConfig::has_time_units() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void EmcStatusConfig::set_has_time_units() {
  _has_bits_[1] |= 0x00000008u;
}
inline void EmcStatusConfig::clear_has_time_units() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void EmcStatusConfig::clear_time_units() {
  time_units_ = 1;
  clear_has_time_units();
}
inline ::pb::EmcTimeUnitsType EmcStatusConfig::time_units() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.time_units)
  return static_cast< ::pb::EmcTimeUnitsType >(time_units_);
}
inline void EmcStatusConfig::set_time_units(::pb::EmcTimeUnitsType value) {
  assert(::pb::EmcTimeUnitsType_IsValid(value));
  set_has_time_units();
  time_units_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.time_units)
}

// optional string name = 37;
inline bool EmcStatusConfig::has_name() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void EmcStatusConfig::set_has_name() {
  _has_bits_[1] |= 0x00000010u;
}
inline void EmcStatusConfig::clear_has_name() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void EmcStatusConfig::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EmcStatusConfig::name() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.name)
  return *name_;
}
inline void EmcStatusConfig::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusConfig.name)
}
inline void EmcStatusConfig::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusConfig.name)
}
inline void EmcStatusConfig::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusConfig.name)
}
inline ::std::string* EmcStatusConfig::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.name)
  return name_;
}
inline ::std::string* EmcStatusConfig::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusConfig::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusConfig.name)
}

// repeated .pb.EmcStatusUserCommand user_command = 38;
inline int EmcStatusConfig::user_command_size() const {
  return user_command_.size();
}
inline void EmcStatusConfig::clear_user_command() {
  user_command_.Clear();
}
inline const ::pb::EmcStatusUserCommand& EmcStatusConfig::user_command(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusConfig.user_command)
  return user_command_.Get(index);
}
inline ::pb::EmcStatusUserCommand* EmcStatusConfig::mutable_user_command(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusConfig.user_command)
  return user_command_.Mutable(index);
}
inline ::pb::EmcStatusUserCommand* EmcStatusConfig::add_user_command() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusConfig.user_command)
  return user_command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusUserCommand >&
EmcStatusConfig::user_command() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusConfig.user_command)
  return user_command_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusUserCommand >*
EmcStatusConfig::mutable_user_command() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusConfig.user_command)
  return &user_command_;
}

// -------------------------------------------------------------------

// EmcStatusMotion

// optional int32 active_queue = 1;
inline bool EmcStatusMotion::has_active_queue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusMotion::set_has_active_queue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusMotion::clear_has_active_queue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusMotion::clear_active_queue() {
  active_queue_ = 0;
  clear_has_active_queue();
}
inline ::google::protobuf::int32 EmcStatusMotion::active_queue() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.active_queue)
  return active_queue_;
}
inline void EmcStatusMotion::set_active_queue(::google::protobuf::int32 value) {
  set_has_active_queue();
  active_queue_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.active_queue)
}

// optional .pb.Position actual_position = 2;
inline bool EmcStatusMotion::has_actual_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusMotion::set_has_actual_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusMotion::clear_has_actual_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusMotion::clear_actual_position() {
  if (actual_position_ != NULL) actual_position_->::pb::Position::Clear();
  clear_has_actual_position();
}
inline const ::pb::Position& EmcStatusMotion::actual_position() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.actual_position)
  return actual_position_ != NULL ? *actual_position_ : *default_instance_->actual_position_;
}
inline ::pb::Position* EmcStatusMotion::mutable_actual_position() {
  set_has_actual_position();
  if (actual_position_ == NULL) actual_position_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.actual_position)
  return actual_position_;
}
inline ::pb::Position* EmcStatusMotion::release_actual_position() {
  clear_has_actual_position();
  ::pb::Position* temp = actual_position_;
  actual_position_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_actual_position(::pb::Position* actual_position) {
  delete actual_position_;
  actual_position_ = actual_position;
  if (actual_position) {
    set_has_actual_position();
  } else {
    clear_has_actual_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.actual_position)
}

// optional bool adaptive_feed_enabled = 3;
inline bool EmcStatusMotion::has_adaptive_feed_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusMotion::set_has_adaptive_feed_enabled() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusMotion::clear_has_adaptive_feed_enabled() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusMotion::clear_adaptive_feed_enabled() {
  adaptive_feed_enabled_ = false;
  clear_has_adaptive_feed_enabled();
}
inline bool EmcStatusMotion::adaptive_feed_enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.adaptive_feed_enabled)
  return adaptive_feed_enabled_;
}
inline void EmcStatusMotion::set_adaptive_feed_enabled(bool value) {
  set_has_adaptive_feed_enabled();
  adaptive_feed_enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.adaptive_feed_enabled)
}

// repeated .pb.EmcStatusAnalogIO ain = 4;
inline int EmcStatusMotion::ain_size() const {
  return ain_.size();
}
inline void EmcStatusMotion::clear_ain() {
  ain_.Clear();
}
inline const ::pb::EmcStatusAnalogIO& EmcStatusMotion::ain(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.ain)
  return ain_.Get(index);
}
inline ::pb::EmcStatusAnalogIO* EmcStatusMotion::mutable_ain(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.ain)
  return ain_.Mutable(index);
}
inline ::pb::EmcStatusAnalogIO* EmcStatusMotion::add_ain() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.ain)
  return ain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >&
EmcStatusMotion::ain() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.ain)
  return ain_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >*
EmcStatusMotion::mutable_ain() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.ain)
  return &ain_;
}

// repeated .pb.EmcStatusAnalogIO aout = 5;
inline int EmcStatusMotion::aout_size() const {
  return aout_.size();
}
inline void EmcStatusMotion::clear_aout() {
  aout_.Clear();
}
inline const ::pb::EmcStatusAnalogIO& EmcStatusMotion::aout(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.aout)
  return aout_.Get(index);
}
inline ::pb::EmcStatusAnalogIO* EmcStatusMotion::mutable_aout(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.aout)
  return aout_.Mutable(index);
}
inline ::pb::EmcStatusAnalogIO* EmcStatusMotion::add_aout() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.aout)
  return aout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >&
EmcStatusMotion::aout() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.aout)
  return aout_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusAnalogIO >*
EmcStatusMotion::mutable_aout() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.aout)
  return &aout_;
}

// repeated .pb.EmcStatusMotionAxis axis = 6;
inline int EmcStatusMotion::axis_size() const {
  return axis_.size();
}
inline void EmcStatusMotion::clear_axis() {
  axis_.Clear();
}
inline const ::pb::EmcStatusMotionAxis& EmcStatusMotion::axis(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.axis)
  return axis_.Get(index);
}
inline ::pb::EmcStatusMotionAxis* EmcStatusMotion::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.axis)
  return axis_.Mutable(index);
}
inline ::pb::EmcStatusMotionAxis* EmcStatusMotion::add_axis() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.axis)
  return axis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMotionAxis >&
EmcStatusMotion::axis() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.axis)
  return axis_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMotionAxis >*
EmcStatusMotion::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.axis)
  return &axis_;
}

// optional bool block_delete = 7;
inline bool EmcStatusMotion::has_block_delete() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusMotion::set_has_block_delete() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusMotion::clear_has_block_delete() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusMotion::clear_block_delete() {
  block_delete_ = false;
  clear_has_block_delete();
}
inline bool EmcStatusMotion::block_delete() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.block_delete)
  return block_delete_;
}
inline void EmcStatusMotion::set_block_delete(bool value) {
  set_has_block_delete();
  block_delete_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.block_delete)
}

// optional int32 current_line = 8;
inline bool EmcStatusMotion::has_current_line() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusMotion::set_has_current_line() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusMotion::clear_has_current_line() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusMotion::clear_current_line() {
  current_line_ = 0;
  clear_has_current_line();
}
inline ::google::protobuf::int32 EmcStatusMotion::current_line() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.current_line)
  return current_line_;
}
inline void EmcStatusMotion::set_current_line(::google::protobuf::int32 value) {
  set_has_current_line();
  current_line_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.current_line)
}

// optional double current_vel = 9;
inline bool EmcStatusMotion::has_current_vel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcStatusMotion::set_has_current_vel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcStatusMotion::clear_has_current_vel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcStatusMotion::clear_current_vel() {
  current_vel_ = 0;
  clear_has_current_vel();
}
inline double EmcStatusMotion::current_vel() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.current_vel)
  return current_vel_;
}
inline void EmcStatusMotion::set_current_vel(double value) {
  set_has_current_vel();
  current_vel_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.current_vel)
}

// optional double delay_left = 10;
inline bool EmcStatusMotion::has_delay_left() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcStatusMotion::set_has_delay_left() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcStatusMotion::clear_has_delay_left() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcStatusMotion::clear_delay_left() {
  delay_left_ = 0;
  clear_has_delay_left();
}
inline double EmcStatusMotion::delay_left() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.delay_left)
  return delay_left_;
}
inline void EmcStatusMotion::set_delay_left(double value) {
  set_has_delay_left();
  delay_left_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.delay_left)
}

// repeated .pb.EmcStatusDigitalIO din = 11;
inline int EmcStatusMotion::din_size() const {
  return din_.size();
}
inline void EmcStatusMotion::clear_din() {
  din_.Clear();
}
inline const ::pb::EmcStatusDigitalIO& EmcStatusMotion::din(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.din)
  return din_.Get(index);
}
inline ::pb::EmcStatusDigitalIO* EmcStatusMotion::mutable_din(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.din)
  return din_.Mutable(index);
}
inline ::pb::EmcStatusDigitalIO* EmcStatusMotion::add_din() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.din)
  return din_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >&
EmcStatusMotion::din() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.din)
  return din_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >*
EmcStatusMotion::mutable_din() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.din)
  return &din_;
}

// optional double distance_to_go = 12;
inline bool EmcStatusMotion::has_distance_to_go() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcStatusMotion::set_has_distance_to_go() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcStatusMotion::clear_has_distance_to_go() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcStatusMotion::clear_distance_to_go() {
  distance_to_go_ = 0;
  clear_has_distance_to_go();
}
inline double EmcStatusMotion::distance_to_go() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.distance_to_go)
  return distance_to_go_;
}
inline void EmcStatusMotion::set_distance_to_go(double value) {
  set_has_distance_to_go();
  distance_to_go_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.distance_to_go)
}

// repeated .pb.EmcStatusDigitalIO dout = 13;
inline int EmcStatusMotion::dout_size() const {
  return dout_.size();
}
inline void EmcStatusMotion::clear_dout() {
  dout_.Clear();
}
inline const ::pb::EmcStatusDigitalIO& EmcStatusMotion::dout(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.dout)
  return dout_.Get(index);
}
inline ::pb::EmcStatusDigitalIO* EmcStatusMotion::mutable_dout(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.dout)
  return dout_.Mutable(index);
}
inline ::pb::EmcStatusDigitalIO* EmcStatusMotion::add_dout() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.dout)
  return dout_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >&
EmcStatusMotion::dout() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.dout)
  return dout_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusDigitalIO >*
EmcStatusMotion::mutable_dout() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.dout)
  return &dout_;
}

// optional .pb.Position dtg = 14;
inline bool EmcStatusMotion::has_dtg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmcStatusMotion::set_has_dtg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmcStatusMotion::clear_has_dtg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmcStatusMotion::clear_dtg() {
  if (dtg_ != NULL) dtg_->::pb::Position::Clear();
  clear_has_dtg();
}
inline const ::pb::Position& EmcStatusMotion::dtg() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.dtg)
  return dtg_ != NULL ? *dtg_ : *default_instance_->dtg_;
}
inline ::pb::Position* EmcStatusMotion::mutable_dtg() {
  set_has_dtg();
  if (dtg_ == NULL) dtg_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.dtg)
  return dtg_;
}
inline ::pb::Position* EmcStatusMotion::release_dtg() {
  clear_has_dtg();
  ::pb::Position* temp = dtg_;
  dtg_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_dtg(::pb::Position* dtg) {
  delete dtg_;
  dtg_ = dtg;
  if (dtg) {
    set_has_dtg();
  } else {
    clear_has_dtg();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.dtg)
}

// optional bool enabled = 15;
inline bool EmcStatusMotion::has_enabled() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmcStatusMotion::set_has_enabled() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmcStatusMotion::clear_has_enabled() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmcStatusMotion::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool EmcStatusMotion::enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.enabled)
  return enabled_;
}
inline void EmcStatusMotion::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.enabled)
}

// optional bool feed_hold_enabled = 16;
inline bool EmcStatusMotion::has_feed_hold_enabled() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmcStatusMotion::set_has_feed_hold_enabled() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmcStatusMotion::clear_has_feed_hold_enabled() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmcStatusMotion::clear_feed_hold_enabled() {
  feed_hold_enabled_ = false;
  clear_has_feed_hold_enabled();
}
inline bool EmcStatusMotion::feed_hold_enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.feed_hold_enabled)
  return feed_hold_enabled_;
}
inline void EmcStatusMotion::set_feed_hold_enabled(bool value) {
  set_has_feed_hold_enabled();
  feed_hold_enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.feed_hold_enabled)
}

// optional bool feed_override_enabled = 17;
inline bool EmcStatusMotion::has_feed_override_enabled() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EmcStatusMotion::set_has_feed_override_enabled() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EmcStatusMotion::clear_has_feed_override_enabled() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EmcStatusMotion::clear_feed_override_enabled() {
  feed_override_enabled_ = false;
  clear_has_feed_override_enabled();
}
inline bool EmcStatusMotion::feed_override_enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.feed_override_enabled)
  return feed_override_enabled_;
}
inline void EmcStatusMotion::set_feed_override_enabled(bool value) {
  set_has_feed_override_enabled();
  feed_override_enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.feed_override_enabled)
}

// optional double feedrate = 18;
inline bool EmcStatusMotion::has_feedrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EmcStatusMotion::set_has_feedrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EmcStatusMotion::clear_has_feedrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EmcStatusMotion::clear_feedrate() {
  feedrate_ = 0;
  clear_has_feedrate();
}
inline double EmcStatusMotion::feedrate() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.feedrate)
  return feedrate_;
}
inline void EmcStatusMotion::set_feedrate(double value) {
  set_has_feedrate();
  feedrate_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.feedrate)
}

// optional .pb.OriginIndex g5x_index = 19;
inline bool EmcStatusMotion::has_g5x_index() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EmcStatusMotion::set_has_g5x_index() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EmcStatusMotion::clear_has_g5x_index() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EmcStatusMotion::clear_g5x_index() {
  g5x_index_ = 0;
  clear_has_g5x_index();
}
inline ::pb::OriginIndex EmcStatusMotion::g5x_index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.g5x_index)
  return static_cast< ::pb::OriginIndex >(g5x_index_);
}
inline void EmcStatusMotion::set_g5x_index(::pb::OriginIndex value) {
  assert(::pb::OriginIndex_IsValid(value));
  set_has_g5x_index();
  g5x_index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.g5x_index)
}

// optional .pb.Position g5x_offset = 20;
inline bool EmcStatusMotion::has_g5x_offset() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EmcStatusMotion::set_has_g5x_offset() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EmcStatusMotion::clear_has_g5x_offset() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EmcStatusMotion::clear_g5x_offset() {
  if (g5x_offset_ != NULL) g5x_offset_->::pb::Position::Clear();
  clear_has_g5x_offset();
}
inline const ::pb::Position& EmcStatusMotion::g5x_offset() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.g5x_offset)
  return g5x_offset_ != NULL ? *g5x_offset_ : *default_instance_->g5x_offset_;
}
inline ::pb::Position* EmcStatusMotion::mutable_g5x_offset() {
  set_has_g5x_offset();
  if (g5x_offset_ == NULL) g5x_offset_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.g5x_offset)
  return g5x_offset_;
}
inline ::pb::Position* EmcStatusMotion::release_g5x_offset() {
  clear_has_g5x_offset();
  ::pb::Position* temp = g5x_offset_;
  g5x_offset_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_g5x_offset(::pb::Position* g5x_offset) {
  delete g5x_offset_;
  g5x_offset_ = g5x_offset;
  if (g5x_offset) {
    set_has_g5x_offset();
  } else {
    clear_has_g5x_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.g5x_offset)
}

// optional .pb.Position g92_offset = 21;
inline bool EmcStatusMotion::has_g92_offset() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EmcStatusMotion::set_has_g92_offset() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EmcStatusMotion::clear_has_g92_offset() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EmcStatusMotion::clear_g92_offset() {
  if (g92_offset_ != NULL) g92_offset_->::pb::Position::Clear();
  clear_has_g92_offset();
}
inline const ::pb::Position& EmcStatusMotion::g92_offset() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.g92_offset)
  return g92_offset_ != NULL ? *g92_offset_ : *default_instance_->g92_offset_;
}
inline ::pb::Position* EmcStatusMotion::mutable_g92_offset() {
  set_has_g92_offset();
  if (g92_offset_ == NULL) g92_offset_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.g92_offset)
  return g92_offset_;
}
inline ::pb::Position* EmcStatusMotion::release_g92_offset() {
  clear_has_g92_offset();
  ::pb::Position* temp = g92_offset_;
  g92_offset_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_g92_offset(::pb::Position* g92_offset) {
  delete g92_offset_;
  g92_offset_ = g92_offset;
  if (g92_offset) {
    set_has_g92_offset();
  } else {
    clear_has_g92_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.g92_offset)
}

// optional int32 id = 23;
inline bool EmcStatusMotion::has_id() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EmcStatusMotion::set_has_id() {
  _has_bits_[0] |= 0x00200000u;
}
inline void EmcStatusMotion::clear_has_id() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void EmcStatusMotion::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EmcStatusMotion::id() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.id)
  return id_;
}
inline void EmcStatusMotion::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.id)
}

// optional bool inpos = 24;
inline bool EmcStatusMotion::has_inpos() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void EmcStatusMotion::set_has_inpos() {
  _has_bits_[0] |= 0x00400000u;
}
inline void EmcStatusMotion::clear_has_inpos() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void EmcStatusMotion::clear_inpos() {
  inpos_ = false;
  clear_has_inpos();
}
inline bool EmcStatusMotion::inpos() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.inpos)
  return inpos_;
}
inline void EmcStatusMotion::set_inpos(bool value) {
  set_has_inpos();
  inpos_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.inpos)
}

// optional .pb.Position joint_actual_position = 25;
inline bool EmcStatusMotion::has_joint_actual_position() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void EmcStatusMotion::set_has_joint_actual_position() {
  _has_bits_[0] |= 0x00800000u;
}
inline void EmcStatusMotion::clear_has_joint_actual_position() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void EmcStatusMotion::clear_joint_actual_position() {
  if (joint_actual_position_ != NULL) joint_actual_position_->::pb::Position::Clear();
  clear_has_joint_actual_position();
}
inline const ::pb::Position& EmcStatusMotion::joint_actual_position() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.joint_actual_position)
  return joint_actual_position_ != NULL ? *joint_actual_position_ : *default_instance_->joint_actual_position_;
}
inline ::pb::Position* EmcStatusMotion::mutable_joint_actual_position() {
  set_has_joint_actual_position();
  if (joint_actual_position_ == NULL) joint_actual_position_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.joint_actual_position)
  return joint_actual_position_;
}
inline ::pb::Position* EmcStatusMotion::release_joint_actual_position() {
  clear_has_joint_actual_position();
  ::pb::Position* temp = joint_actual_position_;
  joint_actual_position_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_joint_actual_position(::pb::Position* joint_actual_position) {
  delete joint_actual_position_;
  joint_actual_position_ = joint_actual_position;
  if (joint_actual_position) {
    set_has_joint_actual_position();
  } else {
    clear_has_joint_actual_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.joint_actual_position)
}

// optional .pb.Position joint_position = 26;
inline bool EmcStatusMotion::has_joint_position() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void EmcStatusMotion::set_has_joint_position() {
  _has_bits_[0] |= 0x01000000u;
}
inline void EmcStatusMotion::clear_has_joint_position() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void EmcStatusMotion::clear_joint_position() {
  if (joint_position_ != NULL) joint_position_->::pb::Position::Clear();
  clear_has_joint_position();
}
inline const ::pb::Position& EmcStatusMotion::joint_position() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.joint_position)
  return joint_position_ != NULL ? *joint_position_ : *default_instance_->joint_position_;
}
inline ::pb::Position* EmcStatusMotion::mutable_joint_position() {
  set_has_joint_position();
  if (joint_position_ == NULL) joint_position_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.joint_position)
  return joint_position_;
}
inline ::pb::Position* EmcStatusMotion::release_joint_position() {
  clear_has_joint_position();
  ::pb::Position* temp = joint_position_;
  joint_position_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_joint_position(::pb::Position* joint_position) {
  delete joint_position_;
  joint_position_ = joint_position;
  if (joint_position) {
    set_has_joint_position();
  } else {
    clear_has_joint_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.joint_position)
}

// repeated .pb.EmcStatusLimit limit = 27;
inline int EmcStatusMotion::limit_size() const {
  return limit_.size();
}
inline void EmcStatusMotion::clear_limit() {
  limit_.Clear();
}
inline const ::pb::EmcStatusLimit& EmcStatusMotion::limit(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.limit)
  return limit_.Get(index);
}
inline ::pb::EmcStatusLimit* EmcStatusMotion::mutable_limit(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.limit)
  return limit_.Mutable(index);
}
inline ::pb::EmcStatusLimit* EmcStatusMotion::add_limit() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusMotion.limit)
  return limit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusLimit >&
EmcStatusMotion::limit() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusMotion.limit)
  return limit_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusLimit >*
EmcStatusMotion::mutable_limit() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusMotion.limit)
  return &limit_;
}

// optional int32 motion_line = 28;
inline bool EmcStatusMotion::has_motion_line() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void EmcStatusMotion::set_has_motion_line() {
  _has_bits_[0] |= 0x04000000u;
}
inline void EmcStatusMotion::clear_has_motion_line() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void EmcStatusMotion::clear_motion_line() {
  motion_line_ = 0;
  clear_has_motion_line();
}
inline ::google::protobuf::int32 EmcStatusMotion::motion_line() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.motion_line)
  return motion_line_;
}
inline void EmcStatusMotion::set_motion_line(::google::protobuf::int32 value) {
  set_has_motion_line();
  motion_line_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.motion_line)
}

// optional .pb.MotionType motion_type = 29;
inline bool EmcStatusMotion::has_motion_type() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void EmcStatusMotion::set_has_motion_type() {
  _has_bits_[0] |= 0x08000000u;
}
inline void EmcStatusMotion::clear_has_motion_type() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void EmcStatusMotion::clear_motion_type() {
  motion_type_ = 0;
  clear_has_motion_type();
}
inline ::pb::MotionType EmcStatusMotion::motion_type() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.motion_type)
  return static_cast< ::pb::MotionType >(motion_type_);
}
inline void EmcStatusMotion::set_motion_type(::pb::MotionType value) {
  assert(::pb::MotionType_IsValid(value));
  set_has_motion_type();
  motion_type_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.motion_type)
}

// optional .pb.EmcTrajectoryModeType motion_mode = 30;
inline bool EmcStatusMotion::has_motion_mode() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void EmcStatusMotion::set_has_motion_mode() {
  _has_bits_[0] |= 0x10000000u;
}
inline void EmcStatusMotion::clear_has_motion_mode() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void EmcStatusMotion::clear_motion_mode() {
  motion_mode_ = 1;
  clear_has_motion_mode();
}
inline ::pb::EmcTrajectoryModeType EmcStatusMotion::motion_mode() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.motion_mode)
  return static_cast< ::pb::EmcTrajectoryModeType >(motion_mode_);
}
inline void EmcStatusMotion::set_motion_mode(::pb::EmcTrajectoryModeType value) {
  assert(::pb::EmcTrajectoryModeType_IsValid(value));
  set_has_motion_mode();
  motion_mode_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.motion_mode)
}

// optional bool paused = 31;
inline bool EmcStatusMotion::has_paused() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void EmcStatusMotion::set_has_paused() {
  _has_bits_[0] |= 0x20000000u;
}
inline void EmcStatusMotion::clear_has_paused() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void EmcStatusMotion::clear_paused() {
  paused_ = false;
  clear_has_paused();
}
inline bool EmcStatusMotion::paused() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.paused)
  return paused_;
}
inline void EmcStatusMotion::set_paused(bool value) {
  set_has_paused();
  paused_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.paused)
}

// optional .pb.Position position = 32;
inline bool EmcStatusMotion::has_position() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void EmcStatusMotion::set_has_position() {
  _has_bits_[0] |= 0x40000000u;
}
inline void EmcStatusMotion::clear_has_position() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void EmcStatusMotion::clear_position() {
  if (position_ != NULL) position_->::pb::Position::Clear();
  clear_has_position();
}
inline const ::pb::Position& EmcStatusMotion::position() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::pb::Position* EmcStatusMotion::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.position)
  return position_;
}
inline ::pb::Position* EmcStatusMotion::release_position() {
  clear_has_position();
  ::pb::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_position(::pb::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.position)
}

// optional bool probe_tripped = 33;
inline bool EmcStatusMotion::has_probe_tripped() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void EmcStatusMotion::set_has_probe_tripped() {
  _has_bits_[0] |= 0x80000000u;
}
inline void EmcStatusMotion::clear_has_probe_tripped() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void EmcStatusMotion::clear_probe_tripped() {
  probe_tripped_ = false;
  clear_has_probe_tripped();
}
inline bool EmcStatusMotion::probe_tripped() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.probe_tripped)
  return probe_tripped_;
}
inline void EmcStatusMotion::set_probe_tripped(bool value) {
  set_has_probe_tripped();
  probe_tripped_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.probe_tripped)
}

// optional int32 probe_val = 34;
inline bool EmcStatusMotion::has_probe_val() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void EmcStatusMotion::set_has_probe_val() {
  _has_bits_[1] |= 0x00000001u;
}
inline void EmcStatusMotion::clear_has_probe_val() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void EmcStatusMotion::clear_probe_val() {
  probe_val_ = 0;
  clear_has_probe_val();
}
inline ::google::protobuf::int32 EmcStatusMotion::probe_val() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.probe_val)
  return probe_val_;
}
inline void EmcStatusMotion::set_probe_val(::google::protobuf::int32 value) {
  set_has_probe_val();
  probe_val_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.probe_val)
}

// optional .pb.Position probed_position = 35;
inline bool EmcStatusMotion::has_probed_position() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void EmcStatusMotion::set_has_probed_position() {
  _has_bits_[1] |= 0x00000002u;
}
inline void EmcStatusMotion::clear_has_probed_position() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void EmcStatusMotion::clear_probed_position() {
  if (probed_position_ != NULL) probed_position_->::pb::Position::Clear();
  clear_has_probed_position();
}
inline const ::pb::Position& EmcStatusMotion::probed_position() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.probed_position)
  return probed_position_ != NULL ? *probed_position_ : *default_instance_->probed_position_;
}
inline ::pb::Position* EmcStatusMotion::mutable_probed_position() {
  set_has_probed_position();
  if (probed_position_ == NULL) probed_position_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusMotion.probed_position)
  return probed_position_;
}
inline ::pb::Position* EmcStatusMotion::release_probed_position() {
  clear_has_probed_position();
  ::pb::Position* temp = probed_position_;
  probed_position_ = NULL;
  return temp;
}
inline void EmcStatusMotion::set_allocated_probed_position(::pb::Position* probed_position) {
  delete probed_position_;
  probed_position_ = probed_position;
  if (probed_position) {
    set_has_probed_position();
  } else {
    clear_has_probed_position();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusMotion.probed_position)
}

// optional bool probing = 36;
inline bool EmcStatusMotion::has_probing() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void EmcStatusMotion::set_has_probing() {
  _has_bits_[1] |= 0x00000004u;
}
inline void EmcStatusMotion::clear_has_probing() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void EmcStatusMotion::clear_probing() {
  probing_ = false;
  clear_has_probing();
}
inline bool EmcStatusMotion::probing() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.probing)
  return probing_;
}
inline void EmcStatusMotion::set_probing(bool value) {
  set_has_probing();
  probing_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.probing)
}

// optional int32 queue = 37;
inline bool EmcStatusMotion::has_queue() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void EmcStatusMotion::set_has_queue() {
  _has_bits_[1] |= 0x00000008u;
}
inline void EmcStatusMotion::clear_has_queue() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void EmcStatusMotion::clear_queue() {
  queue_ = 0;
  clear_has_queue();
}
inline ::google::protobuf::int32 EmcStatusMotion::queue() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.queue)
  return queue_;
}
inline void EmcStatusMotion::set_queue(::google::protobuf::int32 value) {
  set_has_queue();
  queue_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.queue)
}

// optional bool queue_full = 38;
inline bool EmcStatusMotion::has_queue_full() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void EmcStatusMotion::set_has_queue_full() {
  _has_bits_[1] |= 0x00000010u;
}
inline void EmcStatusMotion::clear_has_queue_full() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void EmcStatusMotion::clear_queue_full() {
  queue_full_ = false;
  clear_has_queue_full();
}
inline bool EmcStatusMotion::queue_full() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.queue_full)
  return queue_full_;
}
inline void EmcStatusMotion::set_queue_full(bool value) {
  set_has_queue_full();
  queue_full_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.queue_full)
}

// optional double rotation_xy = 39;
inline bool EmcStatusMotion::has_rotation_xy() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void EmcStatusMotion::set_has_rotation_xy() {
  _has_bits_[1] |= 0x00000020u;
}
inline void EmcStatusMotion::clear_has_rotation_xy() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void EmcStatusMotion::clear_rotation_xy() {
  rotation_xy_ = 0;
  clear_has_rotation_xy();
}
inline double EmcStatusMotion::rotation_xy() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.rotation_xy)
  return rotation_xy_;
}
inline void EmcStatusMotion::set_rotation_xy(double value) {
  set_has_rotation_xy();
  rotation_xy_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.rotation_xy)
}

// optional bool spindle_brake = 40;
inline bool EmcStatusMotion::has_spindle_brake() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_brake() {
  _has_bits_[1] |= 0x00000040u;
}
inline void EmcStatusMotion::clear_has_spindle_brake() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void EmcStatusMotion::clear_spindle_brake() {
  spindle_brake_ = false;
  clear_has_spindle_brake();
}
inline bool EmcStatusMotion::spindle_brake() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_brake)
  return spindle_brake_;
}
inline void EmcStatusMotion::set_spindle_brake(bool value) {
  set_has_spindle_brake();
  spindle_brake_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_brake)
}

// optional int32 spindle_direction = 41;
inline bool EmcStatusMotion::has_spindle_direction() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_direction() {
  _has_bits_[1] |= 0x00000080u;
}
inline void EmcStatusMotion::clear_has_spindle_direction() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void EmcStatusMotion::clear_spindle_direction() {
  spindle_direction_ = 0;
  clear_has_spindle_direction();
}
inline ::google::protobuf::int32 EmcStatusMotion::spindle_direction() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_direction)
  return spindle_direction_;
}
inline void EmcStatusMotion::set_spindle_direction(::google::protobuf::int32 value) {
  set_has_spindle_direction();
  spindle_direction_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_direction)
}

// optional bool spindle_enabled = 42;
inline bool EmcStatusMotion::has_spindle_enabled() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_enabled() {
  _has_bits_[1] |= 0x00000100u;
}
inline void EmcStatusMotion::clear_has_spindle_enabled() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void EmcStatusMotion::clear_spindle_enabled() {
  spindle_enabled_ = false;
  clear_has_spindle_enabled();
}
inline bool EmcStatusMotion::spindle_enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_enabled)
  return spindle_enabled_;
}
inline void EmcStatusMotion::set_spindle_enabled(bool value) {
  set_has_spindle_enabled();
  spindle_enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_enabled)
}

// optional int32 spindle_increasing = 43;
inline bool EmcStatusMotion::has_spindle_increasing() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_increasing() {
  _has_bits_[1] |= 0x00000200u;
}
inline void EmcStatusMotion::clear_has_spindle_increasing() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void EmcStatusMotion::clear_spindle_increasing() {
  spindle_increasing_ = 0;
  clear_has_spindle_increasing();
}
inline ::google::protobuf::int32 EmcStatusMotion::spindle_increasing() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_increasing)
  return spindle_increasing_;
}
inline void EmcStatusMotion::set_spindle_increasing(::google::protobuf::int32 value) {
  set_has_spindle_increasing();
  spindle_increasing_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_increasing)
}

// optional bool spindle_override_enabled = 44;
inline bool EmcStatusMotion::has_spindle_override_enabled() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_override_enabled() {
  _has_bits_[1] |= 0x00000400u;
}
inline void EmcStatusMotion::clear_has_spindle_override_enabled() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void EmcStatusMotion::clear_spindle_override_enabled() {
  spindle_override_enabled_ = false;
  clear_has_spindle_override_enabled();
}
inline bool EmcStatusMotion::spindle_override_enabled() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_override_enabled)
  return spindle_override_enabled_;
}
inline void EmcStatusMotion::set_spindle_override_enabled(bool value) {
  set_has_spindle_override_enabled();
  spindle_override_enabled_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_override_enabled)
}

// optional double spindle_speed = 45;
inline bool EmcStatusMotion::has_spindle_speed() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void EmcStatusMotion::set_has_spindle_speed() {
  _has_bits_[1] |= 0x00000800u;
}
inline void EmcStatusMotion::clear_has_spindle_speed() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void EmcStatusMotion::clear_spindle_speed() {
  spindle_speed_ = 0;
  clear_has_spindle_speed();
}
inline double EmcStatusMotion::spindle_speed() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindle_speed)
  return spindle_speed_;
}
inline void EmcStatusMotion::set_spindle_speed(double value) {
  set_has_spindle_speed();
  spindle_speed_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindle_speed)
}

// optional double spindlerate = 46;
inline bool EmcStatusMotion::has_spindlerate() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void EmcStatusMotion::set_has_spindlerate() {
  _has_bits_[1] |= 0x00001000u;
}
inline void EmcStatusMotion::clear_has_spindlerate() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void EmcStatusMotion::clear_spindlerate() {
  spindlerate_ = 0;
  clear_has_spindlerate();
}
inline double EmcStatusMotion::spindlerate() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.spindlerate)
  return spindlerate_;
}
inline void EmcStatusMotion::set_spindlerate(double value) {
  set_has_spindlerate();
  spindlerate_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.spindlerate)
}

// optional .pb.RCS_STATUS state = 47;
inline bool EmcStatusMotion::has_state() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void EmcStatusMotion::set_has_state() {
  _has_bits_[1] |= 0x00002000u;
}
inline void EmcStatusMotion::clear_has_state() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void EmcStatusMotion::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::pb::RCS_STATUS EmcStatusMotion::state() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.state)
  return static_cast< ::pb::RCS_STATUS >(state_);
}
inline void EmcStatusMotion::set_state(::pb::RCS_STATUS value) {
  assert(::pb::RCS_STATUS_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.state)
}

// optional double max_velocity = 48;
inline bool EmcStatusMotion::has_max_velocity() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void EmcStatusMotion::set_has_max_velocity() {
  _has_bits_[1] |= 0x00004000u;
}
inline void EmcStatusMotion::clear_has_max_velocity() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void EmcStatusMotion::clear_max_velocity() {
  max_velocity_ = 0;
  clear_has_max_velocity();
}
inline double EmcStatusMotion::max_velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.max_velocity)
  return max_velocity_;
}
inline void EmcStatusMotion::set_max_velocity(double value) {
  set_has_max_velocity();
  max_velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.max_velocity)
}

// optional double max_acceleration = 49;
inline bool EmcStatusMotion::has_max_acceleration() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void EmcStatusMotion::set_has_max_acceleration() {
  _has_bits_[1] |= 0x00008000u;
}
inline void EmcStatusMotion::clear_has_max_acceleration() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void EmcStatusMotion::clear_max_acceleration() {
  max_acceleration_ = 0;
  clear_has_max_acceleration();
}
inline double EmcStatusMotion::max_acceleration() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusMotion.max_acceleration)
  return max_acceleration_;
}
inline void EmcStatusMotion::set_max_acceleration(double value) {
  set_has_max_acceleration();
  max_acceleration_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusMotion.max_acceleration)
}

// -------------------------------------------------------------------

// EmcStatusIo

// optional bool estop = 1;
inline bool EmcStatusIo::has_estop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusIo::set_has_estop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusIo::clear_has_estop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusIo::clear_estop() {
  estop_ = false;
  clear_has_estop();
}
inline bool EmcStatusIo::estop() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.estop)
  return estop_;
}
inline void EmcStatusIo::set_estop(bool value) {
  set_has_estop();
  estop_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.estop)
}

// optional bool flood = 2;
inline bool EmcStatusIo::has_flood() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusIo::set_has_flood() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusIo::clear_has_flood() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusIo::clear_flood() {
  flood_ = false;
  clear_has_flood();
}
inline bool EmcStatusIo::flood() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.flood)
  return flood_;
}
inline void EmcStatusIo::set_flood(bool value) {
  set_has_flood();
  flood_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.flood)
}

// optional bool lube = 3;
inline bool EmcStatusIo::has_lube() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusIo::set_has_lube() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusIo::clear_has_lube() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusIo::clear_lube() {
  lube_ = false;
  clear_has_lube();
}
inline bool EmcStatusIo::lube() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.lube)
  return lube_;
}
inline void EmcStatusIo::set_lube(bool value) {
  set_has_lube();
  lube_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.lube)
}

// optional bool lube_level = 4;
inline bool EmcStatusIo::has_lube_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcStatusIo::set_has_lube_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcStatusIo::clear_has_lube_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcStatusIo::clear_lube_level() {
  lube_level_ = false;
  clear_has_lube_level();
}
inline bool EmcStatusIo::lube_level() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.lube_level)
  return lube_level_;
}
inline void EmcStatusIo::set_lube_level(bool value) {
  set_has_lube_level();
  lube_level_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.lube_level)
}

// optional bool mist = 5;
inline bool EmcStatusIo::has_mist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcStatusIo::set_has_mist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcStatusIo::clear_has_mist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcStatusIo::clear_mist() {
  mist_ = false;
  clear_has_mist();
}
inline bool EmcStatusIo::mist() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.mist)
  return mist_;
}
inline void EmcStatusIo::set_mist(bool value) {
  set_has_mist();
  mist_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.mist)
}

// optional bool pocket_prepped = 6;
inline bool EmcStatusIo::has_pocket_prepped() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcStatusIo::set_has_pocket_prepped() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcStatusIo::clear_has_pocket_prepped() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcStatusIo::clear_pocket_prepped() {
  pocket_prepped_ = false;
  clear_has_pocket_prepped();
}
inline bool EmcStatusIo::pocket_prepped() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.pocket_prepped)
  return pocket_prepped_;
}
inline void EmcStatusIo::set_pocket_prepped(bool value) {
  set_has_pocket_prepped();
  pocket_prepped_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.pocket_prepped)
}

// optional bool tool_in_spindle = 7;
inline bool EmcStatusIo::has_tool_in_spindle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusIo::set_has_tool_in_spindle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusIo::clear_has_tool_in_spindle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusIo::clear_tool_in_spindle() {
  tool_in_spindle_ = false;
  clear_has_tool_in_spindle();
}
inline bool EmcStatusIo::tool_in_spindle() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.tool_in_spindle)
  return tool_in_spindle_;
}
inline void EmcStatusIo::set_tool_in_spindle(bool value) {
  set_has_tool_in_spindle();
  tool_in_spindle_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusIo.tool_in_spindle)
}

// optional .pb.Position tool_offset = 8;
inline bool EmcStatusIo::has_tool_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusIo::set_has_tool_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusIo::clear_has_tool_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusIo::clear_tool_offset() {
  if (tool_offset_ != NULL) tool_offset_->::pb::Position::Clear();
  clear_has_tool_offset();
}
inline const ::pb::Position& EmcStatusIo::tool_offset() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.tool_offset)
  return tool_offset_ != NULL ? *tool_offset_ : *default_instance_->tool_offset_;
}
inline ::pb::Position* EmcStatusIo::mutable_tool_offset() {
  set_has_tool_offset();
  if (tool_offset_ == NULL) tool_offset_ = new ::pb::Position;
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusIo.tool_offset)
  return tool_offset_;
}
inline ::pb::Position* EmcStatusIo::release_tool_offset() {
  clear_has_tool_offset();
  ::pb::Position* temp = tool_offset_;
  tool_offset_ = NULL;
  return temp;
}
inline void EmcStatusIo::set_allocated_tool_offset(::pb::Position* tool_offset) {
  delete tool_offset_;
  tool_offset_ = tool_offset;
  if (tool_offset) {
    set_has_tool_offset();
  } else {
    clear_has_tool_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusIo.tool_offset)
}

// repeated .pb.EmcToolData tool_table = 9;
inline int EmcStatusIo::tool_table_size() const {
  return tool_table_.size();
}
inline void EmcStatusIo::clear_tool_table() {
  tool_table_.Clear();
}
inline const ::pb::EmcToolData& EmcStatusIo::tool_table(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusIo.tool_table)
  return tool_table_.Get(index);
}
inline ::pb::EmcToolData* EmcStatusIo::mutable_tool_table(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusIo.tool_table)
  return tool_table_.Mutable(index);
}
inline ::pb::EmcToolData* EmcStatusIo::add_tool_table() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusIo.tool_table)
  return tool_table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcToolData >&
EmcStatusIo::tool_table() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusIo.tool_table)
  return tool_table_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcToolData >*
EmcStatusIo::mutable_tool_table() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusIo.tool_table)
  return &tool_table_;
}

// -------------------------------------------------------------------

// EmcStatusTask

// optional int32 echo_serial_number = 1;
inline bool EmcStatusTask::has_echo_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusTask::set_has_echo_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusTask::clear_has_echo_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusTask::clear_echo_serial_number() {
  echo_serial_number_ = 0;
  clear_has_echo_serial_number();
}
inline ::google::protobuf::int32 EmcStatusTask::echo_serial_number() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.echo_serial_number)
  return echo_serial_number_;
}
inline void EmcStatusTask::set_echo_serial_number(::google::protobuf::int32 value) {
  set_has_echo_serial_number();
  echo_serial_number_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.echo_serial_number)
}

// optional .pb.EmcTaskExecStateType exec_state = 2;
inline bool EmcStatusTask::has_exec_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusTask::set_has_exec_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusTask::clear_has_exec_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusTask::clear_exec_state() {
  exec_state_ = 1;
  clear_has_exec_state();
}
inline ::pb::EmcTaskExecStateType EmcStatusTask::exec_state() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.exec_state)
  return static_cast< ::pb::EmcTaskExecStateType >(exec_state_);
}
inline void EmcStatusTask::set_exec_state(::pb::EmcTaskExecStateType value) {
  assert(::pb::EmcTaskExecStateType_IsValid(value));
  set_has_exec_state();
  exec_state_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.exec_state)
}

// optional string file = 3;
inline bool EmcStatusTask::has_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusTask::set_has_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusTask::clear_has_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusTask::clear_file() {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& EmcStatusTask::file() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.file)
  return *file_;
}
inline void EmcStatusTask::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.file)
}
inline void EmcStatusTask::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusTask.file)
}
inline void EmcStatusTask::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusTask.file)
}
inline ::std::string* EmcStatusTask::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusTask.file)
  return file_;
}
inline ::std::string* EmcStatusTask::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusTask::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusTask.file)
}

// optional bool input_timeout = 4;
inline bool EmcStatusTask::has_input_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcStatusTask::set_has_input_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcStatusTask::clear_has_input_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcStatusTask::clear_input_timeout() {
  input_timeout_ = false;
  clear_has_input_timeout();
}
inline bool EmcStatusTask::input_timeout() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.input_timeout)
  return input_timeout_;
}
inline void EmcStatusTask::set_input_timeout(bool value) {
  set_has_input_timeout();
  input_timeout_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.input_timeout)
}

// optional bool optional_stop = 5;
inline bool EmcStatusTask::has_optional_stop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcStatusTask::set_has_optional_stop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcStatusTask::clear_has_optional_stop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcStatusTask::clear_optional_stop() {
  optional_stop_ = false;
  clear_has_optional_stop();
}
inline bool EmcStatusTask::optional_stop() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.optional_stop)
  return optional_stop_;
}
inline void EmcStatusTask::set_optional_stop(bool value) {
  set_has_optional_stop();
  optional_stop_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.optional_stop)
}

// optional int32 read_line = 6;
inline bool EmcStatusTask::has_read_line() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcStatusTask::set_has_read_line() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcStatusTask::clear_has_read_line() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcStatusTask::clear_read_line() {
  read_line_ = 0;
  clear_has_read_line();
}
inline ::google::protobuf::int32 EmcStatusTask::read_line() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.read_line)
  return read_line_;
}
inline void EmcStatusTask::set_read_line(::google::protobuf::int32 value) {
  set_has_read_line();
  read_line_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.read_line)
}

// optional .pb.EmcTaskModeType task_mode = 7;
inline bool EmcStatusTask::has_task_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcStatusTask::set_has_task_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcStatusTask::clear_has_task_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcStatusTask::clear_task_mode() {
  task_mode_ = 1;
  clear_has_task_mode();
}
inline ::pb::EmcTaskModeType EmcStatusTask::task_mode() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.task_mode)
  return static_cast< ::pb::EmcTaskModeType >(task_mode_);
}
inline void EmcStatusTask::set_task_mode(::pb::EmcTaskModeType value) {
  assert(::pb::EmcTaskModeType_IsValid(value));
  set_has_task_mode();
  task_mode_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.task_mode)
}

// optional int32 task_paused = 8;
inline bool EmcStatusTask::has_task_paused() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcStatusTask::set_has_task_paused() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcStatusTask::clear_has_task_paused() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcStatusTask::clear_task_paused() {
  task_paused_ = 0;
  clear_has_task_paused();
}
inline ::google::protobuf::int32 EmcStatusTask::task_paused() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.task_paused)
  return task_paused_;
}
inline void EmcStatusTask::set_task_paused(::google::protobuf::int32 value) {
  set_has_task_paused();
  task_paused_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.task_paused)
}

// optional .pb.EmcTaskStateType task_state = 9;
inline bool EmcStatusTask::has_task_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcStatusTask::set_has_task_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcStatusTask::clear_has_task_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcStatusTask::clear_task_state() {
  task_state_ = 1;
  clear_has_task_state();
}
inline ::pb::EmcTaskStateType EmcStatusTask::task_state() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.task_state)
  return static_cast< ::pb::EmcTaskStateType >(task_state_);
}
inline void EmcStatusTask::set_task_state(::pb::EmcTaskStateType value) {
  assert(::pb::EmcTaskStateType_IsValid(value));
  set_has_task_state();
  task_state_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.task_state)
}

// optional int32 total_lines = 10;
inline bool EmcStatusTask::has_total_lines() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcStatusTask::set_has_total_lines() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcStatusTask::clear_has_total_lines() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcStatusTask::clear_total_lines() {
  total_lines_ = 0;
  clear_has_total_lines();
}
inline ::google::protobuf::int32 EmcStatusTask::total_lines() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusTask.total_lines)
  return total_lines_;
}
inline void EmcStatusTask::set_total_lines(::google::protobuf::int32 value) {
  set_has_total_lines();
  total_lines_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusTask.total_lines)
}

// -------------------------------------------------------------------

// EmcStatusInterp

// optional string command = 1;
inline bool EmcStatusInterp::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusInterp::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusInterp::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusInterp::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& EmcStatusInterp::command() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.command)
  return *command_;
}
inline void EmcStatusInterp::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusInterp.command)
}
inline void EmcStatusInterp::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusInterp.command)
}
inline void EmcStatusInterp::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusInterp.command)
}
inline ::std::string* EmcStatusInterp::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusInterp.command)
  return command_;
}
inline ::std::string* EmcStatusInterp::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusInterp::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusInterp.command)
}

// repeated .pb.EmcStatusGCode gcodes = 2;
inline int EmcStatusInterp::gcodes_size() const {
  return gcodes_.size();
}
inline void EmcStatusInterp::clear_gcodes() {
  gcodes_.Clear();
}
inline const ::pb::EmcStatusGCode& EmcStatusInterp::gcodes(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.gcodes)
  return gcodes_.Get(index);
}
inline ::pb::EmcStatusGCode* EmcStatusInterp::mutable_gcodes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusInterp.gcodes)
  return gcodes_.Mutable(index);
}
inline ::pb::EmcStatusGCode* EmcStatusInterp::add_gcodes() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusInterp.gcodes)
  return gcodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusGCode >&
EmcStatusInterp::gcodes() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusInterp.gcodes)
  return gcodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusGCode >*
EmcStatusInterp::mutable_gcodes() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusInterp.gcodes)
  return &gcodes_;
}

// optional .pb.EmcInterpStateType interp_state = 3;
inline bool EmcStatusInterp::has_interp_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcStatusInterp::set_has_interp_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcStatusInterp::clear_has_interp_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcStatusInterp::clear_interp_state() {
  interp_state_ = 1;
  clear_has_interp_state();
}
inline ::pb::EmcInterpStateType EmcStatusInterp::interp_state() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.interp_state)
  return static_cast< ::pb::EmcInterpStateType >(interp_state_);
}
inline void EmcStatusInterp::set_interp_state(::pb::EmcInterpStateType value) {
  assert(::pb::EmcInterpStateType_IsValid(value));
  set_has_interp_state();
  interp_state_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusInterp.interp_state)
}

// optional .pb.EmcInterpExitCodeType interpreter_errcode = 4;
inline bool EmcStatusInterp::has_interpreter_errcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcStatusInterp::set_has_interpreter_errcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcStatusInterp::clear_has_interpreter_errcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcStatusInterp::clear_interpreter_errcode() {
  interpreter_errcode_ = 0;
  clear_has_interpreter_errcode();
}
inline ::pb::EmcInterpExitCodeType EmcStatusInterp::interpreter_errcode() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.interpreter_errcode)
  return static_cast< ::pb::EmcInterpExitCodeType >(interpreter_errcode_);
}
inline void EmcStatusInterp::set_interpreter_errcode(::pb::EmcInterpExitCodeType value) {
  assert(::pb::EmcInterpExitCodeType_IsValid(value));
  set_has_interpreter_errcode();
  interpreter_errcode_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusInterp.interpreter_errcode)
}

// repeated .pb.EmcStatusMCode mcodes = 5;
inline int EmcStatusInterp::mcodes_size() const {
  return mcodes_.size();
}
inline void EmcStatusInterp::clear_mcodes() {
  mcodes_.Clear();
}
inline const ::pb::EmcStatusMCode& EmcStatusInterp::mcodes(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.mcodes)
  return mcodes_.Get(index);
}
inline ::pb::EmcStatusMCode* EmcStatusInterp::mutable_mcodes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusInterp.mcodes)
  return mcodes_.Mutable(index);
}
inline ::pb::EmcStatusMCode* EmcStatusInterp::add_mcodes() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusInterp.mcodes)
  return mcodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMCode >&
EmcStatusInterp::mcodes() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusInterp.mcodes)
  return mcodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusMCode >*
EmcStatusInterp::mutable_mcodes() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusInterp.mcodes)
  return &mcodes_;
}

// repeated .pb.EmcStatusSetting settings = 6;
inline int EmcStatusInterp::settings_size() const {
  return settings_.size();
}
inline void EmcStatusInterp::clear_settings() {
  settings_.Clear();
}
inline const ::pb::EmcStatusSetting& EmcStatusInterp::settings(int index) const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusInterp.settings)
  return settings_.Get(index);
}
inline ::pb::EmcStatusSetting* EmcStatusInterp::mutable_settings(int index) {
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusInterp.settings)
  return settings_.Mutable(index);
}
inline ::pb::EmcStatusSetting* EmcStatusInterp::add_settings() {
  // @@protoc_insertion_point(field_add:pb.EmcStatusInterp.settings)
  return settings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusSetting >&
EmcStatusInterp::settings() const {
  // @@protoc_insertion_point(field_list:pb.EmcStatusInterp.settings)
  return settings_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::EmcStatusSetting >*
EmcStatusInterp::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_list:pb.EmcStatusInterp.settings)
  return &settings_;
}

// -------------------------------------------------------------------

// EmcCommandParameters

// optional uint32 index = 1;
inline bool EmcCommandParameters::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcCommandParameters::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcCommandParameters::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcCommandParameters::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 EmcCommandParameters::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.index)
  return index_;
}
inline void EmcCommandParameters::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.index)
}

// optional uint32 debug_level = 2;
inline bool EmcCommandParameters::has_debug_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcCommandParameters::set_has_debug_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcCommandParameters::clear_has_debug_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcCommandParameters::clear_debug_level() {
  debug_level_ = 0u;
  clear_has_debug_level();
}
inline ::google::protobuf::uint32 EmcCommandParameters::debug_level() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.debug_level)
  return debug_level_;
}
inline void EmcCommandParameters::set_debug_level(::google::protobuf::uint32 value) {
  set_has_debug_level();
  debug_level_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.debug_level)
}

// optional int32 line_number = 3;
inline bool EmcCommandParameters::has_line_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmcCommandParameters::set_has_line_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmcCommandParameters::clear_has_line_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmcCommandParameters::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 EmcCommandParameters::line_number() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.line_number)
  return line_number_;
}
inline void EmcCommandParameters::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.line_number)
}

// optional double scale = 4;
inline bool EmcCommandParameters::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmcCommandParameters::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmcCommandParameters::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmcCommandParameters::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double EmcCommandParameters::scale() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.scale)
  return scale_;
}
inline void EmcCommandParameters::set_scale(double value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.scale)
}

// optional double velocity = 5;
inline bool EmcCommandParameters::has_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmcCommandParameters::set_has_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmcCommandParameters::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmcCommandParameters::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double EmcCommandParameters::velocity() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.velocity)
  return velocity_;
}
inline void EmcCommandParameters::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.velocity)
}

// optional double distance = 6;
inline bool EmcCommandParameters::has_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmcCommandParameters::set_has_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmcCommandParameters::clear_has_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmcCommandParameters::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double EmcCommandParameters::distance() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.distance)
  return distance_;
}
inline void EmcCommandParameters::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.distance)
}

// optional double value = 7;
inline bool EmcCommandParameters::has_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmcCommandParameters::set_has_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmcCommandParameters::clear_has_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmcCommandParameters::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double EmcCommandParameters::value() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.value)
  return value_;
}
inline void EmcCommandParameters::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.value)
}

// optional bool enable = 8;
inline bool EmcCommandParameters::has_enable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmcCommandParameters::set_has_enable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmcCommandParameters::clear_has_enable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmcCommandParameters::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool EmcCommandParameters::enable() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.enable)
  return enable_;
}
inline void EmcCommandParameters::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.enable)
}

// optional string command = 9;
inline bool EmcCommandParameters::has_command() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmcCommandParameters::set_has_command() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmcCommandParameters::clear_has_command() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmcCommandParameters::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& EmcCommandParameters::command() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.command)
  return *command_;
}
inline void EmcCommandParameters::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.command)
}
inline void EmcCommandParameters::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcCommandParameters.command)
}
inline void EmcCommandParameters::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcCommandParameters.command)
}
inline ::std::string* EmcCommandParameters::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcCommandParameters.command)
  return command_;
}
inline ::std::string* EmcCommandParameters::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcCommandParameters::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcCommandParameters.command)
}

// optional string path = 10;
inline bool EmcCommandParameters::has_path() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmcCommandParameters::set_has_path() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmcCommandParameters::clear_has_path() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmcCommandParameters::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& EmcCommandParameters::path() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.path)
  return *path_;
}
inline void EmcCommandParameters::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.path)
}
inline void EmcCommandParameters::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcCommandParameters.path)
}
inline void EmcCommandParameters::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcCommandParameters.path)
}
inline ::std::string* EmcCommandParameters::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcCommandParameters.path)
  return path_;
}
inline ::std::string* EmcCommandParameters::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcCommandParameters::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcCommandParameters.path)
}

// optional .pb.EmcTaskModeType task_mode = 100;
inline bool EmcCommandParameters::has_task_mode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmcCommandParameters::set_has_task_mode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmcCommandParameters::clear_has_task_mode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmcCommandParameters::clear_task_mode() {
  task_mode_ = 1;
  clear_has_task_mode();
}
inline ::pb::EmcTaskModeType EmcCommandParameters::task_mode() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.task_mode)
  return static_cast< ::pb::EmcTaskModeType >(task_mode_);
}
inline void EmcCommandParameters::set_task_mode(::pb::EmcTaskModeType value) {
  assert(::pb::EmcTaskModeType_IsValid(value));
  set_has_task_mode();
  task_mode_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.task_mode)
}

// optional .pb.EmcTaskStateType task_state = 101;
inline bool EmcCommandParameters::has_task_state() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmcCommandParameters::set_has_task_state() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmcCommandParameters::clear_has_task_state() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmcCommandParameters::clear_task_state() {
  task_state_ = 1;
  clear_has_task_state();
}
inline ::pb::EmcTaskStateType EmcCommandParameters::task_state() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.task_state)
  return static_cast< ::pb::EmcTaskStateType >(task_state_);
}
inline void EmcCommandParameters::set_task_state(::pb::EmcTaskStateType value) {
  assert(::pb::EmcTaskStateType_IsValid(value));
  set_has_task_state();
  task_state_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.task_state)
}

// optional .pb.EmcTrajectoryModeType traj_mode = 102;
inline bool EmcCommandParameters::has_traj_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmcCommandParameters::set_has_traj_mode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmcCommandParameters::clear_has_traj_mode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmcCommandParameters::clear_traj_mode() {
  traj_mode_ = 1;
  clear_has_traj_mode();
}
inline ::pb::EmcTrajectoryModeType EmcCommandParameters::traj_mode() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.traj_mode)
  return static_cast< ::pb::EmcTrajectoryModeType >(traj_mode_);
}
inline void EmcCommandParameters::set_traj_mode(::pb::EmcTrajectoryModeType value) {
  assert(::pb::EmcTrajectoryModeType_IsValid(value));
  set_has_traj_mode();
  traj_mode_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcCommandParameters.traj_mode)
}

// optional .pb.EmcPose pose = 103;
inline bool EmcCommandParameters::has_pose() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmcCommandParameters::set_has_pose() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmcCommandParameters::clear_has_pose() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmcCommandParameters::clear_pose() {
  if (pose_ != NULL) pose_->::pb::EmcPose::Clear();
  clear_has_pose();
}
inline const ::pb::EmcPose& EmcCommandParameters::pose() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.pose)
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::pb::EmcPose* EmcCommandParameters::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::pb::EmcPose;
  // @@protoc_insertion_point(field_mutable:pb.EmcCommandParameters.pose)
  return pose_;
}
inline ::pb::EmcPose* EmcCommandParameters::release_pose() {
  clear_has_pose();
  ::pb::EmcPose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void EmcCommandParameters::set_allocated_pose(::pb::EmcPose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcCommandParameters.pose)
}

// optional .pb.EmcToolData tool_data = 104;
inline bool EmcCommandParameters::has_tool_data() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmcCommandParameters::set_has_tool_data() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmcCommandParameters::clear_has_tool_data() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmcCommandParameters::clear_tool_data() {
  if (tool_data_ != NULL) tool_data_->::pb::EmcToolData::Clear();
  clear_has_tool_data();
}
inline const ::pb::EmcToolData& EmcCommandParameters::tool_data() const {
  // @@protoc_insertion_point(field_get:pb.EmcCommandParameters.tool_data)
  return tool_data_ != NULL ? *tool_data_ : *default_instance_->tool_data_;
}
inline ::pb::EmcToolData* EmcCommandParameters::mutable_tool_data() {
  set_has_tool_data();
  if (tool_data_ == NULL) tool_data_ = new ::pb::EmcToolData;
  // @@protoc_insertion_point(field_mutable:pb.EmcCommandParameters.tool_data)
  return tool_data_;
}
inline ::pb::EmcToolData* EmcCommandParameters::release_tool_data() {
  clear_has_tool_data();
  ::pb::EmcToolData* temp = tool_data_;
  tool_data_ = NULL;
  return temp;
}
inline void EmcCommandParameters::set_allocated_tool_data(::pb::EmcToolData* tool_data) {
  delete tool_data_;
  tool_data_ = tool_data;
  if (tool_data) {
    set_has_tool_data();
  } else {
    clear_has_tool_data();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcCommandParameters.tool_data)
}

// -------------------------------------------------------------------

// EmcStatusUserCommand

// required int32 index = 1;
inline bool EmcStatusUserCommand::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmcStatusUserCommand::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmcStatusUserCommand::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmcStatusUserCommand::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 EmcStatusUserCommand::index() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusUserCommand.index)
  return index_;
}
inline void EmcStatusUserCommand::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:pb.EmcStatusUserCommand.index)
}

// optional string command = 2;
inline bool EmcStatusUserCommand::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmcStatusUserCommand::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmcStatusUserCommand::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmcStatusUserCommand::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& EmcStatusUserCommand::command() const {
  // @@protoc_insertion_point(field_get:pb.EmcStatusUserCommand.command)
  return *command_;
}
inline void EmcStatusUserCommand::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:pb.EmcStatusUserCommand.command)
}
inline void EmcStatusUserCommand::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.EmcStatusUserCommand.command)
}
inline void EmcStatusUserCommand::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.EmcStatusUserCommand.command)
}
inline ::std::string* EmcStatusUserCommand::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.EmcStatusUserCommand.command)
  return command_;
}
inline ::std::string* EmcStatusUserCommand::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EmcStatusUserCommand::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.EmcStatusUserCommand.command)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::EmcTaskExecStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcTaskExecStateType>() {
  return ::pb::EmcTaskExecStateType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcInterpStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcInterpStateType>() {
  return ::pb::EmcInterpStateType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcInterpExitCodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcInterpExitCodeType>() {
  return ::pb::EmcInterpExitCodeType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcKinematicsType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcKinematicsType>() {
  return ::pb::EmcKinematicsType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcTrajectoryModeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcTrajectoryModeType>() {
  return ::pb::EmcTrajectoryModeType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcCanonUnitsType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcCanonUnitsType>() {
  return ::pb::EmcCanonUnitsType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcTimeUnitsType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcTimeUnitsType>() {
  return ::pb::EmcTimeUnitsType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcTaskModeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcTaskModeType>() {
  return ::pb::EmcTaskModeType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcTaskStateType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcTaskStateType>() {
  return ::pb::EmcTaskStateType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcAxisType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcAxisType>() {
  return ::pb::EmcAxisType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcPositionOffsetType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcPositionOffsetType>() {
  return ::pb::EmcPositionOffsetType_descriptor();
}
template <> struct is_proto_enum< ::pb::EmcPositionFeedbackType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::EmcPositionFeedbackType>() {
  return ::pb::EmcPositionFeedbackType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_status_2eproto__INCLUDED
