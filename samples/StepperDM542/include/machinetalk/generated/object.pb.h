// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object.proto

#ifndef PROTOBUF_object_2eproto__INCLUDED
#define PROTOBUF_object_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_object_2eproto();
void protobuf_AssignDesc_object_2eproto();
void protobuf_ShutdownFile_object_2eproto();

class Instance;
class ServiceAnnouncement;
class Originator;
class AnError;
class Pin;
class Signal;
class Param;
class Function;
class Thread;
class Component;
class Ring;
class Member;
class Group;
class ProtocolParameters;
class Vtable;
class Inst;

// ===================================================================

class Instance : public ::google::protobuf::Message {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  void Swap(Instance* other);

  // implements Message ----------------------------------------------

  Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sfixed32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Instance)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Instance* default_instance_;
};
// -------------------------------------------------------------------

class ServiceAnnouncement : public ::google::protobuf::Message {
 public:
  ServiceAnnouncement();
  virtual ~ServiceAnnouncement();

  ServiceAnnouncement(const ServiceAnnouncement& from);

  inline ServiceAnnouncement& operator=(const ServiceAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceAnnouncement& default_instance();

  void Swap(ServiceAnnouncement* other);

  // implements Message ----------------------------------------------

  ServiceAnnouncement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceAnnouncement& from);
  void MergeFrom(const ServiceAnnouncement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.ServiceType stype = 1;
  inline bool has_stype() const;
  inline void clear_stype();
  static const int kStypeFieldNumber = 1;
  inline ::pb::ServiceType stype() const;
  inline void set_stype(::pb::ServiceType value);

  // required fixed32 version = 2 [default = 0];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required fixed32 instance = 3 [default = 0];
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 3;
  inline ::google::protobuf::uint32 instance() const;
  inline void set_instance(::google::protobuf::uint32 value);

  // required .pb.ServiceAPI api = 8;
  inline bool has_api() const;
  inline void clear_api();
  static const int kApiFieldNumber = 8;
  inline ::pb::ServiceAPI api() const;
  inline void set_api(::pb::ServiceAPI value);

  // required string uri = 6;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 6;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // optional string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:pb.ServiceAnnouncement)
 private:
  inline void set_has_stype();
  inline void clear_has_stype();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_api();
  inline void clear_has_api();
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int stype_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 instance_;
  int api_;
  ::std::string* uri_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static ServiceAnnouncement* default_instance_;
};
// -------------------------------------------------------------------

class Originator : public ::google::protobuf::Message {
 public:
  Originator();
  virtual ~Originator();

  Originator(const Originator& from);

  inline Originator& operator=(const Originator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Originator& default_instance();

  void Swap(Originator* other);

  // implements Message ----------------------------------------------

  Originator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Originator& from);
  void MergeFrom(const Originator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.OriginType origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline ::pb::OriginType origin() const;
  inline void set_origin(::pb::OriginType value);

  // optional .pb.OriginDetail detail = 2;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 2;
  inline ::pb::OriginDetail detail() const;
  inline void set_detail(::pb::OriginDetail value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sfixed32 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .pb.Instance instance = 5;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 5;
  inline const ::pb::Instance& instance() const;
  inline ::pb::Instance* mutable_instance();
  inline ::pb::Instance* release_instance();
  inline void set_allocated_instance(::pb::Instance* instance);

  // @@protoc_insertion_point(class_scope:pb.Originator)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_instance();
  inline void clear_has_instance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int origin_;
  int detail_;
  ::std::string* name_;
  ::pb::Instance* instance_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Originator* default_instance_;
};
// -------------------------------------------------------------------

class AnError : public ::google::protobuf::Message {
 public:
  AnError();
  virtual ~AnError();

  AnError(const AnError& from);

  inline AnError& operator=(const AnError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnError& default_instance();

  void Swap(AnError* other);

  // implements Message ----------------------------------------------

  AnError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnError& from);
  void MergeFrom(const AnError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sfixed32 error_code = 1;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  inline ::google::protobuf::int32 error_code() const;
  inline void set_error_code(::google::protobuf::int32 value);

  // optional .pb.Severity severity = 2;
  inline bool has_severity() const;
  inline void clear_severity();
  static const int kSeverityFieldNumber = 2;
  inline ::pb::Severity severity() const;
  inline void set_severity(::pb::Severity value);

  // optional string error_text = 3;
  inline bool has_error_text() const;
  inline void clear_error_text();
  static const int kErrorTextFieldNumber = 3;
  inline const ::std::string& error_text() const;
  inline void set_error_text(const ::std::string& value);
  inline void set_error_text(const char* value);
  inline void set_error_text(const char* value, size_t size);
  inline ::std::string* mutable_error_text();
  inline ::std::string* release_error_text();
  inline void set_allocated_error_text(::std::string* error_text);

  // optional .pb.Originator origin = 4;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 4;
  inline const ::pb::Originator& origin() const;
  inline ::pb::Originator* mutable_origin();
  inline ::pb::Originator* release_origin();
  inline void set_allocated_origin(::pb::Originator* origin);

  // @@protoc_insertion_point(class_scope:pb.AnError)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_error_text();
  inline void clear_has_error_text();
  inline void set_has_origin();
  inline void clear_has_origin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 error_code_;
  int severity_;
  ::std::string* error_text_;
  ::pb::Originator* origin_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static AnError* default_instance_;
};
// -------------------------------------------------------------------

class Pin : public ::google::protobuf::Message {
 public:
  Pin();
  virtual ~Pin();

  Pin(const Pin& from);

  inline Pin& operator=(const Pin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pin& default_instance();

  void Swap(Pin* other);

  // implements Message ----------------------------------------------

  Pin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pin& from);
  void MergeFrom(const Pin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ValueType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::ValueType type() const;
  inline void set_type(::pb::ValueType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 3;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional .pb.HalPinDirection dir = 4;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 4;
  inline ::pb::HalPinDirection dir() const;
  inline void set_dir(::pb::HalPinDirection value);

  // optional bool halbit = 5;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 6;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sfixed32 hals32 = 7;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 7;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional fixed32 halu32 = 8;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional sfixed32 owner = 9;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 9;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional bool linked = 10;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 10;
  inline bool linked() const;
  inline void set_linked(bool value);

  // optional string oldname = 11;
  inline bool has_oldname() const;
  inline void clear_oldname();
  static const int kOldnameFieldNumber = 11;
  inline const ::std::string& oldname() const;
  inline void set_oldname(const ::std::string& value);
  inline void set_oldname(const char* value);
  inline void set_oldname(const char* value, size_t size);
  inline ::std::string* mutable_oldname();
  inline ::std::string* release_oldname();
  inline void set_allocated_oldname(::std::string* oldname);

  // optional double epsilon = 12;
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 12;
  inline double epsilon() const;
  inline void set_epsilon(double value);

  // optional fixed32 flags = 13;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 13;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Pin)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_linked();
  inline void clear_has_linked();
  inline void set_has_oldname();
  inline void clear_has_oldname();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  int dir_;
  ::google::protobuf::int32 hals32_;
  double halfloat_;
  bool halbit_;
  bool linked_;
  ::google::protobuf::uint32 halu32_;
  ::std::string* oldname_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::uint32 flags_;
  double epsilon_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Pin* default_instance_;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  Signal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ValueType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::ValueType type() const;
  inline void set_type(::pb::ValueType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 3;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 5;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 6;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sfixed32 hals32 = 7;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 7;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional fixed32 halu32 = 8;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional string strval = 9;
  inline bool has_strval() const;
  inline void clear_strval();
  static const int kStrvalFieldNumber = 9;
  inline const ::std::string& strval() const;
  inline void set_strval(const ::std::string& value);
  inline void set_strval(const char* value);
  inline void set_strval(const char* value, size_t size);
  inline ::std::string* mutable_strval();
  inline ::std::string* release_strval();
  inline void set_allocated_strval(::std::string* strval);

  // optional bytes blob = 10;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 10;
  inline const ::std::string& blob() const;
  inline void set_blob(const ::std::string& value);
  inline void set_blob(const char* value);
  inline void set_blob(const void* value, size_t size);
  inline ::std::string* mutable_blob();
  inline ::std::string* release_blob();
  inline void set_allocated_blob(::std::string* blob);

  // optional fixed32 readers = 11;
  inline bool has_readers() const;
  inline void clear_readers();
  static const int kReadersFieldNumber = 11;
  inline ::google::protobuf::uint32 readers() const;
  inline void set_readers(::google::protobuf::uint32 value);

  // optional fixed32 writers = 12;
  inline bool has_writers() const;
  inline void clear_writers();
  static const int kWritersFieldNumber = 12;
  inline ::google::protobuf::uint32 writers() const;
  inline void set_writers(::google::protobuf::uint32 value);

  // optional fixed32 bidirs = 13;
  inline bool has_bidirs() const;
  inline void clear_bidirs();
  static const int kBidirsFieldNumber = 13;
  inline ::google::protobuf::uint32 bidirs() const;
  inline void set_bidirs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Signal)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_strval();
  inline void clear_has_strval();
  inline void set_has_blob();
  inline void clear_has_blob();
  inline void set_has_readers();
  inline void clear_has_readers();
  inline void set_has_writers();
  inline void clear_has_writers();
  inline void set_has_bidirs();
  inline void clear_has_bidirs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double halfloat_;
  bool halbit_;
  ::google::protobuf::int32 hals32_;
  ::std::string* strval_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::uint32 readers_;
  ::std::string* blob_;
  ::google::protobuf::uint32 writers_;
  ::google::protobuf::uint32 bidirs_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Signal* default_instance_;
};
// -------------------------------------------------------------------

class Param : public ::google::protobuf::Message {
 public:
  Param();
  virtual ~Param();

  Param(const Param& from);

  inline Param& operator=(const Param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Param& default_instance();

  void Swap(Param* other);

  // implements Message ----------------------------------------------

  Param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Param& from);
  void MergeFrom(const Param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ValueType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pb::ValueType type() const;
  inline void set_type(::pb::ValueType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 3;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 3;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 5;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 6;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sfixed32 hals32 = 7;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 7;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional fixed32 halu32 = 8;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional string strval = 9;
  inline bool has_strval() const;
  inline void clear_strval();
  static const int kStrvalFieldNumber = 9;
  inline const ::std::string& strval() const;
  inline void set_strval(const ::std::string& value);
  inline void set_strval(const char* value);
  inline void set_strval(const char* value, size_t size);
  inline ::std::string* mutable_strval();
  inline ::std::string* release_strval();
  inline void set_allocated_strval(::std::string* strval);

  // optional bytes blob = 10;
  inline bool has_blob() const;
  inline void clear_blob();
  static const int kBlobFieldNumber = 10;
  inline const ::std::string& blob() const;
  inline void set_blob(const ::std::string& value);
  inline void set_blob(const char* value);
  inline void set_blob(const void* value, size_t size);
  inline ::std::string* mutable_blob();
  inline ::std::string* release_blob();
  inline void set_allocated_blob(::std::string* blob);

  // optional .pb.HalParamDirection dir = 11;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 11;
  inline ::pb::HalParamDirection dir() const;
  inline void set_dir(::pb::HalParamDirection value);

  // optional string oldname = 12;
  inline bool has_oldname() const;
  inline void clear_oldname();
  static const int kOldnameFieldNumber = 12;
  inline const ::std::string& oldname() const;
  inline void set_oldname(const ::std::string& value);
  inline void set_oldname(const char* value);
  inline void set_oldname(const char* value, size_t size);
  inline ::std::string* mutable_oldname();
  inline ::std::string* release_oldname();
  inline void set_allocated_oldname(::std::string* oldname);

  // optional sfixed32 owner = 13;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 13;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional sfixed32 runtime = 14;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 14;
  inline ::google::protobuf::int32 runtime() const;
  inline void set_runtime(::google::protobuf::int32 value);

  // optional sfixed32 maytime = 15;
  inline bool has_maytime() const;
  inline void clear_maytime();
  static const int kMaytimeFieldNumber = 15;
  inline ::google::protobuf::int32 maytime() const;
  inline void set_maytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Param)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_strval();
  inline void clear_has_strval();
  inline void set_has_blob();
  inline void clear_has_blob();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_oldname();
  inline void clear_has_oldname();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_runtime();
  inline void clear_has_runtime();
  inline void set_has_maytime();
  inline void clear_has_maytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double halfloat_;
  bool halbit_;
  ::google::protobuf::int32 hals32_;
  ::std::string* strval_;
  ::google::protobuf::uint32 halu32_;
  int dir_;
  ::std::string* blob_;
  ::std::string* oldname_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::int32 runtime_;
  ::google::protobuf::int32 maytime_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Param* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  Function* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional fixed32 owner_id = 3;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 owner_id() const;
  inline void set_owner_id(::google::protobuf::uint32 value);

  // optional fixed32 users = 4;
  inline bool has_users() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 4;
  inline ::google::protobuf::uint32 users() const;
  inline void set_users(::google::protobuf::uint32 value);

  // optional fixed32 runtime = 5;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 5;
  inline ::google::protobuf::uint32 runtime() const;
  inline void set_runtime(::google::protobuf::uint32 value);

  // optional fixed32 maxtime = 6;
  inline bool has_maxtime() const;
  inline void clear_maxtime();
  static const int kMaxtimeFieldNumber = 6;
  inline ::google::protobuf::uint32 maxtime() const;
  inline void set_maxtime(::google::protobuf::uint32 value);

  // optional bool reentrant = 7;
  inline bool has_reentrant() const;
  inline void clear_reentrant();
  static const int kReentrantFieldNumber = 7;
  inline bool reentrant() const;
  inline void set_reentrant(bool value);

  // @@protoc_insertion_point(class_scope:pb.Function)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_users();
  inline void clear_has_users();
  inline void set_has_runtime();
  inline void clear_has_runtime();
  inline void set_has_maxtime();
  inline void clear_has_maxtime();
  inline void set_has_reentrant();
  inline void clear_has_reentrant();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::uint32 owner_id_;
  ::google::protobuf::uint32 users_;
  ::google::protobuf::uint32 runtime_;
  ::google::protobuf::uint32 maxtime_;
  bool reentrant_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class Thread : public ::google::protobuf::Message {
 public:
  Thread();
  virtual ~Thread();

  Thread(const Thread& from);

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thread& default_instance();

  void Swap(Thread* other);

  // implements Message ----------------------------------------------

  Thread* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Thread& from);
  void MergeFrom(const Thread& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool uses_fp = 3;
  inline bool has_uses_fp() const;
  inline void clear_uses_fp();
  static const int kUsesFpFieldNumber = 3;
  inline bool uses_fp() const;
  inline void set_uses_fp(bool value);

  // optional fixed32 period = 4;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 4;
  inline ::google::protobuf::uint32 period() const;
  inline void set_period(::google::protobuf::uint32 value);

  // optional sfixed32 priority = 5;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 5;
  inline ::google::protobuf::int32 priority() const;
  inline void set_priority(::google::protobuf::int32 value);

  // optional fixed32 task_id = 6;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 6;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional fixed32 cpu_id = 7;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 7;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // repeated string function = 8;
  inline int function_size() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 8;
  inline const ::std::string& function(int index) const;
  inline ::std::string* mutable_function(int index);
  inline void set_function(int index, const ::std::string& value);
  inline void set_function(int index, const char* value);
  inline void set_function(int index, const char* value, size_t size);
  inline ::std::string* add_function();
  inline void add_function(const ::std::string& value);
  inline void add_function(const char* value);
  inline void add_function(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& function() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_function();

  // @@protoc_insertion_point(class_scope:pb.Thread)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_uses_fp();
  inline void clear_has_uses_fp();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  bool uses_fp_;
  ::google::protobuf::uint32 period_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 cpu_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> function_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Thread* default_instance_;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  Component* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 ninst = 2;
  inline bool has_ninst() const;
  inline void clear_ninst();
  static const int kNinstFieldNumber = 2;
  inline ::google::protobuf::uint32 ninst() const;
  inline void set_ninst(::google::protobuf::uint32 value);

  // optional sfixed32 comp_id = 4;
  inline bool has_comp_id() const;
  inline void clear_comp_id();
  static const int kCompIdFieldNumber = 4;
  inline ::google::protobuf::int32 comp_id() const;
  inline void set_comp_id(::google::protobuf::int32 value);

  // optional fixed32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional fixed32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional fixed32 last_update = 7;
  inline bool has_last_update() const;
  inline void clear_last_update();
  static const int kLastUpdateFieldNumber = 7;
  inline ::google::protobuf::uint32 last_update() const;
  inline void set_last_update(::google::protobuf::uint32 value);

  // optional fixed32 last_bound = 8;
  inline bool has_last_bound() const;
  inline void clear_last_bound();
  static const int kLastBoundFieldNumber = 8;
  inline ::google::protobuf::uint32 last_bound() const;
  inline void set_last_bound(::google::protobuf::uint32 value);

  // optional fixed32 last_unbound = 9;
  inline bool has_last_unbound() const;
  inline void clear_last_unbound();
  static const int kLastUnboundFieldNumber = 9;
  inline ::google::protobuf::uint32 last_unbound() const;
  inline void set_last_unbound(::google::protobuf::uint32 value);

  // optional fixed32 pid = 10;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 10;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);

  // optional string args = 11;
  inline bool has_args() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 11;
  inline const ::std::string& args() const;
  inline void set_args(const ::std::string& value);
  inline void set_args(const char* value);
  inline void set_args(const char* value, size_t size);
  inline ::std::string* mutable_args();
  inline ::std::string* release_args();
  inline void set_allocated_args(::std::string* args);

  // optional sfixed32 timer = 12;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 12;
  inline ::google::protobuf::int32 timer() const;
  inline void set_timer(::google::protobuf::int32 value);

  // optional sfixed32 userarg1 = 14;
  inline bool has_userarg1() const;
  inline void clear_userarg1();
  static const int kUserarg1FieldNumber = 14;
  inline ::google::protobuf::int32 userarg1() const;
  inline void set_userarg1(::google::protobuf::int32 value);

  // optional sfixed32 userarg2 = 15;
  inline bool has_userarg2() const;
  inline void clear_userarg2();
  static const int kUserarg2FieldNumber = 15;
  inline ::google::protobuf::int32 userarg2() const;
  inline void set_userarg2(::google::protobuf::int32 value);

  // repeated .pb.Pin pin = 16;
  inline int pin_size() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 16;
  inline const ::pb::Pin& pin(int index) const;
  inline ::pb::Pin* mutable_pin(int index);
  inline ::pb::Pin* add_pin();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
      pin() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
      mutable_pin();

  // repeated .pb.Param param = 17;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 17;
  inline const ::pb::Param& param(int index) const;
  inline ::pb::Param* mutable_param(int index);
  inline ::pb::Param* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
      mutable_param();

  // optional bool no_create = 18;
  inline bool has_no_create() const;
  inline void clear_no_create();
  static const int kNoCreateFieldNumber = 18;
  inline bool no_create() const;
  inline void set_no_create(bool value);

  // @@protoc_insertion_point(class_scope:pb.Component)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ninst();
  inline void clear_has_ninst();
  inline void set_has_comp_id();
  inline void clear_has_comp_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_last_update();
  inline void clear_has_last_update();
  inline void set_has_last_bound();
  inline void clear_has_last_bound();
  inline void set_has_last_unbound();
  inline void clear_has_last_unbound();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_args();
  inline void clear_has_args();
  inline void set_has_timer();
  inline void clear_has_timer();
  inline void set_has_userarg1();
  inline void clear_has_userarg1();
  inline void set_has_userarg2();
  inline void clear_has_userarg2();
  inline void set_has_no_create();
  inline void clear_has_no_create();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 ninst_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 last_update_;
  ::google::protobuf::uint32 last_bound_;
  ::google::protobuf::uint32 last_unbound_;
  ::google::protobuf::uint32 pid_;
  ::std::string* args_;
  ::google::protobuf::int32 timer_;
  ::google::protobuf::int32 userarg1_;
  ::google::protobuf::RepeatedPtrField< ::pb::Pin > pin_;
  ::google::protobuf::int32 userarg2_;
  bool no_create_;
  ::google::protobuf::RepeatedPtrField< ::pb::Param > param_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Component* default_instance_;
};
// -------------------------------------------------------------------

class Ring : public ::google::protobuf::Message {
 public:
  Ring();
  virtual ~Ring();

  Ring(const Ring& from);

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ring& default_instance();

  void Swap(Ring* other);

  // implements Message ----------------------------------------------

  Ring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 owner = 3;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 3;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional bool stream = 4;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 4;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bool wmutex = 5;
  inline bool has_wmutex() const;
  inline void clear_wmutex();
  static const int kWmutexFieldNumber = 5;
  inline bool wmutex() const;
  inline void set_wmutex(bool value);

  // optional bool rmutex = 6;
  inline bool has_rmutex() const;
  inline void clear_rmutex();
  static const int kRmutexFieldNumber = 6;
  inline bool rmutex() const;
  inline void set_rmutex(bool value);

  // optional bool rtapi_shm = 7;
  inline bool has_rtapi_shm() const;
  inline void clear_rtapi_shm();
  static const int kRtapiShmFieldNumber = 7;
  inline bool rtapi_shm() const;
  inline void set_rtapi_shm(bool value);

  // optional sfixed32 reader = 8;
  inline bool has_reader() const;
  inline void clear_reader();
  static const int kReaderFieldNumber = 8;
  inline ::google::protobuf::int32 reader() const;
  inline void set_reader(::google::protobuf::int32 value);

  // optional sfixed32 writer = 9;
  inline bool has_writer() const;
  inline void clear_writer();
  static const int kWriterFieldNumber = 9;
  inline ::google::protobuf::int32 writer() const;
  inline void set_writer(::google::protobuf::int32 value);

  // optional sfixed32 size = 10;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 10;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional sfixed32 scratchpad = 11;
  inline bool has_scratchpad() const;
  inline void clear_scratchpad();
  static const int kScratchpadFieldNumber = 11;
  inline ::google::protobuf::int32 scratchpad() const;
  inline void set_scratchpad(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Ring)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_wmutex();
  inline void clear_has_wmutex();
  inline void set_has_rmutex();
  inline void clear_has_rmutex();
  inline void set_has_rtapi_shm();
  inline void clear_has_rtapi_shm();
  inline void set_has_reader();
  inline void clear_has_reader();
  inline void set_has_writer();
  inline void clear_has_writer();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_scratchpad();
  inline void clear_has_scratchpad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 owner_;
  bool stream_;
  bool wmutex_;
  bool rmutex_;
  bool rtapi_shm_;
  ::google::protobuf::int32 reader_;
  ::google::protobuf::int32 writer_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 scratchpad_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Ring* default_instance_;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  void Swap(Member* other);

  // implements Message ----------------------------------------------

  Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ObjectType mtype = 1;
  inline bool has_mtype() const;
  inline void clear_mtype();
  static const int kMtypeFieldNumber = 1;
  inline ::pb::ObjectType mtype() const;
  inline void set_mtype(::pb::ObjectType value);

  // optional sfixed32 userarg1 = 2;
  inline bool has_userarg1() const;
  inline void clear_userarg1();
  static const int kUserarg1FieldNumber = 2;
  inline ::google::protobuf::int32 userarg1() const;
  inline void set_userarg1(::google::protobuf::int32 value);

  // optional double epsilon = 3;
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 3;
  inline double epsilon() const;
  inline void set_epsilon(double value);

  // optional .pb.Signal signal = 4;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 4;
  inline const ::pb::Signal& signal() const;
  inline ::pb::Signal* mutable_signal();
  inline ::pb::Signal* release_signal();
  inline void set_allocated_signal(::pb::Signal* signal);

  // optional string groupname = 5;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupnameFieldNumber = 5;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // optional fixed32 handle = 6;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 6;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional .pb.Pin pin = 7;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 7;
  inline const ::pb::Pin& pin() const;
  inline ::pb::Pin* mutable_pin();
  inline ::pb::Pin* release_pin();
  inline void set_allocated_pin(::pb::Pin* pin);

  // optional .pb.Param param = 8;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 8;
  inline const ::pb::Param& param() const;
  inline ::pb::Param* mutable_param();
  inline ::pb::Param* release_param();
  inline void set_allocated_param(::pb::Param* param);

  // @@protoc_insertion_point(class_scope:pb.Member)
 private:
  inline void set_has_mtype();
  inline void clear_has_mtype();
  inline void set_has_userarg1();
  inline void clear_has_userarg1();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_groupname();
  inline void clear_has_groupname();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mtype_;
  ::google::protobuf::int32 userarg1_;
  double epsilon_;
  ::pb::Signal* signal_;
  ::std::string* groupname_;
  ::pb::Pin* pin_;
  ::pb::Param* param_;
  ::google::protobuf::uint32 handle_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Member* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 2;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 userarg1 = 4;
  inline bool has_userarg1() const;
  inline void clear_userarg1();
  static const int kUserarg1FieldNumber = 4;
  inline ::google::protobuf::int32 userarg1() const;
  inline void set_userarg1(::google::protobuf::int32 value);

  // optional sfixed32 userarg2 = 5;
  inline bool has_userarg2() const;
  inline void clear_userarg2();
  static const int kUserarg2FieldNumber = 5;
  inline ::google::protobuf::int32 userarg2() const;
  inline void set_userarg2(::google::protobuf::int32 value);

  // optional sfixed32 refcount = 6;
  inline bool has_refcount() const;
  inline void clear_refcount();
  static const int kRefcountFieldNumber = 6;
  inline ::google::protobuf::int32 refcount() const;
  inline void set_refcount(::google::protobuf::int32 value);

  // repeated .pb.Member member = 7;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 7;
  inline const ::pb::Member& member(int index) const;
  inline ::pb::Member* mutable_member(int index);
  inline ::pb::Member* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
      mutable_member();

  // @@protoc_insertion_point(class_scope:pb.Group)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_userarg1();
  inline void clear_has_userarg1();
  inline void set_has_userarg2();
  inline void clear_has_userarg2();
  inline void set_has_refcount();
  inline void clear_has_refcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 userarg1_;
  ::google::protobuf::int32 userarg2_;
  ::google::protobuf::int32 refcount_;
  ::google::protobuf::RepeatedPtrField< ::pb::Member > member_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class ProtocolParameters : public ::google::protobuf::Message {
 public:
  ProtocolParameters();
  virtual ~ProtocolParameters();

  ProtocolParameters(const ProtocolParameters& from);

  inline ProtocolParameters& operator=(const ProtocolParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolParameters& default_instance();

  void Swap(ProtocolParameters* other);

  // implements Message ----------------------------------------------

  ProtocolParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolParameters& from);
  void MergeFrom(const ProtocolParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 keepalive_timer = 1;
  inline bool has_keepalive_timer() const;
  inline void clear_keepalive_timer();
  static const int kKeepaliveTimerFieldNumber = 1;
  inline ::google::protobuf::int32 keepalive_timer() const;
  inline void set_keepalive_timer(::google::protobuf::int32 value);

  // optional sfixed32 group_timer = 2;
  inline bool has_group_timer() const;
  inline void clear_group_timer();
  static const int kGroupTimerFieldNumber = 2;
  inline ::google::protobuf::int32 group_timer() const;
  inline void set_group_timer(::google::protobuf::int32 value);

  // optional sfixed32 rcomp_timer = 3;
  inline bool has_rcomp_timer() const;
  inline void clear_rcomp_timer();
  static const int kRcompTimerFieldNumber = 3;
  inline ::google::protobuf::int32 rcomp_timer() const;
  inline void set_rcomp_timer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ProtocolParameters)
 private:
  inline void set_has_keepalive_timer();
  inline void clear_has_keepalive_timer();
  inline void set_has_group_timer();
  inline void clear_has_group_timer();
  inline void set_has_rcomp_timer();
  inline void clear_has_rcomp_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 keepalive_timer_;
  ::google::protobuf::int32 group_timer_;
  ::google::protobuf::int32 rcomp_timer_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static ProtocolParameters* default_instance_;
};
// -------------------------------------------------------------------

class Vtable : public ::google::protobuf::Message {
 public:
  Vtable();
  virtual ~Vtable();

  Vtable(const Vtable& from);

  inline Vtable& operator=(const Vtable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vtable& default_instance();

  void Swap(Vtable* other);

  // implements Message ----------------------------------------------

  Vtable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vtable& from);
  void MergeFrom(const Vtable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional fixed32 context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline ::google::protobuf::uint32 context() const;
  inline void set_context(::google::protobuf::uint32 value);

  // optional sfixed32 comp_id = 4;
  inline bool has_comp_id() const;
  inline void clear_comp_id();
  static const int kCompIdFieldNumber = 4;
  inline ::google::protobuf::int32 comp_id() const;
  inline void set_comp_id(::google::protobuf::int32 value);

  // optional sfixed32 instance_id = 5;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 5;
  inline ::google::protobuf::int32 instance_id() const;
  inline void set_instance_id(::google::protobuf::int32 value);

  // optional fixed32 handle = 6;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 6;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 refcount = 7;
  inline bool has_refcount() const;
  inline void clear_refcount();
  static const int kRefcountFieldNumber = 7;
  inline ::google::protobuf::int32 refcount() const;
  inline void set_refcount(::google::protobuf::int32 value);

  // optional sfixed32 version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional fixed64 vtable = 9;
  inline bool has_vtable() const;
  inline void clear_vtable();
  static const int kVtableFieldNumber = 9;
  inline ::google::protobuf::uint64 vtable() const;
  inline void set_vtable(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.Vtable)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_comp_id();
  inline void clear_has_comp_id();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_refcount();
  inline void clear_has_refcount();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_vtable();
  inline void clear_has_vtable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 context_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::int32 instance_id_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 refcount_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::uint64 vtable_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Vtable* default_instance_;
};
// -------------------------------------------------------------------

class Inst : public ::google::protobuf::Message {
 public:
  Inst();
  virtual ~Inst();

  Inst(const Inst& from);

  inline Inst& operator=(const Inst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inst& default_instance();

  void Swap(Inst* other);

  // implements Message ----------------------------------------------

  Inst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inst& from);
  void MergeFrom(const Inst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sfixed32 comp_id = 2;
  inline bool has_comp_id() const;
  inline void clear_comp_id();
  static const int kCompIdFieldNumber = 2;
  inline ::google::protobuf::int32 comp_id() const;
  inline void set_comp_id(::google::protobuf::int32 value);

  // optional fixed32 inst_id = 3;
  inline bool has_inst_id() const;
  inline void clear_inst_id();
  static const int kInstIdFieldNumber = 3;
  inline ::google::protobuf::uint32 inst_id() const;
  inline void set_inst_id(::google::protobuf::uint32 value);

  // optional fixed32 inst_size = 4;
  inline bool has_inst_size() const;
  inline void clear_inst_size();
  static const int kInstSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 inst_size() const;
  inline void set_inst_size(::google::protobuf::uint32 value);

  // optional fixed64 vtable = 5;
  inline bool has_vtable() const;
  inline void clear_vtable();
  static const int kVtableFieldNumber = 5;
  inline ::google::protobuf::uint64 vtable() const;
  inline void set_vtable(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.Inst)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_comp_id();
  inline void clear_has_comp_id();
  inline void set_has_inst_id();
  inline void clear_has_inst_id();
  inline void set_has_inst_size();
  inline void clear_has_inst_size();
  inline void set_has_vtable();
  inline void clear_has_vtable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::uint32 inst_id_;
  ::google::protobuf::uint64 vtable_;
  ::google::protobuf::uint32 inst_size_;
  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Inst* default_instance_;
};
// ===================================================================


// ===================================================================

// Instance

// optional string name = 1;
inline bool Instance::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instance::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instance::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instance::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:pb.Instance.name)
  return *name_;
}
inline void Instance::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Instance.name)
}
inline void Instance::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Instance.name)
}
inline void Instance::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Instance.name)
}
inline ::std::string* Instance::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Instance.name)
  return name_;
}
inline ::std::string* Instance::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instance::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Instance.name)
}

// optional sfixed32 id = 2;
inline bool Instance::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instance::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instance::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instance::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Instance::id() const {
  // @@protoc_insertion_point(field_get:pb.Instance.id)
  return id_;
}
inline void Instance::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Instance.id)
}

// -------------------------------------------------------------------

// ServiceAnnouncement

// required .pb.ServiceType stype = 1;
inline bool ServiceAnnouncement::has_stype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceAnnouncement::set_has_stype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceAnnouncement::clear_has_stype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceAnnouncement::clear_stype() {
  stype_ = 1;
  clear_has_stype();
}
inline ::pb::ServiceType ServiceAnnouncement::stype() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.stype)
  return static_cast< ::pb::ServiceType >(stype_);
}
inline void ServiceAnnouncement::set_stype(::pb::ServiceType value) {
  assert(::pb::ServiceType_IsValid(value));
  set_has_stype();
  stype_ = value;
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.stype)
}

// required fixed32 version = 2 [default = 0];
inline bool ServiceAnnouncement::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceAnnouncement::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceAnnouncement::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceAnnouncement::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ServiceAnnouncement::version() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.version)
  return version_;
}
inline void ServiceAnnouncement::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.version)
}

// required fixed32 instance = 3 [default = 0];
inline bool ServiceAnnouncement::has_instance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceAnnouncement::set_has_instance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceAnnouncement::clear_has_instance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceAnnouncement::clear_instance() {
  instance_ = 0u;
  clear_has_instance();
}
inline ::google::protobuf::uint32 ServiceAnnouncement::instance() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.instance)
  return instance_;
}
inline void ServiceAnnouncement::set_instance(::google::protobuf::uint32 value) {
  set_has_instance();
  instance_ = value;
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.instance)
}

// required .pb.ServiceAPI api = 8;
inline bool ServiceAnnouncement::has_api() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceAnnouncement::set_has_api() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceAnnouncement::clear_has_api() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceAnnouncement::clear_api() {
  api_ = 1;
  clear_has_api();
}
inline ::pb::ServiceAPI ServiceAnnouncement::api() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.api)
  return static_cast< ::pb::ServiceAPI >(api_);
}
inline void ServiceAnnouncement::set_api(::pb::ServiceAPI value) {
  assert(::pb::ServiceAPI_IsValid(value));
  set_has_api();
  api_ = value;
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.api)
}

// required string uri = 6;
inline bool ServiceAnnouncement::has_uri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceAnnouncement::set_has_uri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceAnnouncement::clear_has_uri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceAnnouncement::clear_uri() {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& ServiceAnnouncement::uri() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.uri)
  return *uri_;
}
inline void ServiceAnnouncement::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.uri)
}
inline void ServiceAnnouncement::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ServiceAnnouncement.uri)
}
inline void ServiceAnnouncement::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ServiceAnnouncement.uri)
}
inline ::std::string* ServiceAnnouncement::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ServiceAnnouncement.uri)
  return uri_;
}
inline ::std::string* ServiceAnnouncement::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceAnnouncement::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ServiceAnnouncement.uri)
}

// optional string description = 7;
inline bool ServiceAnnouncement::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceAnnouncement::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceAnnouncement::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceAnnouncement::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ServiceAnnouncement::description() const {
  // @@protoc_insertion_point(field_get:pb.ServiceAnnouncement.description)
  return *description_;
}
inline void ServiceAnnouncement::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:pb.ServiceAnnouncement.description)
}
inline void ServiceAnnouncement::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.ServiceAnnouncement.description)
}
inline void ServiceAnnouncement::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.ServiceAnnouncement.description)
}
inline ::std::string* ServiceAnnouncement::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.ServiceAnnouncement.description)
  return description_;
}
inline ::std::string* ServiceAnnouncement::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServiceAnnouncement::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.ServiceAnnouncement.description)
}

// -------------------------------------------------------------------

// Originator

// optional .pb.OriginType origin = 1;
inline bool Originator::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Originator::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Originator::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Originator::clear_origin() {
  origin_ = 10;
  clear_has_origin();
}
inline ::pb::OriginType Originator::origin() const {
  // @@protoc_insertion_point(field_get:pb.Originator.origin)
  return static_cast< ::pb::OriginType >(origin_);
}
inline void Originator::set_origin(::pb::OriginType value) {
  assert(::pb::OriginType_IsValid(value));
  set_has_origin();
  origin_ = value;
  // @@protoc_insertion_point(field_set:pb.Originator.origin)
}

// optional .pb.OriginDetail detail = 2;
inline bool Originator::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Originator::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Originator::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Originator::clear_detail() {
  detail_ = 10;
  clear_has_detail();
}
inline ::pb::OriginDetail Originator::detail() const {
  // @@protoc_insertion_point(field_get:pb.Originator.detail)
  return static_cast< ::pb::OriginDetail >(detail_);
}
inline void Originator::set_detail(::pb::OriginDetail value) {
  assert(::pb::OriginDetail_IsValid(value));
  set_has_detail();
  detail_ = value;
  // @@protoc_insertion_point(field_set:pb.Originator.detail)
}

// optional string name = 3;
inline bool Originator::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Originator::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Originator::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Originator::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Originator::name() const {
  // @@protoc_insertion_point(field_get:pb.Originator.name)
  return *name_;
}
inline void Originator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Originator.name)
}
inline void Originator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Originator.name)
}
inline void Originator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Originator.name)
}
inline ::std::string* Originator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Originator.name)
  return name_;
}
inline ::std::string* Originator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Originator::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Originator.name)
}

// optional sfixed32 id = 4;
inline bool Originator::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Originator::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Originator::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Originator::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Originator::id() const {
  // @@protoc_insertion_point(field_get:pb.Originator.id)
  return id_;
}
inline void Originator::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Originator.id)
}

// optional .pb.Instance instance = 5;
inline bool Originator::has_instance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Originator::set_has_instance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Originator::clear_has_instance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Originator::clear_instance() {
  if (instance_ != NULL) instance_->::pb::Instance::Clear();
  clear_has_instance();
}
inline const ::pb::Instance& Originator::instance() const {
  // @@protoc_insertion_point(field_get:pb.Originator.instance)
  return instance_ != NULL ? *instance_ : *default_instance_->instance_;
}
inline ::pb::Instance* Originator::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) instance_ = new ::pb::Instance;
  // @@protoc_insertion_point(field_mutable:pb.Originator.instance)
  return instance_;
}
inline ::pb::Instance* Originator::release_instance() {
  clear_has_instance();
  ::pb::Instance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline void Originator::set_allocated_instance(::pb::Instance* instance) {
  delete instance_;
  instance_ = instance;
  if (instance) {
    set_has_instance();
  } else {
    clear_has_instance();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Originator.instance)
}

// -------------------------------------------------------------------

// AnError

// required sfixed32 error_code = 1;
inline bool AnError::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnError::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnError::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnError::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 AnError::error_code() const {
  // @@protoc_insertion_point(field_get:pb.AnError.error_code)
  return error_code_;
}
inline void AnError::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:pb.AnError.error_code)
}

// optional .pb.Severity severity = 2;
inline bool AnError::has_severity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnError::set_has_severity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnError::clear_has_severity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnError::clear_severity() {
  severity_ = 1;
  clear_has_severity();
}
inline ::pb::Severity AnError::severity() const {
  // @@protoc_insertion_point(field_get:pb.AnError.severity)
  return static_cast< ::pb::Severity >(severity_);
}
inline void AnError::set_severity(::pb::Severity value) {
  assert(::pb::Severity_IsValid(value));
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:pb.AnError.severity)
}

// optional string error_text = 3;
inline bool AnError::has_error_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnError::set_has_error_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnError::clear_has_error_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnError::clear_error_text() {
  if (error_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_text_->clear();
  }
  clear_has_error_text();
}
inline const ::std::string& AnError::error_text() const {
  // @@protoc_insertion_point(field_get:pb.AnError.error_text)
  return *error_text_;
}
inline void AnError::set_error_text(const ::std::string& value) {
  set_has_error_text();
  if (error_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_text_ = new ::std::string;
  }
  error_text_->assign(value);
  // @@protoc_insertion_point(field_set:pb.AnError.error_text)
}
inline void AnError::set_error_text(const char* value) {
  set_has_error_text();
  if (error_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_text_ = new ::std::string;
  }
  error_text_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.AnError.error_text)
}
inline void AnError::set_error_text(const char* value, size_t size) {
  set_has_error_text();
  if (error_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_text_ = new ::std::string;
  }
  error_text_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.AnError.error_text)
}
inline ::std::string* AnError::mutable_error_text() {
  set_has_error_text();
  if (error_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_text_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.AnError.error_text)
  return error_text_;
}
inline ::std::string* AnError::release_error_text() {
  clear_has_error_text();
  if (error_text_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_text_;
    error_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AnError::set_allocated_error_text(::std::string* error_text) {
  if (error_text_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_text_;
  }
  if (error_text) {
    set_has_error_text();
    error_text_ = error_text;
  } else {
    clear_has_error_text();
    error_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnError.error_text)
}

// optional .pb.Originator origin = 4;
inline bool AnError::has_origin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnError::set_has_origin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnError::clear_has_origin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnError::clear_origin() {
  if (origin_ != NULL) origin_->::pb::Originator::Clear();
  clear_has_origin();
}
inline const ::pb::Originator& AnError::origin() const {
  // @@protoc_insertion_point(field_get:pb.AnError.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::pb::Originator* AnError::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::pb::Originator;
  // @@protoc_insertion_point(field_mutable:pb.AnError.origin)
  return origin_;
}
inline ::pb::Originator* AnError::release_origin() {
  clear_has_origin();
  ::pb::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void AnError::set_allocated_origin(::pb::Originator* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.AnError.origin)
}

// -------------------------------------------------------------------

// Pin

// optional .pb.ValueType type = 1;
inline bool Pin::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pin::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pin::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pin::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::ValueType Pin::type() const {
  // @@protoc_insertion_point(field_get:pb.Pin.type)
  return static_cast< ::pb::ValueType >(type_);
}
inline void Pin::set_type(::pb::ValueType value) {
  assert(::pb::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.type)
}

// optional string name = 2;
inline bool Pin::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pin::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pin::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pin::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Pin::name() const {
  // @@protoc_insertion_point(field_get:pb.Pin.name)
  return *name_;
}
inline void Pin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Pin.name)
}
inline void Pin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Pin.name)
}
inline void Pin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Pin.name)
}
inline ::std::string* Pin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Pin.name)
  return name_;
}
inline ::std::string* Pin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pin::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Pin.name)
}

// optional fixed32 handle = 3;
inline bool Pin::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pin::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pin::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pin::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Pin::handle() const {
  // @@protoc_insertion_point(field_get:pb.Pin.handle)
  return handle_;
}
inline void Pin::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.handle)
}

// optional .pb.HalPinDirection dir = 4;
inline bool Pin::has_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pin::set_has_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pin::clear_has_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pin::clear_dir() {
  dir_ = 16;
  clear_has_dir();
}
inline ::pb::HalPinDirection Pin::dir() const {
  // @@protoc_insertion_point(field_get:pb.Pin.dir)
  return static_cast< ::pb::HalPinDirection >(dir_);
}
inline void Pin::set_dir(::pb::HalPinDirection value) {
  assert(::pb::HalPinDirection_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.dir)
}

// optional bool halbit = 5;
inline bool Pin::has_halbit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pin::set_has_halbit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pin::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pin::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Pin::halbit() const {
  // @@protoc_insertion_point(field_get:pb.Pin.halbit)
  return halbit_;
}
inline void Pin::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.halbit)
}

// optional double halfloat = 6;
inline bool Pin::has_halfloat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pin::set_has_halfloat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pin::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pin::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Pin::halfloat() const {
  // @@protoc_insertion_point(field_get:pb.Pin.halfloat)
  return halfloat_;
}
inline void Pin::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Pin::has_hals32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pin::set_has_hals32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pin::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pin::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Pin::hals32() const {
  // @@protoc_insertion_point(field_get:pb.Pin.hals32)
  return hals32_;
}
inline void Pin::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Pin::has_halu32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pin::set_has_halu32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pin::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pin::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Pin::halu32() const {
  // @@protoc_insertion_point(field_get:pb.Pin.halu32)
  return halu32_;
}
inline void Pin::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.halu32)
}

// optional sfixed32 owner = 9;
inline bool Pin::has_owner() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pin::set_has_owner() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pin::clear_has_owner() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pin::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Pin::owner() const {
  // @@protoc_insertion_point(field_get:pb.Pin.owner)
  return owner_;
}
inline void Pin::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.owner)
}

// optional bool linked = 10;
inline bool Pin::has_linked() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Pin::set_has_linked() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Pin::clear_has_linked() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Pin::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool Pin::linked() const {
  // @@protoc_insertion_point(field_get:pb.Pin.linked)
  return linked_;
}
inline void Pin::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.linked)
}

// optional string oldname = 11;
inline bool Pin::has_oldname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Pin::set_has_oldname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Pin::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Pin::clear_oldname() {
  if (oldname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_->clear();
  }
  clear_has_oldname();
}
inline const ::std::string& Pin::oldname() const {
  // @@protoc_insertion_point(field_get:pb.Pin.oldname)
  return *oldname_;
}
inline void Pin::set_oldname(const ::std::string& value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Pin.oldname)
}
inline void Pin::set_oldname(const char* value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Pin.oldname)
}
inline void Pin::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Pin.oldname)
}
inline ::std::string* Pin::mutable_oldname() {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Pin.oldname)
  return oldname_;
}
inline ::std::string* Pin::release_oldname() {
  clear_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = oldname_;
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pin::set_allocated_oldname(::std::string* oldname) {
  if (oldname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete oldname_;
  }
  if (oldname) {
    set_has_oldname();
    oldname_ = oldname;
  } else {
    clear_has_oldname();
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Pin.oldname)
}

// optional double epsilon = 12;
inline bool Pin::has_epsilon() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Pin::set_has_epsilon() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Pin::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Pin::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Pin::epsilon() const {
  // @@protoc_insertion_point(field_get:pb.Pin.epsilon)
  return epsilon_;
}
inline void Pin::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.epsilon)
}

// optional fixed32 flags = 13;
inline bool Pin::has_flags() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Pin::set_has_flags() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Pin::clear_has_flags() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Pin::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Pin::flags() const {
  // @@protoc_insertion_point(field_get:pb.Pin.flags)
  return flags_;
}
inline void Pin::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:pb.Pin.flags)
}

// -------------------------------------------------------------------

// Signal

// optional .pb.ValueType type = 1;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::ValueType Signal::type() const {
  // @@protoc_insertion_point(field_get:pb.Signal.type)
  return static_cast< ::pb::ValueType >(type_);
}
inline void Signal::set_type(::pb::ValueType value) {
  assert(::pb::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.type)
}

// optional string name = 2;
inline bool Signal::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:pb.Signal.name)
  return *name_;
}
inline void Signal::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Signal.name)
}
inline void Signal::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Signal.name)
}
inline void Signal::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Signal.name)
}
inline ::std::string* Signal::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Signal.name)
  return name_;
}
inline ::std::string* Signal::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Signal::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Signal.name)
}

// optional fixed32 handle = 3;
inline bool Signal::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Signal::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Signal::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Signal::handle() const {
  // @@protoc_insertion_point(field_get:pb.Signal.handle)
  return handle_;
}
inline void Signal::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.handle)
}

// optional bool halbit = 5;
inline bool Signal::has_halbit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signal::set_has_halbit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Signal::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Signal::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Signal::halbit() const {
  // @@protoc_insertion_point(field_get:pb.Signal.halbit)
  return halbit_;
}
inline void Signal::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.halbit)
}

// optional double halfloat = 6;
inline bool Signal::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Signal::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Signal::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Signal::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Signal::halfloat() const {
  // @@protoc_insertion_point(field_get:pb.Signal.halfloat)
  return halfloat_;
}
inline void Signal::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Signal::has_hals32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Signal::set_has_hals32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Signal::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Signal::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Signal::hals32() const {
  // @@protoc_insertion_point(field_get:pb.Signal.hals32)
  return hals32_;
}
inline void Signal::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Signal::has_halu32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Signal::set_has_halu32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Signal::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Signal::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Signal::halu32() const {
  // @@protoc_insertion_point(field_get:pb.Signal.halu32)
  return halu32_;
}
inline void Signal::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.halu32)
}

// optional string strval = 9;
inline bool Signal::has_strval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Signal::set_has_strval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Signal::clear_has_strval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Signal::clear_strval() {
  if (strval_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_->clear();
  }
  clear_has_strval();
}
inline const ::std::string& Signal::strval() const {
  // @@protoc_insertion_point(field_get:pb.Signal.strval)
  return *strval_;
}
inline void Signal::set_strval(const ::std::string& value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Signal.strval)
}
inline void Signal::set_strval(const char* value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Signal.strval)
}
inline void Signal::set_strval(const char* value, size_t size) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Signal.strval)
}
inline ::std::string* Signal::mutable_strval() {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Signal.strval)
  return strval_;
}
inline ::std::string* Signal::release_strval() {
  clear_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = strval_;
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Signal::set_allocated_strval(::std::string* strval) {
  if (strval_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strval_;
  }
  if (strval) {
    set_has_strval();
    strval_ = strval;
  } else {
    clear_has_strval();
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Signal.strval)
}

// optional bytes blob = 10;
inline bool Signal::has_blob() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Signal::set_has_blob() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Signal::clear_has_blob() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Signal::clear_blob() {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_->clear();
  }
  clear_has_blob();
}
inline const ::std::string& Signal::blob() const {
  // @@protoc_insertion_point(field_get:pb.Signal.blob)
  return *blob_;
}
inline void Signal::set_blob(const ::std::string& value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Signal.blob)
}
inline void Signal::set_blob(const char* value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Signal.blob)
}
inline void Signal::set_blob(const void* value, size_t size) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Signal.blob)
}
inline ::std::string* Signal::mutable_blob() {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Signal.blob)
  return blob_;
}
inline ::std::string* Signal::release_blob() {
  clear_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blob_;
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Signal::set_allocated_blob(::std::string* blob) {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_;
  }
  if (blob) {
    set_has_blob();
    blob_ = blob;
  } else {
    clear_has_blob();
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Signal.blob)
}

// optional fixed32 readers = 11;
inline bool Signal::has_readers() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Signal::set_has_readers() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Signal::clear_has_readers() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Signal::clear_readers() {
  readers_ = 0u;
  clear_has_readers();
}
inline ::google::protobuf::uint32 Signal::readers() const {
  // @@protoc_insertion_point(field_get:pb.Signal.readers)
  return readers_;
}
inline void Signal::set_readers(::google::protobuf::uint32 value) {
  set_has_readers();
  readers_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.readers)
}

// optional fixed32 writers = 12;
inline bool Signal::has_writers() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Signal::set_has_writers() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Signal::clear_has_writers() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Signal::clear_writers() {
  writers_ = 0u;
  clear_has_writers();
}
inline ::google::protobuf::uint32 Signal::writers() const {
  // @@protoc_insertion_point(field_get:pb.Signal.writers)
  return writers_;
}
inline void Signal::set_writers(::google::protobuf::uint32 value) {
  set_has_writers();
  writers_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.writers)
}

// optional fixed32 bidirs = 13;
inline bool Signal::has_bidirs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Signal::set_has_bidirs() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Signal::clear_has_bidirs() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Signal::clear_bidirs() {
  bidirs_ = 0u;
  clear_has_bidirs();
}
inline ::google::protobuf::uint32 Signal::bidirs() const {
  // @@protoc_insertion_point(field_get:pb.Signal.bidirs)
  return bidirs_;
}
inline void Signal::set_bidirs(::google::protobuf::uint32 value) {
  set_has_bidirs();
  bidirs_ = value;
  // @@protoc_insertion_point(field_set:pb.Signal.bidirs)
}

// -------------------------------------------------------------------

// Param

// optional .pb.ValueType type = 1;
inline bool Param::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Param::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Param::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Param::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pb::ValueType Param::type() const {
  // @@protoc_insertion_point(field_get:pb.Param.type)
  return static_cast< ::pb::ValueType >(type_);
}
inline void Param::set_type(::pb::ValueType value) {
  assert(::pb::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.type)
}

// optional string name = 2;
inline bool Param::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Param::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Param::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Param::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Param::name() const {
  // @@protoc_insertion_point(field_get:pb.Param.name)
  return *name_;
}
inline void Param::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Param.name)
}
inline void Param::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Param.name)
}
inline void Param::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Param.name)
}
inline ::std::string* Param::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Param.name)
  return name_;
}
inline ::std::string* Param::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Param::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Param.name)
}

// optional fixed32 handle = 3;
inline bool Param::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Param::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Param::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Param::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Param::handle() const {
  // @@protoc_insertion_point(field_get:pb.Param.handle)
  return handle_;
}
inline void Param::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.handle)
}

// optional bool halbit = 5;
inline bool Param::has_halbit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Param::set_has_halbit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Param::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Param::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Param::halbit() const {
  // @@protoc_insertion_point(field_get:pb.Param.halbit)
  return halbit_;
}
inline void Param::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.halbit)
}

// optional double halfloat = 6;
inline bool Param::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Param::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Param::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Param::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Param::halfloat() const {
  // @@protoc_insertion_point(field_get:pb.Param.halfloat)
  return halfloat_;
}
inline void Param::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Param::has_hals32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Param::set_has_hals32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Param::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Param::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Param::hals32() const {
  // @@protoc_insertion_point(field_get:pb.Param.hals32)
  return hals32_;
}
inline void Param::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Param::has_halu32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Param::set_has_halu32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Param::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Param::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Param::halu32() const {
  // @@protoc_insertion_point(field_get:pb.Param.halu32)
  return halu32_;
}
inline void Param::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.halu32)
}

// optional string strval = 9;
inline bool Param::has_strval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Param::set_has_strval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Param::clear_has_strval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Param::clear_strval() {
  if (strval_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_->clear();
  }
  clear_has_strval();
}
inline const ::std::string& Param::strval() const {
  // @@protoc_insertion_point(field_get:pb.Param.strval)
  return *strval_;
}
inline void Param::set_strval(const ::std::string& value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Param.strval)
}
inline void Param::set_strval(const char* value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Param.strval)
}
inline void Param::set_strval(const char* value, size_t size) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  strval_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Param.strval)
}
inline ::std::string* Param::mutable_strval() {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    strval_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Param.strval)
  return strval_;
}
inline ::std::string* Param::release_strval() {
  clear_has_strval();
  if (strval_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = strval_;
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Param::set_allocated_strval(::std::string* strval) {
  if (strval_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete strval_;
  }
  if (strval) {
    set_has_strval();
    strval_ = strval;
  } else {
    clear_has_strval();
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Param.strval)
}

// optional bytes blob = 10;
inline bool Param::has_blob() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Param::set_has_blob() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Param::clear_has_blob() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Param::clear_blob() {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_->clear();
  }
  clear_has_blob();
}
inline const ::std::string& Param::blob() const {
  // @@protoc_insertion_point(field_get:pb.Param.blob)
  return *blob_;
}
inline void Param::set_blob(const ::std::string& value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Param.blob)
}
inline void Param::set_blob(const char* value) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Param.blob)
}
inline void Param::set_blob(const void* value, size_t size) {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  blob_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Param.blob)
}
inline ::std::string* Param::mutable_blob() {
  set_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    blob_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Param.blob)
  return blob_;
}
inline ::std::string* Param::release_blob() {
  clear_has_blob();
  if (blob_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = blob_;
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Param::set_allocated_blob(::std::string* blob) {
  if (blob_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete blob_;
  }
  if (blob) {
    set_has_blob();
    blob_ = blob;
  } else {
    clear_has_blob();
    blob_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Param.blob)
}

// optional .pb.HalParamDirection dir = 11;
inline bool Param::has_dir() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Param::set_has_dir() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Param::clear_has_dir() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Param::clear_dir() {
  dir_ = 64;
  clear_has_dir();
}
inline ::pb::HalParamDirection Param::dir() const {
  // @@protoc_insertion_point(field_get:pb.Param.dir)
  return static_cast< ::pb::HalParamDirection >(dir_);
}
inline void Param::set_dir(::pb::HalParamDirection value) {
  assert(::pb::HalParamDirection_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.dir)
}

// optional string oldname = 12;
inline bool Param::has_oldname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Param::set_has_oldname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Param::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Param::clear_oldname() {
  if (oldname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_->clear();
  }
  clear_has_oldname();
}
inline const ::std::string& Param::oldname() const {
  // @@protoc_insertion_point(field_get:pb.Param.oldname)
  return *oldname_;
}
inline void Param::set_oldname(const ::std::string& value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Param.oldname)
}
inline void Param::set_oldname(const char* value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Param.oldname)
}
inline void Param::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Param.oldname)
}
inline ::std::string* Param::mutable_oldname() {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Param.oldname)
  return oldname_;
}
inline ::std::string* Param::release_oldname() {
  clear_has_oldname();
  if (oldname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = oldname_;
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Param::set_allocated_oldname(::std::string* oldname) {
  if (oldname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete oldname_;
  }
  if (oldname) {
    set_has_oldname();
    oldname_ = oldname;
  } else {
    clear_has_oldname();
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Param.oldname)
}

// optional sfixed32 owner = 13;
inline bool Param::has_owner() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Param::set_has_owner() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Param::clear_has_owner() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Param::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Param::owner() const {
  // @@protoc_insertion_point(field_get:pb.Param.owner)
  return owner_;
}
inline void Param::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.owner)
}

// optional sfixed32 runtime = 14;
inline bool Param::has_runtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Param::set_has_runtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Param::clear_has_runtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Param::clear_runtime() {
  runtime_ = 0;
  clear_has_runtime();
}
inline ::google::protobuf::int32 Param::runtime() const {
  // @@protoc_insertion_point(field_get:pb.Param.runtime)
  return runtime_;
}
inline void Param::set_runtime(::google::protobuf::int32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.runtime)
}

// optional sfixed32 maytime = 15;
inline bool Param::has_maytime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Param::set_has_maytime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Param::clear_has_maytime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Param::clear_maytime() {
  maytime_ = 0;
  clear_has_maytime();
}
inline ::google::protobuf::int32 Param::maytime() const {
  // @@protoc_insertion_point(field_get:pb.Param.maytime)
  return maytime_;
}
inline void Param::set_maytime(::google::protobuf::int32 value) {
  set_has_maytime();
  maytime_ = value;
  // @@protoc_insertion_point(field_set:pb.Param.maytime)
}

// -------------------------------------------------------------------

// Function

// optional string name = 1;
inline bool Function::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Function::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Function::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Function::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Function::name() const {
  // @@protoc_insertion_point(field_get:pb.Function.name)
  return *name_;
}
inline void Function::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Function.name)
}
inline void Function::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Function.name)
}
inline void Function::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Function.name)
}
inline ::std::string* Function::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Function.name)
  return name_;
}
inline ::std::string* Function::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Function::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Function.name)
}

// optional fixed32 handle = 2;
inline bool Function::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Function::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Function::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Function::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Function::handle() const {
  // @@protoc_insertion_point(field_get:pb.Function.handle)
  return handle_;
}
inline void Function::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.handle)
}

// optional fixed32 owner_id = 3;
inline bool Function::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Function::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Function::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Function::clear_owner_id() {
  owner_id_ = 0u;
  clear_has_owner_id();
}
inline ::google::protobuf::uint32 Function::owner_id() const {
  // @@protoc_insertion_point(field_get:pb.Function.owner_id)
  return owner_id_;
}
inline void Function::set_owner_id(::google::protobuf::uint32 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.owner_id)
}

// optional fixed32 users = 4;
inline bool Function::has_users() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Function::set_has_users() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Function::clear_has_users() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Function::clear_users() {
  users_ = 0u;
  clear_has_users();
}
inline ::google::protobuf::uint32 Function::users() const {
  // @@protoc_insertion_point(field_get:pb.Function.users)
  return users_;
}
inline void Function::set_users(::google::protobuf::uint32 value) {
  set_has_users();
  users_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.users)
}

// optional fixed32 runtime = 5;
inline bool Function::has_runtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Function::set_has_runtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Function::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Function::clear_runtime() {
  runtime_ = 0u;
  clear_has_runtime();
}
inline ::google::protobuf::uint32 Function::runtime() const {
  // @@protoc_insertion_point(field_get:pb.Function.runtime)
  return runtime_;
}
inline void Function::set_runtime(::google::protobuf::uint32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.runtime)
}

// optional fixed32 maxtime = 6;
inline bool Function::has_maxtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Function::set_has_maxtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Function::clear_has_maxtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Function::clear_maxtime() {
  maxtime_ = 0u;
  clear_has_maxtime();
}
inline ::google::protobuf::uint32 Function::maxtime() const {
  // @@protoc_insertion_point(field_get:pb.Function.maxtime)
  return maxtime_;
}
inline void Function::set_maxtime(::google::protobuf::uint32 value) {
  set_has_maxtime();
  maxtime_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.maxtime)
}

// optional bool reentrant = 7;
inline bool Function::has_reentrant() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Function::set_has_reentrant() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Function::clear_has_reentrant() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Function::clear_reentrant() {
  reentrant_ = false;
  clear_has_reentrant();
}
inline bool Function::reentrant() const {
  // @@protoc_insertion_point(field_get:pb.Function.reentrant)
  return reentrant_;
}
inline void Function::set_reentrant(bool value) {
  set_has_reentrant();
  reentrant_ = value;
  // @@protoc_insertion_point(field_set:pb.Function.reentrant)
}

// -------------------------------------------------------------------

// Thread

// optional string name = 1;
inline bool Thread::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thread::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thread::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thread::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Thread::name() const {
  // @@protoc_insertion_point(field_get:pb.Thread.name)
  return *name_;
}
inline void Thread::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Thread.name)
}
inline void Thread::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Thread.name)
}
inline void Thread::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Thread.name)
}
inline ::std::string* Thread::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Thread.name)
  return name_;
}
inline ::std::string* Thread::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Thread::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Thread.name)
}

// optional fixed32 handle = 2;
inline bool Thread::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thread::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thread::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thread::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Thread::handle() const {
  // @@protoc_insertion_point(field_get:pb.Thread.handle)
  return handle_;
}
inline void Thread::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.handle)
}

// optional bool uses_fp = 3;
inline bool Thread::has_uses_fp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thread::set_has_uses_fp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thread::clear_has_uses_fp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thread::clear_uses_fp() {
  uses_fp_ = false;
  clear_has_uses_fp();
}
inline bool Thread::uses_fp() const {
  // @@protoc_insertion_point(field_get:pb.Thread.uses_fp)
  return uses_fp_;
}
inline void Thread::set_uses_fp(bool value) {
  set_has_uses_fp();
  uses_fp_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.uses_fp)
}

// optional fixed32 period = 4;
inline bool Thread::has_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Thread::set_has_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Thread::clear_has_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Thread::clear_period() {
  period_ = 0u;
  clear_has_period();
}
inline ::google::protobuf::uint32 Thread::period() const {
  // @@protoc_insertion_point(field_get:pb.Thread.period)
  return period_;
}
inline void Thread::set_period(::google::protobuf::uint32 value) {
  set_has_period();
  period_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.period)
}

// optional sfixed32 priority = 5;
inline bool Thread::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Thread::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Thread::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Thread::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Thread::priority() const {
  // @@protoc_insertion_point(field_get:pb.Thread.priority)
  return priority_;
}
inline void Thread::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.priority)
}

// optional fixed32 task_id = 6;
inline bool Thread::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Thread::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Thread::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Thread::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 Thread::task_id() const {
  // @@protoc_insertion_point(field_get:pb.Thread.task_id)
  return task_id_;
}
inline void Thread::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.task_id)
}

// optional fixed32 cpu_id = 7;
inline bool Thread::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Thread::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Thread::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Thread::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 Thread::cpu_id() const {
  // @@protoc_insertion_point(field_get:pb.Thread.cpu_id)
  return cpu_id_;
}
inline void Thread::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Thread.cpu_id)
}

// repeated string function = 8;
inline int Thread::function_size() const {
  return function_.size();
}
inline void Thread::clear_function() {
  function_.Clear();
}
inline const ::std::string& Thread::function(int index) const {
  // @@protoc_insertion_point(field_get:pb.Thread.function)
  return function_.Get(index);
}
inline ::std::string* Thread::mutable_function(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Thread.function)
  return function_.Mutable(index);
}
inline void Thread::set_function(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Thread.function)
  function_.Mutable(index)->assign(value);
}
inline void Thread::set_function(int index, const char* value) {
  function_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Thread.function)
}
inline void Thread::set_function(int index, const char* value, size_t size) {
  function_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Thread.function)
}
inline ::std::string* Thread::add_function() {
  return function_.Add();
}
inline void Thread::add_function(const ::std::string& value) {
  function_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Thread.function)
}
inline void Thread::add_function(const char* value) {
  function_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Thread.function)
}
inline void Thread::add_function(const char* value, size_t size) {
  function_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Thread.function)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Thread::function() const {
  // @@protoc_insertion_point(field_list:pb.Thread.function)
  return function_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Thread::mutable_function() {
  // @@protoc_insertion_point(field_mutable_list:pb.Thread.function)
  return &function_;
}

// -------------------------------------------------------------------

// Component

// optional string name = 1;
inline bool Component::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Component::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Component::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Component::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Component::name() const {
  // @@protoc_insertion_point(field_get:pb.Component.name)
  return *name_;
}
inline void Component::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Component.name)
}
inline void Component::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Component.name)
}
inline void Component::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Component.name)
}
inline ::std::string* Component::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Component.name)
  return name_;
}
inline ::std::string* Component::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Component::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Component.name)
}

// optional fixed32 ninst = 2;
inline bool Component::has_ninst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Component::set_has_ninst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Component::clear_has_ninst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Component::clear_ninst() {
  ninst_ = 0u;
  clear_has_ninst();
}
inline ::google::protobuf::uint32 Component::ninst() const {
  // @@protoc_insertion_point(field_get:pb.Component.ninst)
  return ninst_;
}
inline void Component::set_ninst(::google::protobuf::uint32 value) {
  set_has_ninst();
  ninst_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.ninst)
}

// optional sfixed32 comp_id = 4;
inline bool Component::has_comp_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Component::set_has_comp_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Component::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Component::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Component::comp_id() const {
  // @@protoc_insertion_point(field_get:pb.Component.comp_id)
  return comp_id_;
}
inline void Component::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.comp_id)
}

// optional fixed32 type = 5;
inline bool Component::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Component::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Component::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Component::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Component::type() const {
  // @@protoc_insertion_point(field_get:pb.Component.type)
  return type_;
}
inline void Component::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.type)
}

// optional fixed32 state = 6;
inline bool Component::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Component::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Component::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Component::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 Component::state() const {
  // @@protoc_insertion_point(field_get:pb.Component.state)
  return state_;
}
inline void Component::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.state)
}

// optional fixed32 last_update = 7;
inline bool Component::has_last_update() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Component::set_has_last_update() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Component::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Component::clear_last_update() {
  last_update_ = 0u;
  clear_has_last_update();
}
inline ::google::protobuf::uint32 Component::last_update() const {
  // @@protoc_insertion_point(field_get:pb.Component.last_update)
  return last_update_;
}
inline void Component::set_last_update(::google::protobuf::uint32 value) {
  set_has_last_update();
  last_update_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.last_update)
}

// optional fixed32 last_bound = 8;
inline bool Component::has_last_bound() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Component::set_has_last_bound() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Component::clear_has_last_bound() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Component::clear_last_bound() {
  last_bound_ = 0u;
  clear_has_last_bound();
}
inline ::google::protobuf::uint32 Component::last_bound() const {
  // @@protoc_insertion_point(field_get:pb.Component.last_bound)
  return last_bound_;
}
inline void Component::set_last_bound(::google::protobuf::uint32 value) {
  set_has_last_bound();
  last_bound_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.last_bound)
}

// optional fixed32 last_unbound = 9;
inline bool Component::has_last_unbound() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Component::set_has_last_unbound() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Component::clear_has_last_unbound() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Component::clear_last_unbound() {
  last_unbound_ = 0u;
  clear_has_last_unbound();
}
inline ::google::protobuf::uint32 Component::last_unbound() const {
  // @@protoc_insertion_point(field_get:pb.Component.last_unbound)
  return last_unbound_;
}
inline void Component::set_last_unbound(::google::protobuf::uint32 value) {
  set_has_last_unbound();
  last_unbound_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.last_unbound)
}

// optional fixed32 pid = 10;
inline bool Component::has_pid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Component::set_has_pid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Component::clear_has_pid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Component::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 Component::pid() const {
  // @@protoc_insertion_point(field_get:pb.Component.pid)
  return pid_;
}
inline void Component::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.pid)
}

// optional string args = 11;
inline bool Component::has_args() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Component::set_has_args() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Component::clear_has_args() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Component::clear_args() {
  if (args_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_->clear();
  }
  clear_has_args();
}
inline const ::std::string& Component::args() const {
  // @@protoc_insertion_point(field_get:pb.Component.args)
  return *args_;
}
inline void Component::set_args(const ::std::string& value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Component.args)
}
inline void Component::set_args(const char* value) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Component.args)
}
inline void Component::set_args(const char* value, size_t size) {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  args_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Component.args)
}
inline ::std::string* Component::mutable_args() {
  set_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    args_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Component.args)
  return args_;
}
inline ::std::string* Component::release_args() {
  clear_has_args();
  if (args_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = args_;
    args_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Component::set_allocated_args(::std::string* args) {
  if (args_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete args_;
  }
  if (args) {
    set_has_args();
    args_ = args;
  } else {
    clear_has_args();
    args_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Component.args)
}

// optional sfixed32 timer = 12;
inline bool Component::has_timer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Component::set_has_timer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Component::clear_has_timer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Component::clear_timer() {
  timer_ = 0;
  clear_has_timer();
}
inline ::google::protobuf::int32 Component::timer() const {
  // @@protoc_insertion_point(field_get:pb.Component.timer)
  return timer_;
}
inline void Component::set_timer(::google::protobuf::int32 value) {
  set_has_timer();
  timer_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.timer)
}

// optional sfixed32 userarg1 = 14;
inline bool Component::has_userarg1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Component::set_has_userarg1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Component::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Component::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Component::userarg1() const {
  // @@protoc_insertion_point(field_get:pb.Component.userarg1)
  return userarg1_;
}
inline void Component::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.userarg1)
}

// optional sfixed32 userarg2 = 15;
inline bool Component::has_userarg2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Component::set_has_userarg2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Component::clear_has_userarg2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Component::clear_userarg2() {
  userarg2_ = 0;
  clear_has_userarg2();
}
inline ::google::protobuf::int32 Component::userarg2() const {
  // @@protoc_insertion_point(field_get:pb.Component.userarg2)
  return userarg2_;
}
inline void Component::set_userarg2(::google::protobuf::int32 value) {
  set_has_userarg2();
  userarg2_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.userarg2)
}

// repeated .pb.Pin pin = 16;
inline int Component::pin_size() const {
  return pin_.size();
}
inline void Component::clear_pin() {
  pin_.Clear();
}
inline const ::pb::Pin& Component::pin(int index) const {
  // @@protoc_insertion_point(field_get:pb.Component.pin)
  return pin_.Get(index);
}
inline ::pb::Pin* Component::mutable_pin(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Component.pin)
  return pin_.Mutable(index);
}
inline ::pb::Pin* Component::add_pin() {
  // @@protoc_insertion_point(field_add:pb.Component.pin)
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Pin >&
Component::pin() const {
  // @@protoc_insertion_point(field_list:pb.Component.pin)
  return pin_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Pin >*
Component::mutable_pin() {
  // @@protoc_insertion_point(field_mutable_list:pb.Component.pin)
  return &pin_;
}

// repeated .pb.Param param = 17;
inline int Component::param_size() const {
  return param_.size();
}
inline void Component::clear_param() {
  param_.Clear();
}
inline const ::pb::Param& Component::param(int index) const {
  // @@protoc_insertion_point(field_get:pb.Component.param)
  return param_.Get(index);
}
inline ::pb::Param* Component::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Component.param)
  return param_.Mutable(index);
}
inline ::pb::Param* Component::add_param() {
  // @@protoc_insertion_point(field_add:pb.Component.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Param >&
Component::param() const {
  // @@protoc_insertion_point(field_list:pb.Component.param)
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Param >*
Component::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:pb.Component.param)
  return &param_;
}

// optional bool no_create = 18;
inline bool Component::has_no_create() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Component::set_has_no_create() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Component::clear_has_no_create() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Component::clear_no_create() {
  no_create_ = false;
  clear_has_no_create();
}
inline bool Component::no_create() const {
  // @@protoc_insertion_point(field_get:pb.Component.no_create)
  return no_create_;
}
inline void Component::set_no_create(bool value) {
  set_has_no_create();
  no_create_ = value;
  // @@protoc_insertion_point(field_set:pb.Component.no_create)
}

// -------------------------------------------------------------------

// Ring

// optional string name = 1;
inline bool Ring::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ring::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ring::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ring::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Ring::name() const {
  // @@protoc_insertion_point(field_get:pb.Ring.name)
  return *name_;
}
inline void Ring::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Ring.name)
}
inline void Ring::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Ring.name)
}
inline void Ring::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Ring.name)
}
inline ::std::string* Ring::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Ring.name)
  return name_;
}
inline ::std::string* Ring::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Ring::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Ring.name)
}

// optional fixed32 handle = 2;
inline bool Ring::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ring::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ring::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ring::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Ring::handle() const {
  // @@protoc_insertion_point(field_get:pb.Ring.handle)
  return handle_;
}
inline void Ring::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.handle)
}

// optional sfixed32 owner = 3;
inline bool Ring::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ring::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ring::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ring::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Ring::owner() const {
  // @@protoc_insertion_point(field_get:pb.Ring.owner)
  return owner_;
}
inline void Ring::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.owner)
}

// optional bool stream = 4;
inline bool Ring::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ring::set_has_stream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ring::clear_has_stream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ring::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool Ring::stream() const {
  // @@protoc_insertion_point(field_get:pb.Ring.stream)
  return stream_;
}
inline void Ring::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.stream)
}

// optional bool wmutex = 5;
inline bool Ring::has_wmutex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ring::set_has_wmutex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ring::clear_has_wmutex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ring::clear_wmutex() {
  wmutex_ = false;
  clear_has_wmutex();
}
inline bool Ring::wmutex() const {
  // @@protoc_insertion_point(field_get:pb.Ring.wmutex)
  return wmutex_;
}
inline void Ring::set_wmutex(bool value) {
  set_has_wmutex();
  wmutex_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.wmutex)
}

// optional bool rmutex = 6;
inline bool Ring::has_rmutex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ring::set_has_rmutex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ring::clear_has_rmutex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ring::clear_rmutex() {
  rmutex_ = false;
  clear_has_rmutex();
}
inline bool Ring::rmutex() const {
  // @@protoc_insertion_point(field_get:pb.Ring.rmutex)
  return rmutex_;
}
inline void Ring::set_rmutex(bool value) {
  set_has_rmutex();
  rmutex_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.rmutex)
}

// optional bool rtapi_shm = 7;
inline bool Ring::has_rtapi_shm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ring::set_has_rtapi_shm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ring::clear_has_rtapi_shm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ring::clear_rtapi_shm() {
  rtapi_shm_ = false;
  clear_has_rtapi_shm();
}
inline bool Ring::rtapi_shm() const {
  // @@protoc_insertion_point(field_get:pb.Ring.rtapi_shm)
  return rtapi_shm_;
}
inline void Ring::set_rtapi_shm(bool value) {
  set_has_rtapi_shm();
  rtapi_shm_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.rtapi_shm)
}

// optional sfixed32 reader = 8;
inline bool Ring::has_reader() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ring::set_has_reader() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ring::clear_has_reader() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ring::clear_reader() {
  reader_ = 0;
  clear_has_reader();
}
inline ::google::protobuf::int32 Ring::reader() const {
  // @@protoc_insertion_point(field_get:pb.Ring.reader)
  return reader_;
}
inline void Ring::set_reader(::google::protobuf::int32 value) {
  set_has_reader();
  reader_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.reader)
}

// optional sfixed32 writer = 9;
inline bool Ring::has_writer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ring::set_has_writer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ring::clear_has_writer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ring::clear_writer() {
  writer_ = 0;
  clear_has_writer();
}
inline ::google::protobuf::int32 Ring::writer() const {
  // @@protoc_insertion_point(field_get:pb.Ring.writer)
  return writer_;
}
inline void Ring::set_writer(::google::protobuf::int32 value) {
  set_has_writer();
  writer_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.writer)
}

// optional sfixed32 size = 10;
inline bool Ring::has_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ring::set_has_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ring::clear_has_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ring::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Ring::size() const {
  // @@protoc_insertion_point(field_get:pb.Ring.size)
  return size_;
}
inline void Ring::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.size)
}

// optional sfixed32 scratchpad = 11;
inline bool Ring::has_scratchpad() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ring::set_has_scratchpad() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ring::clear_has_scratchpad() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ring::clear_scratchpad() {
  scratchpad_ = 0;
  clear_has_scratchpad();
}
inline ::google::protobuf::int32 Ring::scratchpad() const {
  // @@protoc_insertion_point(field_get:pb.Ring.scratchpad)
  return scratchpad_;
}
inline void Ring::set_scratchpad(::google::protobuf::int32 value) {
  set_has_scratchpad();
  scratchpad_ = value;
  // @@protoc_insertion_point(field_set:pb.Ring.scratchpad)
}

// -------------------------------------------------------------------

// Member

// optional .pb.ObjectType mtype = 1;
inline bool Member::has_mtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_mtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_mtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_mtype() {
  mtype_ = 1;
  clear_has_mtype();
}
inline ::pb::ObjectType Member::mtype() const {
  // @@protoc_insertion_point(field_get:pb.Member.mtype)
  return static_cast< ::pb::ObjectType >(mtype_);
}
inline void Member::set_mtype(::pb::ObjectType value) {
  assert(::pb::ObjectType_IsValid(value));
  set_has_mtype();
  mtype_ = value;
  // @@protoc_insertion_point(field_set:pb.Member.mtype)
}

// optional sfixed32 userarg1 = 2;
inline bool Member::has_userarg1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Member::set_has_userarg1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Member::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Member::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Member::userarg1() const {
  // @@protoc_insertion_point(field_get:pb.Member.userarg1)
  return userarg1_;
}
inline void Member::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:pb.Member.userarg1)
}

// optional double epsilon = 3;
inline bool Member::has_epsilon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Member::set_has_epsilon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Member::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Member::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Member::epsilon() const {
  // @@protoc_insertion_point(field_get:pb.Member.epsilon)
  return epsilon_;
}
inline void Member::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:pb.Member.epsilon)
}

// optional .pb.Signal signal = 4;
inline bool Member::has_signal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Member::set_has_signal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Member::clear_has_signal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Member::clear_signal() {
  if (signal_ != NULL) signal_->::pb::Signal::Clear();
  clear_has_signal();
}
inline const ::pb::Signal& Member::signal() const {
  // @@protoc_insertion_point(field_get:pb.Member.signal)
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::pb::Signal* Member::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::pb::Signal;
  // @@protoc_insertion_point(field_mutable:pb.Member.signal)
  return signal_;
}
inline ::pb::Signal* Member::release_signal() {
  clear_has_signal();
  ::pb::Signal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void Member::set_allocated_signal(::pb::Signal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Member.signal)
}

// optional string groupname = 5;
inline bool Member::has_groupname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Member::set_has_groupname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Member::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Member::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& Member::groupname() const {
  // @@protoc_insertion_point(field_get:pb.Member.groupname)
  return *groupname_;
}
inline void Member::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Member.groupname)
}
inline void Member::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Member.groupname)
}
inline void Member::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Member.groupname)
}
inline ::std::string* Member::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Member.groupname)
  return groupname_;
}
inline ::std::string* Member::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Member::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Member.groupname)
}

// optional fixed32 handle = 6;
inline bool Member::has_handle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Member::set_has_handle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Member::clear_has_handle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Member::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Member::handle() const {
  // @@protoc_insertion_point(field_get:pb.Member.handle)
  return handle_;
}
inline void Member::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Member.handle)
}

// optional .pb.Pin pin = 7;
inline bool Member::has_pin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Member::set_has_pin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Member::clear_has_pin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Member::clear_pin() {
  if (pin_ != NULL) pin_->::pb::Pin::Clear();
  clear_has_pin();
}
inline const ::pb::Pin& Member::pin() const {
  // @@protoc_insertion_point(field_get:pb.Member.pin)
  return pin_ != NULL ? *pin_ : *default_instance_->pin_;
}
inline ::pb::Pin* Member::mutable_pin() {
  set_has_pin();
  if (pin_ == NULL) pin_ = new ::pb::Pin;
  // @@protoc_insertion_point(field_mutable:pb.Member.pin)
  return pin_;
}
inline ::pb::Pin* Member::release_pin() {
  clear_has_pin();
  ::pb::Pin* temp = pin_;
  pin_ = NULL;
  return temp;
}
inline void Member::set_allocated_pin(::pb::Pin* pin) {
  delete pin_;
  pin_ = pin;
  if (pin) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Member.pin)
}

// optional .pb.Param param = 8;
inline bool Member::has_param() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Member::set_has_param() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Member::clear_has_param() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Member::clear_param() {
  if (param_ != NULL) param_->::pb::Param::Clear();
  clear_has_param();
}
inline const ::pb::Param& Member::param() const {
  // @@protoc_insertion_point(field_get:pb.Member.param)
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::pb::Param* Member::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::pb::Param;
  // @@protoc_insertion_point(field_mutable:pb.Member.param)
  return param_;
}
inline ::pb::Param* Member::release_param() {
  clear_has_param();
  ::pb::Param* temp = param_;
  param_ = NULL;
  return temp;
}
inline void Member::set_allocated_param(::pb::Param* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Member.param)
}

// -------------------------------------------------------------------

// Group

// optional string name = 1;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:pb.Group.name)
  return *name_;
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Group.name)
}
inline void Group::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Group.name)
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Group.name)
  return name_;
}
inline ::std::string* Group::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Group.name)
}

// optional fixed32 handle = 2;
inline bool Group::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Group::handle() const {
  // @@protoc_insertion_point(field_get:pb.Group.handle)
  return handle_;
}
inline void Group::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Group.handle)
}

// optional sfixed32 userarg1 = 4;
inline bool Group::has_userarg1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_userarg1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Group::userarg1() const {
  // @@protoc_insertion_point(field_get:pb.Group.userarg1)
  return userarg1_;
}
inline void Group::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:pb.Group.userarg1)
}

// optional sfixed32 userarg2 = 5;
inline bool Group::has_userarg2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Group::set_has_userarg2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Group::clear_has_userarg2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Group::clear_userarg2() {
  userarg2_ = 0;
  clear_has_userarg2();
}
inline ::google::protobuf::int32 Group::userarg2() const {
  // @@protoc_insertion_point(field_get:pb.Group.userarg2)
  return userarg2_;
}
inline void Group::set_userarg2(::google::protobuf::int32 value) {
  set_has_userarg2();
  userarg2_ = value;
  // @@protoc_insertion_point(field_set:pb.Group.userarg2)
}

// optional sfixed32 refcount = 6;
inline bool Group::has_refcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Group::set_has_refcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Group::clear_has_refcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Group::clear_refcount() {
  refcount_ = 0;
  clear_has_refcount();
}
inline ::google::protobuf::int32 Group::refcount() const {
  // @@protoc_insertion_point(field_get:pb.Group.refcount)
  return refcount_;
}
inline void Group::set_refcount(::google::protobuf::int32 value) {
  set_has_refcount();
  refcount_ = value;
  // @@protoc_insertion_point(field_set:pb.Group.refcount)
}

// repeated .pb.Member member = 7;
inline int Group::member_size() const {
  return member_.size();
}
inline void Group::clear_member() {
  member_.Clear();
}
inline const ::pb::Member& Group::member(int index) const {
  // @@protoc_insertion_point(field_get:pb.Group.member)
  return member_.Get(index);
}
inline ::pb::Member* Group::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Group.member)
  return member_.Mutable(index);
}
inline ::pb::Member* Group::add_member() {
  // @@protoc_insertion_point(field_add:pb.Group.member)
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Member >&
Group::member() const {
  // @@protoc_insertion_point(field_list:pb.Group.member)
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Member >*
Group::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:pb.Group.member)
  return &member_;
}

// -------------------------------------------------------------------

// ProtocolParameters

// optional sfixed32 keepalive_timer = 1;
inline bool ProtocolParameters::has_keepalive_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolParameters::set_has_keepalive_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolParameters::clear_has_keepalive_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolParameters::clear_keepalive_timer() {
  keepalive_timer_ = 0;
  clear_has_keepalive_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::keepalive_timer() const {
  // @@protoc_insertion_point(field_get:pb.ProtocolParameters.keepalive_timer)
  return keepalive_timer_;
}
inline void ProtocolParameters::set_keepalive_timer(::google::protobuf::int32 value) {
  set_has_keepalive_timer();
  keepalive_timer_ = value;
  // @@protoc_insertion_point(field_set:pb.ProtocolParameters.keepalive_timer)
}

// optional sfixed32 group_timer = 2;
inline bool ProtocolParameters::has_group_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolParameters::set_has_group_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolParameters::clear_has_group_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolParameters::clear_group_timer() {
  group_timer_ = 0;
  clear_has_group_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::group_timer() const {
  // @@protoc_insertion_point(field_get:pb.ProtocolParameters.group_timer)
  return group_timer_;
}
inline void ProtocolParameters::set_group_timer(::google::protobuf::int32 value) {
  set_has_group_timer();
  group_timer_ = value;
  // @@protoc_insertion_point(field_set:pb.ProtocolParameters.group_timer)
}

// optional sfixed32 rcomp_timer = 3;
inline bool ProtocolParameters::has_rcomp_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolParameters::set_has_rcomp_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolParameters::clear_has_rcomp_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolParameters::clear_rcomp_timer() {
  rcomp_timer_ = 0;
  clear_has_rcomp_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::rcomp_timer() const {
  // @@protoc_insertion_point(field_get:pb.ProtocolParameters.rcomp_timer)
  return rcomp_timer_;
}
inline void ProtocolParameters::set_rcomp_timer(::google::protobuf::int32 value) {
  set_has_rcomp_timer();
  rcomp_timer_ = value;
  // @@protoc_insertion_point(field_set:pb.ProtocolParameters.rcomp_timer)
}

// -------------------------------------------------------------------

// Vtable

// optional string name = 1;
inline bool Vtable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vtable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vtable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vtable::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Vtable::name() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.name)
  return *name_;
}
inline void Vtable::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Vtable.name)
}
inline void Vtable::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Vtable.name)
}
inline void Vtable::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Vtable.name)
}
inline ::std::string* Vtable::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Vtable.name)
  return name_;
}
inline ::std::string* Vtable::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Vtable::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Vtable.name)
}

// optional fixed32 context = 2;
inline bool Vtable::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vtable::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vtable::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vtable::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 Vtable::context() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.context)
  return context_;
}
inline void Vtable::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.context)
}

// optional sfixed32 comp_id = 4;
inline bool Vtable::has_comp_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vtable::set_has_comp_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vtable::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vtable::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Vtable::comp_id() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.comp_id)
  return comp_id_;
}
inline void Vtable::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.comp_id)
}

// optional sfixed32 instance_id = 5;
inline bool Vtable::has_instance_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vtable::set_has_instance_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vtable::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vtable::clear_instance_id() {
  instance_id_ = 0;
  clear_has_instance_id();
}
inline ::google::protobuf::int32 Vtable::instance_id() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.instance_id)
  return instance_id_;
}
inline void Vtable::set_instance_id(::google::protobuf::int32 value) {
  set_has_instance_id();
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.instance_id)
}

// optional fixed32 handle = 6;
inline bool Vtable::has_handle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vtable::set_has_handle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vtable::clear_has_handle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vtable::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Vtable::handle() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.handle)
  return handle_;
}
inline void Vtable::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.handle)
}

// optional sfixed32 refcount = 7;
inline bool Vtable::has_refcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vtable::set_has_refcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vtable::clear_has_refcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vtable::clear_refcount() {
  refcount_ = 0;
  clear_has_refcount();
}
inline ::google::protobuf::int32 Vtable::refcount() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.refcount)
  return refcount_;
}
inline void Vtable::set_refcount(::google::protobuf::int32 value) {
  set_has_refcount();
  refcount_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.refcount)
}

// optional sfixed32 version = 8;
inline bool Vtable::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Vtable::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Vtable::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Vtable::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Vtable::version() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.version)
  return version_;
}
inline void Vtable::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.version)
}

// optional fixed64 vtable = 9;
inline bool Vtable::has_vtable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Vtable::set_has_vtable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Vtable::clear_has_vtable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Vtable::clear_vtable() {
  vtable_ = GOOGLE_ULONGLONG(0);
  clear_has_vtable();
}
inline ::google::protobuf::uint64 Vtable::vtable() const {
  // @@protoc_insertion_point(field_get:pb.Vtable.vtable)
  return vtable_;
}
inline void Vtable::set_vtable(::google::protobuf::uint64 value) {
  set_has_vtable();
  vtable_ = value;
  // @@protoc_insertion_point(field_set:pb.Vtable.vtable)
}

// -------------------------------------------------------------------

// Inst

// optional string name = 1;
inline bool Inst::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Inst::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Inst::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Inst::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Inst::name() const {
  // @@protoc_insertion_point(field_get:pb.Inst.name)
  return *name_;
}
inline void Inst::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:pb.Inst.name)
}
inline void Inst::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Inst.name)
}
inline void Inst::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Inst.name)
}
inline ::std::string* Inst::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pb.Inst.name)
  return name_;
}
inline ::std::string* Inst::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Inst::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pb.Inst.name)
}

// optional sfixed32 comp_id = 2;
inline bool Inst::has_comp_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Inst::set_has_comp_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Inst::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Inst::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Inst::comp_id() const {
  // @@protoc_insertion_point(field_get:pb.Inst.comp_id)
  return comp_id_;
}
inline void Inst::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Inst.comp_id)
}

// optional fixed32 inst_id = 3;
inline bool Inst::has_inst_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Inst::set_has_inst_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Inst::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Inst::clear_inst_id() {
  inst_id_ = 0u;
  clear_has_inst_id();
}
inline ::google::protobuf::uint32 Inst::inst_id() const {
  // @@protoc_insertion_point(field_get:pb.Inst.inst_id)
  return inst_id_;
}
inline void Inst::set_inst_id(::google::protobuf::uint32 value) {
  set_has_inst_id();
  inst_id_ = value;
  // @@protoc_insertion_point(field_set:pb.Inst.inst_id)
}

// optional fixed32 inst_size = 4;
inline bool Inst::has_inst_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Inst::set_has_inst_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Inst::clear_has_inst_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Inst::clear_inst_size() {
  inst_size_ = 0u;
  clear_has_inst_size();
}
inline ::google::protobuf::uint32 Inst::inst_size() const {
  // @@protoc_insertion_point(field_get:pb.Inst.inst_size)
  return inst_size_;
}
inline void Inst::set_inst_size(::google::protobuf::uint32 value) {
  set_has_inst_size();
  inst_size_ = value;
  // @@protoc_insertion_point(field_set:pb.Inst.inst_size)
}

// optional fixed64 vtable = 5;
inline bool Inst::has_vtable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Inst::set_has_vtable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Inst::clear_has_vtable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Inst::clear_vtable() {
  vtable_ = GOOGLE_ULONGLONG(0);
  clear_has_vtable();
}
inline ::google::protobuf::uint64 Inst::vtable() const {
  // @@protoc_insertion_point(field_get:pb.Inst.vtable)
  return vtable_;
}
inline void Inst::set_vtable(::google::protobuf::uint64 value) {
  set_has_vtable();
  vtable_ = value;
  // @@protoc_insertion_point(field_set:pb.Inst.vtable)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_object_2eproto__INCLUDED
